"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
class FindReferencesAdapter {
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing a referencesProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.referencesProvider === true;
    }
    // Public: Get the references for a specific symbol within the document as represented by
    // the {TextEditor} and {Point} within it via the language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will be queried
    //                for the references.
    // * `editor` The Atom {TextEditor} containing the text the references should relate to.
    // * `point` The Atom {Point} containing the point within the text the references should relate to.
    //
    // Returns a {Promise} containing a {FindReferencesReturn} with all the references the language server
    // could find.
    getReferences(connection, editor, point, projectRoot) {
        return __awaiter(this, void 0, void 0, function* () {
            const locations = yield connection.findReferences(FindReferencesAdapter.createReferenceParams(editor, point));
            if (locations == null) {
                return null;
            }
            const references = locations.map(FindReferencesAdapter.locationToReference);
            return {
                type: 'data',
                baseUri: projectRoot || '',
                referencedSymbolName: FindReferencesAdapter.getReferencedSymbolName(editor, point, references),
                references,
            };
        });
    }
    // Public: Create a {ReferenceParams} from a given {TextEditor} for a specific {Point}.
    //
    // * `editor` A {TextEditor} that represents the document.
    // * `point` A {Point} within the document.
    //
    // Returns a {ReferenceParams} built from the given parameters.
    static createReferenceParams(editor, point) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            position: convert_1.default.pointToPosition(point),
            context: { includeDeclaration: true },
        };
    }
    // Public: Convert a {Location} into a {Reference}.
    //
    // * `location` A {Location} to convert.
    //
    // Returns a {Reference} equivalent to the given {Location}.
    static locationToReference(location) {
        return {
            uri: convert_1.default.uriToPath(location.uri),
            name: null,
            range: convert_1.default.lsRangeToAtomRange(location.range),
        };
    }
    // Public: Get a symbol name from a {TextEditor} for a specific {Point} in the document.
    static getReferencedSymbolName(editor, point, references) {
        if (references.length === 0) {
            return '';
        }
        const currentReference = references.find((r) => r.range.containsPoint(point)) || references[0];
        return editor.getBuffer().getTextInRange(currentReference.range);
    }
}
exports.default = FindReferencesAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBLHdDQUFpQztBQVlqQyxnRUFBZ0U7QUFDaEUsd0VBQXdFO0FBQ3hFO0lBQ0UsZ0ZBQWdGO0lBQ2hGLDBFQUEwRTtJQUMxRSxFQUFFO0lBQ0Ysc0ZBQXNGO0lBQ3RGLEVBQUU7SUFDRiwyRUFBMkU7SUFDM0UsNEJBQTRCO0lBQ3JCLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQXNDO1FBQzNELE9BQU8sa0JBQWtCLENBQUMsa0JBQWtCLEtBQUssSUFBSSxDQUFDO0lBQ3hELENBQUM7SUFFRCx5RkFBeUY7SUFDekYsa0VBQWtFO0lBQ2xFLEVBQUU7SUFDRiwwRkFBMEY7SUFDMUYscUNBQXFDO0lBQ3JDLHdGQUF3RjtJQUN4RixtR0FBbUc7SUFDbkcsRUFBRTtJQUNGLHNHQUFzRztJQUN0RyxjQUFjO0lBQ0QsYUFBYSxDQUN4QixVQUFvQyxFQUNwQyxNQUFrQixFQUNsQixLQUFZLEVBQ1osV0FBMEI7O1lBRTFCLE1BQU0sU0FBUyxHQUFHLE1BQU0sVUFBVSxDQUFDLGNBQWMsQ0FDL0MscUJBQXFCLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUMzRCxDQUFDO1lBQ0YsSUFBSSxTQUFTLElBQUksSUFBSSxFQUFFO2dCQUNyQixPQUFPLElBQUksQ0FBQzthQUNiO1lBRUQsTUFBTSxVQUFVLEdBQXdCLFNBQVMsQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsbUJBQW1CLENBQUMsQ0FBQztZQUNqRyxPQUFPO2dCQUNMLElBQUksRUFBRSxNQUFNO2dCQUNaLE9BQU8sRUFBRSxXQUFXLElBQUksRUFBRTtnQkFDMUIsb0JBQW9CLEVBQUUscUJBQXFCLENBQUMsdUJBQXVCLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxVQUFVLENBQUM7Z0JBQzlGLFVBQVU7YUFDWCxDQUFDO1FBQ0osQ0FBQztLQUFBO0lBRUQsdUZBQXVGO0lBQ3ZGLEVBQUU7SUFDRiwwREFBMEQ7SUFDMUQsMkNBQTJDO0lBQzNDLEVBQUU7SUFDRiwrREFBK0Q7SUFDeEQsTUFBTSxDQUFDLHFCQUFxQixDQUFDLE1BQWtCLEVBQUUsS0FBWTtRQUNsRSxPQUFPO1lBQ0wsWUFBWSxFQUFFLGlCQUFPLENBQUMsOEJBQThCLENBQUMsTUFBTSxDQUFDO1lBQzVELFFBQVEsRUFBRSxpQkFBTyxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUM7WUFDeEMsT0FBTyxFQUFFLEVBQUMsa0JBQWtCLEVBQUUsSUFBSSxFQUFDO1NBQ3BDLENBQUM7SUFDSixDQUFDO0lBRUQsbURBQW1EO0lBQ25ELEVBQUU7SUFDRix3Q0FBd0M7SUFDeEMsRUFBRTtJQUNGLDREQUE0RDtJQUNyRCxNQUFNLENBQUMsbUJBQW1CLENBQUMsUUFBa0I7UUFDbEQsT0FBTztZQUNMLEdBQUcsRUFBRSxpQkFBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDO1lBQ3BDLElBQUksRUFBRSxJQUFJO1lBQ1YsS0FBSyxFQUFFLGlCQUFPLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztTQUNsRCxDQUFDO0lBQ0osQ0FBQztJQUVELHdGQUF3RjtJQUNqRixNQUFNLENBQUMsdUJBQXVCLENBQ25DLE1BQWtCLEVBQ2xCLEtBQVksRUFDWixVQUErQjtRQUUvQixJQUFJLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzNCLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFDRCxNQUFNLGdCQUFnQixHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9GLE9BQU8sTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNuRSxDQUFDO0NBQ0Y7QUFuRkQsd0NBbUZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYXRvbUlkZSBmcm9tICdhdG9tLWlkZSc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5pbXBvcnQge1xyXG4gIFBvaW50LFxyXG4gIFRleHRFZGl0b3IsXHJcbn0gZnJvbSAnYXRvbSc7XHJcbmltcG9ydCB7XHJcbiAgTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gIExvY2F0aW9uLFxyXG4gIFNlcnZlckNhcGFiaWxpdGllcyxcclxuICBSZWZlcmVuY2VQYXJhbXMsXHJcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5cclxuLy8gUHVibGljOiBBZGFwdHMgdGhlIGxhbmd1YWdlIHNlcnZlciBkZWZpbml0aW9uIHByb3ZpZGVyIHRvIHRoZVxyXG4vLyBBdG9tIElERSBVSSBEZWZpbml0aW9ucyBwYWNrYWdlIGZvciAnR28gVG8gRGVmaW5pdGlvbicgZnVuY3Rpb25hbGl0eS5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmluZFJlZmVyZW5jZXNBZGFwdGVyIHtcclxuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IGNvbnRhaW5pbmcgYSByZWZlcmVuY2VzUHJvdmlkZXIuXHJcbiAgLy9cclxuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXHJcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxyXG4gIHB1YmxpYyBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMucmVmZXJlbmNlc1Byb3ZpZGVyID09PSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBHZXQgdGhlIHJlZmVyZW5jZXMgZm9yIGEgc3BlY2lmaWMgc3ltYm9sIHdpdGhpbiB0aGUgZG9jdW1lbnQgYXMgcmVwcmVzZW50ZWQgYnlcclxuICAvLyB0aGUge1RleHRFZGl0b3J9IGFuZCB7UG9pbnR9IHdpdGhpbiBpdCB2aWEgdGhlIGxhbmd1YWdlIHNlcnZlci5cclxuICAvL1xyXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgcXVlcmllZFxyXG4gIC8vICAgICAgICAgICAgICAgIGZvciB0aGUgcmVmZXJlbmNlcy5cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSByZWZlcmVuY2VzIHNob3VsZCByZWxhdGUgdG8uXHJcbiAgLy8gKiBgcG9pbnRgIFRoZSBBdG9tIHtQb2ludH0gY29udGFpbmluZyB0aGUgcG9pbnQgd2l0aGluIHRoZSB0ZXh0IHRoZSByZWZlcmVuY2VzIHNob3VsZCByZWxhdGUgdG8uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IGNvbnRhaW5pbmcgYSB7RmluZFJlZmVyZW5jZXNSZXR1cm59IHdpdGggYWxsIHRoZSByZWZlcmVuY2VzIHRoZSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBjb3VsZCBmaW5kLlxyXG4gIHB1YmxpYyBhc3luYyBnZXRSZWZlcmVuY2VzKFxyXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxyXG4gICAgcG9pbnQ6IFBvaW50LFxyXG4gICAgcHJvamVjdFJvb3Q6IHN0cmluZyB8IG51bGwsXHJcbiAgKTogUHJvbWlzZTxhdG9tSWRlLkZpbmRSZWZlcmVuY2VzUmV0dXJuIHwgbnVsbD4ge1xyXG4gICAgY29uc3QgbG9jYXRpb25zID0gYXdhaXQgY29ubmVjdGlvbi5maW5kUmVmZXJlbmNlcyhcclxuICAgICAgRmluZFJlZmVyZW5jZXNBZGFwdGVyLmNyZWF0ZVJlZmVyZW5jZVBhcmFtcyhlZGl0b3IsIHBvaW50KSxcclxuICAgICk7XHJcbiAgICBpZiAobG9jYXRpb25zID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVmZXJlbmNlczogYXRvbUlkZS5SZWZlcmVuY2VbXSA9IGxvY2F0aW9ucy5tYXAoRmluZFJlZmVyZW5jZXNBZGFwdGVyLmxvY2F0aW9uVG9SZWZlcmVuY2UpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogJ2RhdGEnLFxyXG4gICAgICBiYXNlVXJpOiBwcm9qZWN0Um9vdCB8fCAnJyxcclxuICAgICAgcmVmZXJlbmNlZFN5bWJvbE5hbWU6IEZpbmRSZWZlcmVuY2VzQWRhcHRlci5nZXRSZWZlcmVuY2VkU3ltYm9sTmFtZShlZGl0b3IsIHBvaW50LCByZWZlcmVuY2VzKSxcclxuICAgICAgcmVmZXJlbmNlcyxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSBhIHtSZWZlcmVuY2VQYXJhbXN9IGZyb20gYSBnaXZlbiB7VGV4dEVkaXRvcn0gZm9yIGEgc3BlY2lmaWMge1BvaW50fS5cclxuICAvL1xyXG4gIC8vICogYGVkaXRvcmAgQSB7VGV4dEVkaXRvcn0gdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudC5cclxuICAvLyAqIGBwb2ludGAgQSB7UG9pbnR9IHdpdGhpbiB0aGUgZG9jdW1lbnQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1JlZmVyZW5jZVBhcmFtc30gYnVpbHQgZnJvbSB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZVJlZmVyZW5jZVBhcmFtcyhlZGl0b3I6IFRleHRFZGl0b3IsIHBvaW50OiBQb2ludCk6IFJlZmVyZW5jZVBhcmFtcyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXHJcbiAgICAgIHBvc2l0aW9uOiBDb252ZXJ0LnBvaW50VG9Qb3NpdGlvbihwb2ludCksXHJcbiAgICAgIGNvbnRleHQ6IHtpbmNsdWRlRGVjbGFyYXRpb246IHRydWV9LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHtMb2NhdGlvbn0gaW50byBhIHtSZWZlcmVuY2V9LlxyXG4gIC8vXHJcbiAgLy8gKiBgbG9jYXRpb25gIEEge0xvY2F0aW9ufSB0byBjb252ZXJ0LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtSZWZlcmVuY2V9IGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIHtMb2NhdGlvbn0uXHJcbiAgcHVibGljIHN0YXRpYyBsb2NhdGlvblRvUmVmZXJlbmNlKGxvY2F0aW9uOiBMb2NhdGlvbik6IGF0b21JZGUuUmVmZXJlbmNlIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHVyaTogQ29udmVydC51cmlUb1BhdGgobG9jYXRpb24udXJpKSxcclxuICAgICAgbmFtZTogbnVsbCxcclxuICAgICAgcmFuZ2U6IENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKGxvY2F0aW9uLnJhbmdlKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IEdldCBhIHN5bWJvbCBuYW1lIGZyb20gYSB7VGV4dEVkaXRvcn0gZm9yIGEgc3BlY2lmaWMge1BvaW50fSBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgcHVibGljIHN0YXRpYyBnZXRSZWZlcmVuY2VkU3ltYm9sTmFtZShcclxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcclxuICAgIHBvaW50OiBQb2ludCxcclxuICAgIHJlZmVyZW5jZXM6IGF0b21JZGUuUmVmZXJlbmNlW10sXHJcbiAgKTogc3RyaW5nIHtcclxuICAgIGlmIChyZWZlcmVuY2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjdXJyZW50UmVmZXJlbmNlID0gcmVmZXJlbmNlcy5maW5kKChyKSA9PiByLnJhbmdlLmNvbnRhaW5zUG9pbnQocG9pbnQpKSB8fCByZWZlcmVuY2VzWzBdO1xyXG4gICAgcmV0dXJuIGVkaXRvci5nZXRCdWZmZXIoKS5nZXRUZXh0SW5SYW5nZShjdXJyZW50UmVmZXJlbmNlLnJhbmdlKTtcclxuICB9XHJcbn1cclxuIl19
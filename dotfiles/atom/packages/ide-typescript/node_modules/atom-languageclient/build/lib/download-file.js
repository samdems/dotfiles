"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
// Public: Download a file and store it on a file system using streaming with appropriate progress callback.
//
// * `sourceUrl`        Url to download from.
// * `targetFile`       File path to save to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
// * `length`           File length in bytes if you want percentage progress indication and the server is
//                      unable to provide a Content-Length header and whitelist CORS access via a
//                      `Access-Control-Expose-Headers "content-length"` header.
//
// Returns a {Promise} that will accept when complete.
exports.default = (function downloadFile(sourceUrl, targetFile, progressCallback, length) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = new Request(sourceUrl, {
            headers: new Headers({ 'Content-Type': 'application/octet-stream' }),
        });
        const response = yield fetch(request);
        if (!response.ok) {
            throw Error(`Unable to download, server returned ${response.status} ${response.statusText}`);
        }
        const body = response.body;
        if (body == null) {
            throw Error('No response body');
        }
        const finalLength = length || parseInt(response.headers.get('Content-Length') || '0', 10);
        const reader = body.getReader();
        const writer = fs.createWriteStream(targetFile);
        yield streamWithProgress(finalLength, reader, writer, progressCallback);
        writer.end();
    });
});
// Stream from a {ReadableStreamReader} to a {WriteStream} with progress callback.
//
// * `length`           File length in bytes.
// * `reader`           {ReadableStreamReader} to read from.
// * `writer`           {WriteStream} to write to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
//
// Returns a {Promise} that will accept when complete.
function streamWithProgress(length, reader, writer, progressCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        let bytesDone = 0;
        while (true) {
            const result = yield reader.read();
            if (result.done) {
                if (progressCallback != null) {
                    progressCallback(length, 100);
                }
                return;
            }
            const chunk = result.value;
            if (chunk == null) {
                throw Error('Empty chunk received during download');
            }
            else {
                writer.write(Buffer.from(chunk));
                if (progressCallback != null) {
                    bytesDone += chunk.byteLength;
                    const percent = length === 0 ? undefined : Math.floor(bytesDone / length * 100);
                    progressCallback(bytesDone, percent);
                }
            }
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG93bmxvYWQtZmlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9kb3dubG9hZC1maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFFekIsNEdBQTRHO0FBQzVHLEVBQUU7QUFDRiw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLHVHQUF1RztBQUN2RyxtREFBbUQ7QUFDbkQseUdBQXlHO0FBQ3pHLGlHQUFpRztBQUNqRyxnRkFBZ0Y7QUFDaEYsRUFBRTtBQUNGLHNEQUFzRDtBQUN0RCxrQkFBZSxDQUFDLHNCQUNkLFNBQWlCLEVBQ2pCLFVBQWtCLEVBQ2xCLGdCQUF1QyxFQUN2QyxNQUFlOztRQUVmLE1BQU0sT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRTtZQUNyQyxPQUFPLEVBQUUsSUFBSSxPQUFPLENBQUMsRUFBQyxjQUFjLEVBQUUsMEJBQTBCLEVBQUMsQ0FBQztTQUNuRSxDQUFDLENBQUM7UUFFSCxNQUFNLFFBQVEsR0FBRyxNQUFNLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRTtZQUNoQixNQUFNLEtBQUssQ0FBQyx1Q0FBdUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQztTQUM5RjtRQUVELE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUM7UUFDM0IsSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO1lBQ2hCLE1BQU0sS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7U0FDakM7UUFFRCxNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLElBQUksR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzFGLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNoQyxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFaEQsTUFBTSxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ3hFLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNmLENBQUM7Q0FBQSxDQUFDLENBQUM7QUFFSCxrRkFBa0Y7QUFDbEYsRUFBRTtBQUNGLDZDQUE2QztBQUM3Qyw0REFBNEQ7QUFDNUQsa0RBQWtEO0FBQ2xELHVHQUF1RztBQUN2RyxtREFBbUQ7QUFDbkQsRUFBRTtBQUNGLHNEQUFzRDtBQUN0RCw0QkFDRSxNQUFjLEVBQ2QsTUFBNEIsRUFDNUIsTUFBc0IsRUFDdEIsZ0JBQXVDOztRQUV2QyxJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFFbEIsT0FBTyxJQUFJLEVBQUU7WUFDWCxNQUFNLE1BQU0sR0FBRyxNQUFNLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNuQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUU7Z0JBQ2YsSUFBSSxnQkFBZ0IsSUFBSSxJQUFJLEVBQUU7b0JBQzVCLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztpQkFDL0I7Z0JBQ0QsT0FBTzthQUNSO1lBRUQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztZQUMzQixJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUU7Z0JBQ2pCLE1BQU0sS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7YUFDckQ7aUJBQU07Z0JBQ0wsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQ2pDLElBQUksZ0JBQWdCLElBQUksSUFBSSxFQUFFO29CQUM1QixTQUFTLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQztvQkFDOUIsTUFBTSxPQUFPLEdBQXVCLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDO29CQUNwRyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7aUJBQ3RDO2FBQ0Y7U0FDRjtJQUNILENBQUM7Q0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcclxuXHJcbi8vIFB1YmxpYzogRG93bmxvYWQgYSBmaWxlIGFuZCBzdG9yZSBpdCBvbiBhIGZpbGUgc3lzdGVtIHVzaW5nIHN0cmVhbWluZyB3aXRoIGFwcHJvcHJpYXRlIHByb2dyZXNzIGNhbGxiYWNrLlxyXG4vL1xyXG4vLyAqIGBzb3VyY2VVcmxgICAgICAgICBVcmwgdG8gZG93bmxvYWQgZnJvbS5cclxuLy8gKiBgdGFyZ2V0RmlsZWAgICAgICAgRmlsZSBwYXRoIHRvIHNhdmUgdG8uXHJcbi8vICogYHByb2dyZXNzQ2FsbGJhY2tgIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBnaXZlbiBhIHtCeXRlUHJvZ3Jlc3NDYWxsYmFja30gb2JqZWN0IGNvbnRhaW5pbmdcclxuLy8gICAgICAgICAgICAgICAgICAgICAgYm90aCBieXRlc0RvbmUgYW5kIHBlcmNlbnQuXHJcbi8vICogYGxlbmd0aGAgICAgICAgICAgIEZpbGUgbGVuZ3RoIGluIGJ5dGVzIGlmIHlvdSB3YW50IHBlcmNlbnRhZ2UgcHJvZ3Jlc3MgaW5kaWNhdGlvbiBhbmQgdGhlIHNlcnZlciBpc1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICB1bmFibGUgdG8gcHJvdmlkZSBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBhbmQgd2hpdGVsaXN0IENPUlMgYWNjZXNzIHZpYSBhXHJcbi8vICAgICAgICAgICAgICAgICAgICAgIGBBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVycyBcImNvbnRlbnQtbGVuZ3RoXCJgIGhlYWRlci5cclxuLy9cclxuLy8gUmV0dXJucyBhIHtQcm9taXNlfSB0aGF0IHdpbGwgYWNjZXB0IHdoZW4gY29tcGxldGUuXHJcbmV4cG9ydCBkZWZhdWx0IChhc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUoXHJcbiAgc291cmNlVXJsOiBzdHJpbmcsXHJcbiAgdGFyZ2V0RmlsZTogc3RyaW5nLFxyXG4gIHByb2dyZXNzQ2FsbGJhY2s/OiBCeXRlUHJvZ3Jlc3NDYWxsYmFjayxcclxuICBsZW5ndGg/OiBudW1iZXIsXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChzb3VyY2VVcmwsIHtcclxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSd9KSxcclxuICB9KTtcclxuXHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcclxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGRvd25sb2FkLCBzZXJ2ZXIgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGJvZHkgPSByZXNwb25zZS5ib2R5O1xyXG4gIGlmIChib2R5ID09IG51bGwpIHtcclxuICAgIHRocm93IEVycm9yKCdObyByZXNwb25zZSBib2R5Jyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmaW5hbExlbmd0aCA9IGxlbmd0aCB8fCBwYXJzZUludChyZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKSB8fCAnMCcsIDEwKTtcclxuICBjb25zdCByZWFkZXIgPSBib2R5LmdldFJlYWRlcigpO1xyXG4gIGNvbnN0IHdyaXRlciA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHRhcmdldEZpbGUpO1xyXG5cclxuICBhd2FpdCBzdHJlYW1XaXRoUHJvZ3Jlc3MoZmluYWxMZW5ndGgsIHJlYWRlciwgd3JpdGVyLCBwcm9ncmVzc0NhbGxiYWNrKTtcclxuICB3cml0ZXIuZW5kKCk7XHJcbn0pO1xyXG5cclxuLy8gU3RyZWFtIGZyb20gYSB7UmVhZGFibGVTdHJlYW1SZWFkZXJ9IHRvIGEge1dyaXRlU3RyZWFtfSB3aXRoIHByb2dyZXNzIGNhbGxiYWNrLlxyXG4vL1xyXG4vLyAqIGBsZW5ndGhgICAgICAgICAgICBGaWxlIGxlbmd0aCBpbiBieXRlcy5cclxuLy8gKiBgcmVhZGVyYCAgICAgICAgICAge1JlYWRhYmxlU3RyZWFtUmVhZGVyfSB0byByZWFkIGZyb20uXHJcbi8vICogYHdyaXRlcmAgICAgICAgICAgIHtXcml0ZVN0cmVhbX0gdG8gd3JpdGUgdG8uXHJcbi8vICogYHByb2dyZXNzQ2FsbGJhY2tgIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBnaXZlbiBhIHtCeXRlUHJvZ3Jlc3NDYWxsYmFja30gb2JqZWN0IGNvbnRhaW5pbmdcclxuLy8gICAgICAgICAgICAgICAgICAgICAgYm90aCBieXRlc0RvbmUgYW5kIHBlcmNlbnQuXHJcbi8vXHJcbi8vIFJldHVybnMgYSB7UHJvbWlzZX0gdGhhdCB3aWxsIGFjY2VwdCB3aGVuIGNvbXBsZXRlLlxyXG5hc3luYyBmdW5jdGlvbiBzdHJlYW1XaXRoUHJvZ3Jlc3MoXHJcbiAgbGVuZ3RoOiBudW1iZXIsXHJcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcixcclxuICB3cml0ZXI6IGZzLldyaXRlU3RyZWFtLFxyXG4gIHByb2dyZXNzQ2FsbGJhY2s/OiBCeXRlUHJvZ3Jlc3NDYWxsYmFjayxcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgbGV0IGJ5dGVzRG9uZSA9IDA7XHJcblxyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xyXG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XHJcbiAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrICE9IG51bGwpIHtcclxuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGxlbmd0aCwgMTAwKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2h1bmsgPSByZXN1bHQudmFsdWU7XHJcbiAgICBpZiAoY2h1bmsgPT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBFcnJvcignRW1wdHkgY2h1bmsgcmVjZWl2ZWQgZHVyaW5nIGRvd25sb2FkJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3cml0ZXIud3JpdGUoQnVmZmVyLmZyb20oY2h1bmspKTtcclxuICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2sgIT0gbnVsbCkge1xyXG4gICAgICAgIGJ5dGVzRG9uZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHBlcmNlbnQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IGxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IE1hdGguZmxvb3IoYnl0ZXNEb25lIC8gbGVuZ3RoICogMTAwKTtcclxuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGJ5dGVzRG9uZSwgcGVyY2VudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIFB1YmxpYzogUHJvZ3Jlc3MgY2FsbGJhY2sgZnVuY3Rpb24gc2lnbmF0dXJlIGluZGljYXRpbmcgdGhlIGJ5dGVzRG9uZSBhbmRcclxuLy8gb3B0aW9uYWwgcGVyY2VudGFnZSB3aGVuIGxlbmd0aCBpcyBrbm93bi5cclxuZXhwb3J0IHR5cGUgQnl0ZVByb2dyZXNzQ2FsbGJhY2sgPSAoYnl0ZXNEb25lOiBudW1iZXIsIHBlcmNlbnQ/OiBudW1iZXIpID0+IHZvaWQ7XHJcbiJdfQ==
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
// Public: Adapts the language server protocol "textDocument/completion" to the
// Atom IDE UI Code-format package.
class CodeFormatAdapter {
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing either a documentFormattingProvider
    // or a documentRangeFormattingProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating this adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return (serverCapabilities.documentRangeFormattingProvider === true ||
            serverCapabilities.documentFormattingProvider === true);
    }
    // Public: Format text in the editor using the given language server connection and an optional range.
    // If the server does not support range formatting then range will be ignored and the entire document formatted.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will format the text.
    // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
    // * `editor` The Atom {TextEditor} containing the text that will be formatted.
    // * `range` The optional Atom {Range} containing the subset of the text to be formatted.
    //
    // Returns a {Promise} of an {Array} of {Object}s containing the AutoComplete+
    // suggestions to display.
    static format(connection, serverCapabilities, editor, range) {
        if (serverCapabilities.documentRangeFormattingProvider) {
            return CodeFormatAdapter.formatRange(connection, editor, range);
        }
        if (serverCapabilities.documentFormattingProvider) {
            return CodeFormatAdapter.formatDocument(connection, editor);
        }
        throw new Error('Can not format document, language server does not support it');
    }
    // Public: Format the entire document of an Atom {TextEditor} by using a given language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will format the text.
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    //
    // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
    // to format the document.
    static formatDocument(connection, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            const edits = yield connection.documentFormatting(CodeFormatAdapter.createDocumentFormattingParams(editor));
            return convert_1.default.convertLsTextEdits(edits);
        });
    }
    // Public: Create {DocumentFormattingParams} to be sent to the language server when requesting an
    // entire document is formatted.
    //
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    //
    // Returns {DocumentFormattingParams} containing the identity of the text document as well as
    // options to be used in formatting the document such as tab size and tabs vs spaces.
    static createDocumentFormattingParams(editor) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            options: CodeFormatAdapter.getFormatOptions(editor),
        };
    }
    // Public: Format a range within an Atom {TextEditor} by using a given language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will format the text.
    // * `range` The Atom {Range} containing the range of text that should be formatted.
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    //
    // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
    // to format the document.
    static formatRange(connection, editor, range) {
        return __awaiter(this, void 0, void 0, function* () {
            const edits = yield connection.documentRangeFormatting(CodeFormatAdapter.createDocumentRangeFormattingParams(editor, range));
            return convert_1.default.convertLsTextEdits(edits);
        });
    }
    // Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
    // entire document is formatted.
    //
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    // * `range` The Atom {Range} containing the range of text that should be formatted.
    //
    // Returns {DocumentRangeFormattingParams} containing the identity of the text document, the
    // range of the text to be formatted as well as the options to be used in formatting the
    // document such as tab size and tabs vs spaces.
    static createDocumentRangeFormattingParams(editor, range) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            range: convert_1.default.atomRangeToLSRange(range),
            options: CodeFormatAdapter.getFormatOptions(editor),
        };
    }
    // Public: Format on type within an Atom {TextEditor} by using a given language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will format the text.
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    // * `point` The {Point} at which the document to be formatted.
    // * `character` A character that triggered formatting request.
    //
    // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
    // to format the document.
    static formatOnType(connection, editor, point, character) {
        return __awaiter(this, void 0, void 0, function* () {
            const edits = yield connection.documentOnTypeFormatting(CodeFormatAdapter.createDocumentOnTypeFormattingParams(editor, point, character));
            return convert_1.default.convertLsTextEdits(edits);
        });
    }
    // Public: Create {DocumentOnTypeFormattingParams} to be sent to the language server when requesting an
    // entire document is formatted.
    //
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    // * `point` The {Point} at which the document to be formatted.
    // * `character` A character that triggered formatting request.
    //
    // Returns {DocumentOnTypeFormattingParams} containing the identity of the text document, the
    // position of the text to be formatted, the character that triggered formatting request
    // as well as the options to be used in formatting the document such as tab size and tabs vs spaces.
    static createDocumentOnTypeFormattingParams(editor, point, character) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            position: convert_1.default.pointToPosition(point),
            ch: character,
            options: CodeFormatAdapter.getFormatOptions(editor),
        };
    }
    // Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
    // entire document is formatted.
    //
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    // * `range` The Atom {Range} containing the range of document that should be formatted.
    //
    // Returns the {FormattingOptions} to be used containing the keys:
    //  * `tabSize` The number of spaces a tab represents.
    //  * `insertSpaces` {True} if spaces should be used, {False} for tab characters.
    static getFormatOptions(editor) {
        return {
            tabSize: editor.getTabLength(),
            insertSpaces: editor.getSoftTabs(),
        };
    }
}
exports.default = CodeFormatAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZS1mb3JtYXQtYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9jb2RlLWZvcm1hdC1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDQSx3Q0FBaUM7QUFlakMsK0VBQStFO0FBQy9FLG1DQUFtQztBQUNuQztJQUNFLGdGQUFnRjtJQUNoRix3RkFBd0Y7SUFDeEYsd0NBQXdDO0lBQ3hDLEVBQUU7SUFDRixzRkFBc0Y7SUFDdEYsRUFBRTtJQUNGLGdGQUFnRjtJQUNoRiw0QkFBNEI7SUFDckIsTUFBTSxDQUFDLFFBQVEsQ0FBQyxrQkFBc0M7UUFDM0QsT0FBTyxDQUNMLGtCQUFrQixDQUFDLCtCQUErQixLQUFLLElBQUk7WUFDM0Qsa0JBQWtCLENBQUMsMEJBQTBCLEtBQUssSUFBSSxDQUN2RCxDQUFDO0lBQ0osQ0FBQztJQUVELHNHQUFzRztJQUN0RyxnSEFBZ0g7SUFDaEgsRUFBRTtJQUNGLGdHQUFnRztJQUNoRyw0RkFBNEY7SUFDNUYsK0VBQStFO0lBQy9FLHlGQUF5RjtJQUN6RixFQUFFO0lBQ0YsOEVBQThFO0lBQzlFLDBCQUEwQjtJQUNuQixNQUFNLENBQUMsTUFBTSxDQUNsQixVQUFvQyxFQUNwQyxrQkFBc0MsRUFDdEMsTUFBa0IsRUFDbEIsS0FBWTtRQUVaLElBQUksa0JBQWtCLENBQUMsK0JBQStCLEVBQUU7WUFDdEQsT0FBTyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztTQUNqRTtRQUVELElBQUksa0JBQWtCLENBQUMsMEJBQTBCLEVBQUU7WUFDakQsT0FBTyxpQkFBaUIsQ0FBQyxjQUFjLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQzdEO1FBRUQsTUFBTSxJQUFJLEtBQUssQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO0lBQ2xGLENBQUM7SUFFRCwrRkFBK0Y7SUFDL0YsRUFB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LEtBQUssQ0FBQztZQUN4QyxFQUFFLEVBQUUsU0FBUztZQUNiLE9BQU8sRUFBRSxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7U0FDcEQsQ0FBQztJQUNKLENBQUM7SUFFRCxzR0FBc0c7SUFDdEcsZ0NBQWdDO0lBQ2hDLEVBQUU7SUFDRiw0RUFBNEU7SUFDNUUsd0ZBQXdGO0lBQ3hGLEVBQUU7SUFDRixrRUFBa0U7SUFDbEUsc0RBQXNEO0lBQ3RELGlGQUFpRjtJQUMxRSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsTUFBa0I7UUFDL0MsT0FBTztZQUNMLE9BQU8sRUFBRSxNQUFNLENBQUMsWUFBWSxFQUFFO1lBQzlCLFlBQVksRUFBRSxNQUFNLENBQUMsV0FBVyxFQUFFO1NBQ25DLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUExS0Qsb0NBMEtDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYXRvbUlkZSBmcm9tICdhdG9tLWlkZSc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5pbXBvcnQge1xyXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICBEb2N1bWVudEZvcm1hdHRpbmdQYXJhbXMsXHJcbiAgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMsXHJcbiAgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUGFyYW1zLFxyXG4gIEZvcm1hdHRpbmdPcHRpb25zLFxyXG4gIFNlcnZlckNhcGFiaWxpdGllcyxcclxufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCB7XHJcbiAgVGV4dEVkaXRvcixcclxuICBSYW5nZSxcclxuICBQb2ludCxcclxufSBmcm9tICdhdG9tJztcclxuXHJcbi8vIFB1YmxpYzogQWRhcHRzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgXCJ0ZXh0RG9jdW1lbnQvY29tcGxldGlvblwiIHRvIHRoZVxyXG4vLyBBdG9tIElERSBVSSBDb2RlLWZvcm1hdCBwYWNrYWdlLlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2RlRm9ybWF0QWRhcHRlciB7XHJcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGVpdGhlciBhIGRvY3VtZW50Rm9ybWF0dGluZ1Byb3ZpZGVyXHJcbiAgLy8gb3IgYSBkb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyB0aGlzIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXHJcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxyXG4gIHB1YmxpYyBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyID09PSB0cnVlIHx8XHJcbiAgICAgIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlciA9PT0gdHJ1ZVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogRm9ybWF0IHRleHQgaW4gdGhlIGVkaXRvciB1c2luZyB0aGUgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyIGNvbm5lY3Rpb24gYW5kIGFuIG9wdGlvbmFsIHJhbmdlLlxyXG4gIC8vIElmIHRoZSBzZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCByYW5nZSBmb3JtYXR0aW5nIHRoZW4gcmFuZ2Ugd2lsbCBiZSBpZ25vcmVkIGFuZCB0aGUgZW50aXJlIGRvY3VtZW50IGZvcm1hdHRlZC5cclxuICAvL1xyXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgZm9ybWF0IHRoZSB0ZXh0LlxyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHVzZWQuXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgdGV4dCB0aGF0IHdpbGwgYmUgZm9ybWF0dGVkLlxyXG4gIC8vICogYHJhbmdlYCBUaGUgb3B0aW9uYWwgQXRvbSB7UmFuZ2V9IGNvbnRhaW5pbmcgdGhlIHN1YnNldCBvZiB0aGUgdGV4dCB0byBiZSBmb3JtYXR0ZWQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IG9mIGFuIHtBcnJheX0gb2Yge09iamVjdH1zIGNvbnRhaW5pbmcgdGhlIEF1dG9Db21wbGV0ZStcclxuICAvLyBzdWdnZXN0aW9ucyB0byBkaXNwbGF5LlxyXG4gIHB1YmxpYyBzdGF0aWMgZm9ybWF0KFxyXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gICAgc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMsXHJcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXHJcbiAgICByYW5nZTogUmFuZ2UsXHJcbiAgKTogUHJvbWlzZTxhdG9tSWRlLlRleHRFZGl0W10+IHtcclxuICAgIGlmIChzZXJ2ZXJDYXBhYmlsaXRpZXMuZG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQcm92aWRlcikge1xyXG4gICAgICByZXR1cm4gQ29kZUZvcm1hdEFkYXB0ZXIuZm9ybWF0UmFuZ2UoY29ubmVjdGlvbiwgZWRpdG9yLCByYW5nZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlcikge1xyXG4gICAgICByZXR1cm4gQ29kZUZvcm1hdEFkYXB0ZXIuZm9ybWF0RG9jdW1lbnQoY29ubmVjdGlvbiwgZWRpdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZm9ybWF0IGRvY3VtZW50LCBsYW5ndWFnZSBzZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBpdCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBGb3JtYXQgdGhlIGVudGlyZSBkb2N1bWVudCBvZiBhbiBBdG9tIHtUZXh0RWRpdG9yfSBieSB1c2luZyBhIGdpdmVuIGxhbmd1YWdlIHNlcnZlci5cclxuICAvL1xyXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgZm9ybWF0IHRoZSB0ZXh0LlxyXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gb2YgYW4ge0FycmF5fSBvZiB7VGV4dEVkaXR9IG9iamVjdHMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgQXRvbSBUZXh0RWRpdG9yXHJcbiAgLy8gdG8gZm9ybWF0IHRoZSBkb2N1bWVudC5cclxuICBwdWJsaWMgc3RhdGljIGFzeW5jIGZvcm1hdERvY3VtZW50KFxyXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxyXG4gICk6IFByb21pc2U8YXRvbUlkZS5UZXh0RWRpdFtdPiB7XHJcbiAgICBjb25zdCBlZGl0cyA9IGF3YWl0IGNvbm5lY3Rpb24uZG9jdW1lbnRGb3JtYXR0aW5nKENvZGVGb3JtYXRBZGFwdGVyLmNyZWF0ZURvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyhlZGl0b3IpKTtcclxuICAgIHJldHVybiBDb252ZXJ0LmNvbnZlcnRMc1RleHRFZGl0cyhlZGl0cyk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSB7RG9jdW1lbnRGb3JtYXR0aW5nUGFyYW1zfSB0byBiZSBzZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgd2hlbiByZXF1ZXN0aW5nIGFuXHJcbiAgLy8gZW50aXJlIGRvY3VtZW50IGlzIGZvcm1hdHRlZC5cclxuICAvL1xyXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMge0RvY3VtZW50Rm9ybWF0dGluZ1BhcmFtc30gY29udGFpbmluZyB0aGUgaWRlbnRpdHkgb2YgdGhlIHRleHQgZG9jdW1lbnQgYXMgd2VsbCBhc1xyXG4gIC8vIG9wdGlvbnMgdG8gYmUgdXNlZCBpbiBmb3JtYXR0aW5nIHRoZSBkb2N1bWVudCBzdWNoIGFzIHRhYiBzaXplIGFuZCB0YWJzIHZzIHNwYWNlcy5cclxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZURvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyhlZGl0b3I6IFRleHRFZGl0b3IpOiBEb2N1bWVudEZvcm1hdHRpbmdQYXJhbXMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpLFxyXG4gICAgICBvcHRpb25zOiBDb2RlRm9ybWF0QWRhcHRlci5nZXRGb3JtYXRPcHRpb25zKGVkaXRvciksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBGb3JtYXQgYSByYW5nZSB3aXRoaW4gYW4gQXRvbSB7VGV4dEVkaXRvcn0gYnkgdXNpbmcgYSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGZvcm1hdCB0aGUgdGV4dC5cclxuICAvLyAqIGByYW5nZWAgVGhlIEF0b20ge1JhbmdlfSBjb250YWluaW5nIHRoZSByYW5nZSBvZiB0ZXh0IHRoYXQgc2hvdWxkIGJlIGZvcm1hdHRlZC5cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IG9mIGFuIHtBcnJheX0gb2Yge1RleHRFZGl0fSBvYmplY3RzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIEF0b20gVGV4dEVkaXRvclxyXG4gIC8vIHRvIGZvcm1hdCB0aGUgZG9jdW1lbnQuXHJcbiAgcHVibGljIHN0YXRpYyBhc3luYyBmb3JtYXRSYW5nZShcclxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcclxuICAgIHJhbmdlOiBSYW5nZSxcclxuICApOiBQcm9taXNlPGF0b21JZGUuVGV4dEVkaXRbXT4ge1xyXG4gICAgY29uc3QgZWRpdHMgPSBhd2FpdCBjb25uZWN0aW9uLmRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nKFxyXG4gICAgICBDb2RlRm9ybWF0QWRhcHRlci5jcmVhdGVEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtcyhlZGl0b3IsIHJhbmdlKSxcclxuICAgICk7XHJcbiAgICByZXR1cm4gQ29udmVydC5jb252ZXJ0THNUZXh0RWRpdHMoZWRpdHMpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUge0RvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zfSB0byBiZSBzZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgd2hlbiByZXF1ZXN0aW5nIGFuXHJcbiAgLy8gZW50aXJlIGRvY3VtZW50IGlzIGZvcm1hdHRlZC5cclxuICAvL1xyXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cclxuICAvLyAqIGByYW5nZWAgVGhlIEF0b20ge1JhbmdlfSBjb250YWluaW5nIHRoZSByYW5nZSBvZiB0ZXh0IHRoYXQgc2hvdWxkIGJlIGZvcm1hdHRlZC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMge0RvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zfSBjb250YWluaW5nIHRoZSBpZGVudGl0eSBvZiB0aGUgdGV4dCBkb2N1bWVudCwgdGhlXHJcbiAgLy8gcmFuZ2Ugb2YgdGhlIHRleHQgdG8gYmUgZm9ybWF0dGVkIGFzIHdlbGwgYXMgdGhlIG9wdGlvbnMgdG8gYmUgdXNlZCBpbiBmb3JtYXR0aW5nIHRoZVxyXG4gIC8vIGRvY3VtZW50IHN1Y2ggYXMgdGFiIHNpemUgYW5kIHRhYnMgdnMgc3BhY2VzLlxyXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMoXHJcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXHJcbiAgICByYW5nZTogUmFuZ2UsXHJcbiAgKTogRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpLFxyXG4gICAgICByYW5nZTogQ29udmVydC5hdG9tUmFuZ2VUb0xTUmFuZ2UocmFuZ2UpLFxyXG4gICAgICBvcHRpb25zOiBDb2RlRm9ybWF0QWRhcHRlci5nZXRGb3JtYXRPcHRpb25zKGVkaXRvciksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBGb3JtYXQgb24gdHlwZSB3aXRoaW4gYW4gQXRvbSB7VGV4dEVkaXRvcn0gYnkgdXNpbmcgYSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGZvcm1hdCB0aGUgdGV4dC5cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXHJcbiAgLy8gKiBgcG9pbnRgIFRoZSB7UG9pbnR9IGF0IHdoaWNoIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXHJcbiAgLy8gKiBgY2hhcmFjdGVyYCBBIGNoYXJhY3RlciB0aGF0IHRyaWdnZXJlZCBmb3JtYXR0aW5nIHJlcXVlc3QuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IG9mIGFuIHtBcnJheX0gb2Yge1RleHRFZGl0fSBvYmplY3RzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIEF0b20gVGV4dEVkaXRvclxyXG4gIC8vIHRvIGZvcm1hdCB0aGUgZG9jdW1lbnQuXHJcbiAgcHVibGljIHN0YXRpYyBhc3luYyBmb3JtYXRPblR5cGUoXHJcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXHJcbiAgICBwb2ludDogUG9pbnQsXHJcbiAgICBjaGFyYWN0ZXI6IHN0cmluZyxcclxuICApOiBQcm9taXNlPGF0b21JZGUuVGV4dEVkaXRbXT4ge1xyXG4gICAgY29uc3QgZWRpdHMgPSBhd2FpdCBjb25uZWN0aW9uLmRvY3VtZW50T25UeXBlRm9ybWF0dGluZyhcclxuICAgICAgQ29kZUZvcm1hdEFkYXB0ZXIuY3JlYXRlRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUGFyYW1zKGVkaXRvciwgcG9pbnQsIGNoYXJhY3RlciksXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIENvbnZlcnQuY29udmVydExzVGV4dEVkaXRzKGVkaXRzKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIHtEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdQYXJhbXN9IHRvIGJlIHNlbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB3aGVuIHJlcXVlc3RpbmcgYW5cclxuICAvLyBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxyXG4gIC8vICogYHBvaW50YCBUaGUge1BvaW50fSBhdCB3aGljaCB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxyXG4gIC8vICogYGNoYXJhY3RlcmAgQSBjaGFyYWN0ZXIgdGhhdCB0cmlnZ2VyZWQgZm9ybWF0dGluZyByZXF1ZXN0LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB7RG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUGFyYW1zfSBjb250YWluaW5nIHRoZSBpZGVudGl0eSBvZiB0aGUgdGV4dCBkb2N1bWVudCwgdGhlXHJcbiAgLy8gcG9zaXRpb24gb2YgdGhlIHRleHQgdG8gYmUgZm9ybWF0dGVkLCB0aGUgY2hhcmFjdGVyIHRoYXQgdHJpZ2dlcmVkIGZvcm1hdHRpbmcgcmVxdWVzdFxyXG4gIC8vIGFzIHdlbGwgYXMgdGhlIG9wdGlvbnMgdG8gYmUgdXNlZCBpbiBmb3JtYXR0aW5nIHRoZSBkb2N1bWVudCBzdWNoIGFzIHRhYiBzaXplIGFuZCB0YWJzIHZzIHNwYWNlcy5cclxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZURvY3VtZW50T25UeXBlRm9ybWF0dGluZ1BhcmFtcyhcclxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcclxuICAgIHBvaW50OiBQb2ludCxcclxuICAgIGNoYXJhY3Rlcjogc3RyaW5nLFxyXG4gICk6IERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1BhcmFtcyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXHJcbiAgICAgIHBvc2l0aW9uOiBDb252ZXJ0LnBvaW50VG9Qb3NpdGlvbihwb2ludCksXHJcbiAgICAgIGNoOiBjaGFyYWN0ZXIsXHJcbiAgICAgIG9wdGlvbnM6IENvZGVGb3JtYXRBZGFwdGVyLmdldEZvcm1hdE9wdGlvbnMoZWRpdG9yKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSB7RG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXN9IHRvIGJlIHNlbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB3aGVuIHJlcXVlc3RpbmcgYW5cclxuICAvLyBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxyXG4gIC8vICogYHJhbmdlYCBUaGUgQXRvbSB7UmFuZ2V9IGNvbnRhaW5pbmcgdGhlIHJhbmdlIG9mIGRvY3VtZW50IHRoYXQgc2hvdWxkIGJlIGZvcm1hdHRlZC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgdGhlIHtGb3JtYXR0aW5nT3B0aW9uc30gdG8gYmUgdXNlZCBjb250YWluaW5nIHRoZSBrZXlzOlxyXG4gIC8vICAqIGB0YWJTaXplYCBUaGUgbnVtYmVyIG9mIHNwYWNlcyBhIHRhYiByZXByZXNlbnRzLlxyXG4gIC8vICAqIGBpbnNlcnRTcGFjZXNgIHtUcnVlfSBpZiBzcGFjZXMgc2hvdWxkIGJlIHVzZWQsIHtGYWxzZX0gZm9yIHRhYiBjaGFyYWN0ZXJzLlxyXG4gIHB1YmxpYyBzdGF0aWMgZ2V0Rm9ybWF0T3B0aW9ucyhlZGl0b3I6IFRleHRFZGl0b3IpOiBGb3JtYXR0aW5nT3B0aW9ucyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0YWJTaXplOiBlZGl0b3IuZ2V0VGFiTGVuZ3RoKCksXHJcbiAgICAgIGluc2VydFNwYWNlczogZWRpdG9yLmdldFNvZnRUYWJzKCksXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iXX0=
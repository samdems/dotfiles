"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const Utils = require("../utils");
const fuzzaldrin_plus_1 = require("fuzzaldrin-plus");
const languageclient_1 = require("../languageclient");
const atom_1 = require("atom");
// Public: Adapts the language server protocol "textDocument/completion" to the Atom
// AutoComplete+ package.
class AutocompleteAdapter {
    constructor() {
        this._suggestionCache = new WeakMap();
        this._cancellationTokens = new WeakMap();
    }
    static canAdapt(serverCapabilities) {
        return serverCapabilities.completionProvider != null;
    }
    static canResolve(serverCapabilities) {
        return serverCapabilities.completionProvider != null &&
            serverCapabilities.completionProvider.resolveProvider === true;
    }
    // Public: Obtain suggestion list for AutoComplete+ by querying the language server using
    // the `textDocument/completion` request.
    //
    // * `server` An {ActiveServer} pointing to the language server to query.
    // * `request` The {atom$AutocompleteRequest} to satisfy.
    // * `onDidConvertCompletionItem` An optional function that takes a {CompletionItem}, an {atom$AutocompleteSuggestion}
    //   and a {atom$AutocompleteRequest} allowing you to adjust converted items.
    //
    // Returns a {Promise} of an {Array} of {atom$AutocompleteSuggestion}s containing the
    // AutoComplete+ suggestions to display.
    getSuggestions(server, request, onDidConvertCompletionItem, minimumWordLength) {
        return __awaiter(this, void 0, void 0, function* () {
            const triggerChars = server.capabilities.completionProvider != null ?
                server.capabilities.completionProvider.triggerCharacters || [] : [];
            const triggerChar = AutocompleteAdapter.getTriggerCharacter(request, triggerChars);
            const prefixWithTrigger = triggerChar + request.prefix;
            const triggerColumn = request.bufferPosition.column - prefixWithTrigger.length;
            const triggerPoint = new atom_1.Point(request.bufferPosition.row, triggerColumn);
            // Only auto-trigger on a trigger character or after the minimum number of characters from autocomplete-plus
            minimumWordLength = minimumWordLength || 0;
            if (!request.activatedManually && triggerChar === '' &&
                minimumWordLength > 0 && request.prefix.length < minimumWordLength) {
                return [];
            }
            const cache = this._suggestionCache.get(server);
            let suggestionMap = null;
            // Do we have complete cached suggestions that are still valid for this request
            if (cache && !cache.isIncomplete && triggerChar !== '' &&
                cache.triggerChar === triggerChar && cache.triggerPoint.isEqual(triggerPoint)) {
                suggestionMap = cache.suggestionMap;
            }
            else {
                // Our cached suggestions can't be used so obtain new ones from the language server
                const completions = yield Utils.doWithCancellationToken(server.connection, this._cancellationTokens, (cancellationToken) => server.connection.completion(AutocompleteAdapter.createCompletionParams(request, triggerChar), cancellationToken));
                const isIncomplete = !Array.isArray(completions) && completions.isIncomplete;
                suggestionMap = this.completionItemsToSuggestions(completions, request, onDidConvertCompletionItem);
                this._suggestionCache.set(server, { isIncomplete, triggerChar, triggerPoint, suggestionMap });
            }
            // Filter the results to recalculate the score and ordering (unless only triggerChar)
            const suggestions = Array.from(suggestionMap.keys());
            const replacementPrefix = request.prefix !== triggerChar ? request.prefix : '';
            AutocompleteAdapter.setReplacementPrefixOnSuggestions(suggestions, replacementPrefix);
            return request.prefix === "" || request.prefix === triggerChar
                ? suggestions
                : fuzzaldrin_plus_1.filter(suggestions, request.prefix, { key: 'text' });
        });
    }
    // Public: Obtain a complete version of a suggestion with additional information
    // the language server can provide by way of the `completionItem/resolve` request.
    //
    // * `server` An {ActiveServer} pointing to the language server to query.
    // * `suggestion` An {atom$AutocompleteSuggestion} suggestion that should be resolved.
    // * `request` An {Object} with the AutoComplete+ request to satisfy.
    // * `onDidConvertCompletionItem` An optional function that takes a {CompletionItem}, an {atom$AutocompleteSuggestion}
    //   and a {atom$AutocompleteRequest} allowing you to adjust converted items.
    //
    // Returns a {Promise} of an {atom$AutocompleteSuggestion} with the resolved AutoComplete+ suggestion.
    completeSuggestion(server, suggestion, request, onDidConvertCompletionItem) {
        return __awaiter(this, void 0, void 0, function* () {
            const cache = this._suggestionCache.get(server);
            if (cache) {
                const originalCompletionItem = cache.suggestionMap.get(suggestion);
                if (originalCompletionItem != null && originalCompletionItem[1] === false) {
                    const resolvedCompletionItem = yield server.connection.completionItemResolve(originalCompletionItem[0]);
                    if (resolvedCompletionItem != null) {
                        AutocompleteAdapter.completionItemToSuggestion(resolvedCompletionItem, suggestion, request, onDidConvertCompletionItem);
                        originalCompletionItem[1] = true;
                    }
                }
            }
            return suggestion;
        });
    }
    // Public: Set the replacementPrefix property on all given suggestions to the
    // prefix specified.
    //
    // * `suggestions` An {Array} of {atom$AutocompleteSuggestion}s to set the replacementPrefix on.
    // * `prefix` The {string} containing the prefix that should be set as replacementPrefix on all suggestions.
    static setReplacementPrefixOnSuggestions(suggestions, prefix) {
        for (const suggestion of suggestions) {
            suggestion.replacementPrefix = prefix;
        }
    }
    // Public: Get the trigger character that caused the autocomplete (if any).  This is required because
    // AutoComplete-plus does not have trigger characters.  Although the terminology is 'character' we treat
    // them as variable length strings as this will almost certainly change in the future to support '->' etc.
    //
    // * `request` An {Array} of {atom$AutocompleteSuggestion}s to locate the prefix, editor, bufferPosition etc.
    // * `triggerChars` The {Array} of {string}s that can be trigger characters.
    //
    // Returns a {string} containing the matching trigger character or an empty string if one was not matched.
    static getTriggerCharacter(request, triggerChars) {
        // AutoComplete-Plus considers text after a symbol to be a new trigger. So we should look backward
        // from the current cursor position to see if one is there and thus simulate it.
        const buffer = request.editor.getBuffer();
        const cursor = request.bufferPosition;
        const prefixStartColumn = cursor.column - request.prefix.length;
        for (const triggerChar of triggerChars) {
            if (triggerChar === request.prefix) {
                return triggerChar;
            }
            if (prefixStartColumn >= triggerChar.length) { // Far enough along a line to fit the trigger char
                const start = new atom_1.Point(cursor.row, prefixStartColumn - triggerChar.length);
                const possibleTrigger = buffer.getTextInRange([start, [cursor.row, prefixStartColumn]]);
                if (possibleTrigger === triggerChar) { // The text before our trigger is a trigger char!
                    return triggerChar;
                }
            }
        }
        // There was no explicit trigger char
        return '';
    }
    // Public: Create TextDocumentPositionParams to be sent to the language server
    // based on the editor and position from the AutoCompleteRequest.
    //
    // * `request` The {atom$AutocompleteRequest} to obtain the editor from.
    // * `triggerPoint` The {atom$Point} where the trigger started.
    //
    // Returns a {string} containing the prefix including the trigger character.
    static getPrefixWithTrigger(request, triggerPoint) {
        return request.editor
            .getBuffer()
            .getTextInRange([[triggerPoint.row, triggerPoint.column], request.bufferPosition]);
    }
    // Public: Create {CompletionParams} to be sent to the language server
    // based on the editor and position from the Autocomplete request etc.
    //
    // * `request` The {atom$AutocompleteRequest} containing the request details.
    // * `triggerCharacter` The {string} containing the trigger character (empty if none).
    //
    // Returns an {CompletionParams} with the keys:
    //  * `textDocument` the language server protocol textDocument identification.
    //  * `position` the position within the text document to display completion request for.
    //  * `context` containing the trigger character and kind.
    static createCompletionParams(request, triggerCharacter) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(request.editor),
            position: convert_1.default.pointToPosition(request.bufferPosition),
            context: AutocompleteAdapter.createCompletionContext(triggerCharacter),
        };
    }
    // Public: Create {CompletionContext} to be sent to the language server
    // based on the trigger character.
    //
    // * `triggerCharacter` The {string} containing the trigger character or '' if none.
    //
    // Returns an {CompletionContext} that specifies the triggerKind and the triggerCharacter
    // if there is one.
    static createCompletionContext(triggerCharacter) {
        return triggerCharacter === ''
            ? { triggerKind: languageclient_1.CompletionTriggerKind.Invoked }
            : { triggerKind: languageclient_1.CompletionTriggerKind.TriggerCharacter, triggerCharacter };
    }
    // Public: Convert a language server protocol CompletionItem array or CompletionList to
    // an array of ordered AutoComplete+ suggestions.
    //
    // * `completionItems` An {Array} of {CompletionItem} objects or a {CompletionList} containing completion
    //           items to be converted.
    // * `request` The {atom$AutocompleteRequest} to satisfy.
    // * `onDidConvertCompletionItem` A function that takes a {CompletionItem}, an {atom$AutocompleteSuggestion}
    //   and a {atom$AutocompleteRequest} allowing you to adjust converted items.
    //
    // Returns a {Map} of AutoComplete+ suggestions ordered by the CompletionItems sortText.
    completionItemsToSuggestions(completionItems, request, onDidConvertCompletionItem) {
        return new Map((Array.isArray(completionItems) ? completionItems : completionItems.items || [])
            .sort((a, b) => (a.sortText || a.label).localeCompare(b.sortText || b.label))
            .map((s) => [
            AutocompleteAdapter.completionItemToSuggestion(s, {}, request, onDidConvertCompletionItem),
            [s, false]
        ]));
    }
    // Public: Convert a language server protocol CompletionItem to an AutoComplete+ suggestion.
    //
    // * `item` An {CompletionItem} containing a completion item to be converted.
    // * `suggestion` A {atom$AutocompleteSuggestion} to have the conversion applied to.
    // * `request` The {atom$AutocompleteRequest} to satisfy.
    // * `onDidConvertCompletionItem` A function that takes a {CompletionItem}, an {atom$AutocompleteSuggestion}
    //   and a {atom$AutocompleteRequest} allowing you to adjust converted items.
    //
    // Returns the {atom$AutocompleteSuggestion} passed in as suggestion with the conversion applied.
    static completionItemToSuggestion(item, suggestion, request, onDidConvertCompletionItem) {
        AutocompleteAdapter.applyCompletionItemToSuggestion(item, suggestion);
        AutocompleteAdapter.applyTextEditToSuggestion(item.textEdit, request.editor, suggestion);
        AutocompleteAdapter.applySnippetToSuggestion(item, suggestion);
        if (onDidConvertCompletionItem != null) {
            onDidConvertCompletionItem(item, suggestion, request);
        }
        return suggestion;
    }
    // Public: Convert the primary parts of a language server protocol CompletionItem to an AutoComplete+ suggestion.
    //
    // * `item` An {CompletionItem} containing the completion items to be merged into.
    // * `suggestion` The {atom$AutocompleteSuggestion} to merge the conversion into.
    //
    // Returns an {atom$AutocompleteSuggestion} created from the {CompletionItem}.
    static applyCompletionItemToSuggestion(item, suggestion) {
        suggestion.text = item.insertText || item.label;
        suggestion.displayText = item.label;
        suggestion.type = AutocompleteAdapter.completionKindToSuggestionType(item.kind);
        suggestion.rightLabel = item.detail;
        // Older format, can't know what it is so assign to both and hope for best
        if (typeof (item.documentation) === 'string') {
            suggestion.descriptionMarkdown = item.documentation;
            suggestion.description = item.documentation;
        }
        if (item.documentation != null && typeof (item.documentation) === 'object') {
            // Newer format specifies the kind of documentation, assign appropriately
            if (item.documentation.kind === 'markdown') {
                suggestion.descriptionMarkdown = item.documentation.value;
            }
            else {
                suggestion.description = item.documentation.value;
            }
        }
    }
    // Public: Applies the textEdit part of a language server protocol CompletionItem to an
    // AutoComplete+ Suggestion via the replacementPrefix and text properties.
    //
    // * `textEdit` A {TextEdit} from a CompletionItem to apply.
    // * `editor` An Atom {TextEditor} used to obtain the necessary text replacement.
    // * `suggestion` An {atom$AutocompleteSuggestion} to set the replacementPrefix and text properties of.
    static applyTextEditToSuggestion(textEdit, editor, suggestion) {
        if (textEdit) {
            suggestion.replacementPrefix = editor.getTextInBufferRange(convert_1.default.lsRangeToAtomRange(textEdit.range));
            suggestion.text = textEdit.newText;
        }
    }
    // Public: Adds a snippet to the suggestion if the CompletionItem contains
    // snippet-formatted text
    //
    // * `item` An {CompletionItem} containing the completion items to be merged into.
    // * `suggestion` The {atom$AutocompleteSuggestion} to merge the conversion into.
    //
    static applySnippetToSuggestion(item, suggestion) {
        if (item.insertTextFormat === languageclient_1.InsertTextFormat.Snippet) {
            suggestion.snippet = item.textEdit != null ? item.textEdit.newText : (item.insertText || '');
        }
    }
    // Public: Obtain the textual suggestion type required by AutoComplete+ that
    // most closely maps to the numeric completion kind supplies by the language server.
    //
    // * `kind` A {Number} that represents the suggestion kind to be converted.
    //
    // Returns a {String} containing the AutoComplete+ suggestion type equivalent
    // to the given completion kind.
    static completionKindToSuggestionType(kind) {
        switch (kind) {
            case languageclient_1.CompletionItemKind.Constant:
                return 'constant';
            case languageclient_1.CompletionItemKind.Method:
                return 'method';
            case languageclient_1.CompletionItemKind.Function:
            case languageclient_1.CompletionItemKind.Constructor:
                return 'function';
            case languageclient_1.CompletionItemKind.Field:
            case languageclient_1.CompletionItemKind.Property:
                return 'property';
            case languageclient_1.CompletionItemKind.Variable:
                return 'variable';
            case languageclient_1.CompletionItemKind.Class:
                return 'class';
            case languageclient_1.CompletionItemKind.Struct:
            case languageclient_1.CompletionItemKind.TypeParameter:
                return 'type';
            case languageclient_1.CompletionItemKind.Operator:
                return 'selector';
            case languageclient_1.CompletionItemKind.Interface:
                return 'mixin';
            case languageclient_1.CompletionItemKind.Module:
                return 'module';
            case languageclient_1.CompletionItemKind.Unit:
                return 'builtin';
            case languageclient_1.CompletionItemKind.Enum:
            case languageclient_1.CompletionItemKind.EnumMember:
                return 'enum';
            case languageclient_1.CompletionItemKind.Keyword:
                return 'keyword';
            case languageclient_1.CompletionItemKind.Snippet:
                return 'snippet';
            case languageclient_1.CompletionItemKind.File:
            case languageclient_1.CompletionItemKind.Folder:
                return 'import';
            case languageclient_1.CompletionItemKind.Reference:
                return 'require';
            default:
                return 'value';
        }
    }
}
exports.default = AutocompleteAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2NvbXBsZXRlLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvYXV0b2NvbXBsZXRlLWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLHdDQUFpQztBQUNqQyxrQ0FBa0M7QUFHbEMscURBQXlDO0FBQ3pDLHNEQVcyQjtBQUMzQiwrQkFHYztBQVVkLG9GQUFvRjtBQUNwRix5QkFBeUI7QUFDekI7SUFBQTtRQVVVLHFCQUFnQixHQUFnRCxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQzlFLHdCQUFtQixHQUErRCxJQUFJLE9BQU8sRUFBRSxDQUFDO0lBc1YxRyxDQUFDO0lBaFdRLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQXNDO1FBQzNELE9BQU8sa0JBQWtCLENBQUMsa0JBQWtCLElBQUksSUFBSSxDQUFDO0lBQ3ZELENBQUM7SUFFTSxNQUFNLENBQUMsVUFBVSxDQUFDLGtCQUFzQztRQUM3RCxPQUFPLGtCQUFrQixDQUFDLGtCQUFrQixJQUFJLElBQUk7WUFDbEQsa0JBQWtCLENBQUMsa0JBQWtCLENBQUMsZUFBZSxLQUFLLElBQUksQ0FBQztJQUNuRSxDQUFDO0lBS0QseUZBQXlGO0lBQ3pGLHlDQUF5QztJQUN6QyxFQUFFO0lBQ0YseUVBQXlFO0lBQ3pFLHlEQUF5RDtJQUN6RCxzSEFBc0g7SUFDdEgsNkVBQTZFO0lBQzdFLEVBQUU7SUFDRixxRkFBcUY7SUFDckYsd0NBQXdDO0lBQzNCLGNBQWMsQ0FDekIsTUFBb0IsRUFDcEIsT0FBcUMsRUFDckMsMEJBQzRFLEVBQzVFLGlCQUEwQjs7WUFFMUIsTUFBTSxZQUFZLEdBQ2hCLE1BQU0sQ0FBQyxZQUFZLENBQUMsa0JBQWtCLElBQUksSUFBSSxDQUFDLENBQUM7Z0JBQzlDLE1BQU0sQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7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Q0FBQztZQUNuQjtnQkFDRSxPQUFPLE9BQU8sQ0FBQztTQUNsQjtJQUNILENBQUM7Q0FDRjtBQWpXRCxzQ0FpV0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB9IGZyb20gJ3ZzY29kZS1qc29ucnBjJztcclxuaW1wb3J0IHsgQWN0aXZlU2VydmVyIH0gZnJvbSAnLi4vc2VydmVyLW1hbmFnZXInO1xyXG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdmdXp6YWxkcmluLXBsdXMnO1xyXG5pbXBvcnQge1xyXG4gIENvbXBsZXRpb25JdGVtS2luZCxcclxuICBDb21wbGV0aW9uVHJpZ2dlcktpbmQsXHJcbiAgSW5zZXJ0VGV4dEZvcm1hdCxcclxuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgQ29tcGxldGlvbkNvbnRleHQsXHJcbiAgQ29tcGxldGlvbkl0ZW0sXHJcbiAgQ29tcGxldGlvbkxpc3QsXHJcbiAgQ29tcGxldGlvblBhcmFtcyxcclxuICBTZXJ2ZXJDYXBhYmlsaXRpZXMsXHJcbiAgVGV4dEVkaXQsXHJcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQge1xyXG4gIFBvaW50LFxyXG4gIFRleHRFZGl0b3IsXHJcbn0gZnJvbSAnYXRvbSc7XHJcbmltcG9ydCAqIGFzIGFjIGZyb20gJ2F0b20vYXV0b2NvbXBsZXRlLXBsdXMnO1xyXG5cclxuaW50ZXJmYWNlIFN1Z2dlc3Rpb25DYWNoZUVudHJ5IHtcclxuICBpc0luY29tcGxldGU6IGJvb2xlYW47XHJcbiAgdHJpZ2dlclBvaW50OiBQb2ludDtcclxuICB0cmlnZ2VyQ2hhcjogc3RyaW5nO1xyXG4gIHN1Z2dlc3Rpb25NYXA6IE1hcDxhYy5BbnlTdWdnZXN0aW9uLCBbQ29tcGxldGlvbkl0ZW0sIGJvb2xlYW5dPjtcclxufVxyXG5cclxuLy8gUHVibGljOiBBZGFwdHMgdGhlIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCBcInRleHREb2N1bWVudC9jb21wbGV0aW9uXCIgdG8gdGhlIEF0b21cclxuLy8gQXV0b0NvbXBsZXRlKyBwYWNrYWdlLlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvY29tcGxldGVBZGFwdGVyIHtcclxuICBwdWJsaWMgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLmNvbXBsZXRpb25Qcm92aWRlciAhPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0YXRpYyBjYW5SZXNvbHZlKHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLmNvbXBsZXRpb25Qcm92aWRlciAhPSBudWxsICYmXHJcbiAgICAgIHNlcnZlckNhcGFiaWxpdGllcy5jb21wbGV0aW9uUHJvdmlkZXIucmVzb2x2ZVByb3ZpZGVyID09PSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc3VnZ2VzdGlvbkNhY2hlOiBXZWFrTWFwPEFjdGl2ZVNlcnZlciwgU3VnZ2VzdGlvbkNhY2hlRW50cnk+ID0gbmV3IFdlYWtNYXAoKTtcclxuICBwcml2YXRlIF9jYW5jZWxsYXRpb25Ub2tlbnM6IFdlYWtNYXA8TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZT4gPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuICAvLyBQdWJsaWM6IE9idGFpbiBzdWdnZXN0aW9uIGxpc3QgZm9yIEF1dG9Db21wbGV0ZSsgYnkgcXVlcnlpbmcgdGhlIGxhbmd1YWdlIHNlcnZlciB1c2luZ1xyXG4gIC8vIHRoZSBgdGV4dERvY3VtZW50L2NvbXBsZXRpb25gIHJlcXVlc3QuXHJcbiAgLy9cclxuICAvLyAqIGBzZXJ2ZXJgIEFuIHtBY3RpdmVTZXJ2ZXJ9IHBvaW50aW5nIHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gcXVlcnkuXHJcbiAgLy8gKiBgcmVxdWVzdGAgVGhlIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IHRvIHNhdGlzZnkuXHJcbiAgLy8gKiBgb25EaWRDb252ZXJ0Q29tcGxldGlvbkl0ZW1gIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7Q29tcGxldGlvbkl0ZW19LCBhbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufVxyXG4gIC8vICAgYW5kIGEge2F0b20kQXV0b2NvbXBsZXRlUmVxdWVzdH0gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBjb252ZXJ0ZWQgaXRlbXMuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IG9mIGFuIHtBcnJheX0gb2Yge2F0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbn1zIGNvbnRhaW5pbmcgdGhlXHJcbiAgLy8gQXV0b0NvbXBsZXRlKyBzdWdnZXN0aW9ucyB0byBkaXNwbGF5LlxyXG4gIHB1YmxpYyBhc3luYyBnZXRTdWdnZXN0aW9ucyhcclxuICAgIHNlcnZlcjogQWN0aXZlU2VydmVyLFxyXG4gICAgcmVxdWVzdDogYWMuU3VnZ2VzdGlvbnNSZXF1ZXN0ZWRFdmVudCxcclxuICAgIG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtPzogKGl0ZW06IENvbXBsZXRpb25JdGVtLCBzdWdnZXN0aW9uOiBhYy5BbnlTdWdnZXN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogYWMuU3VnZ2VzdGlvbnNSZXF1ZXN0ZWRFdmVudCkgPT4gdm9pZCxcclxuICAgIG1pbmltdW1Xb3JkTGVuZ3RoPzogbnVtYmVyLFxyXG4gICk6IFByb21pc2U8YWMuQW55U3VnZ2VzdGlvbltdPiB7XHJcbiAgICBjb25zdCB0cmlnZ2VyQ2hhcnMgPVxyXG4gICAgICBzZXJ2ZXIuY2FwYWJpbGl0aWVzLmNvbXBsZXRpb25Qcm92aWRlciAhPSBudWxsID9cclxuICAgICAgICBzZXJ2ZXIuY2FwYWJpbGl0aWVzLmNvbXBsZXRpb25Qcm92aWRlci50cmlnZ2VyQ2hhcmFjdGVycyB8fCBbXSA6IFtdO1xyXG4gICAgY29uc3QgdHJpZ2dlckNoYXIgPSBBdXRvY29tcGxldGVBZGFwdGVyLmdldFRyaWdnZXJDaGFyYWN0ZXIocmVxdWVzdCwgdHJpZ2dlckNoYXJzKTtcclxuICAgIGNvbnN0IHByZWZpeFdpdGhUcmlnZ2VyID0gdHJpZ2dlckNoYXIgKyByZXF1ZXN0LnByZWZpeDtcclxuICAgIGNvbnN0IHRyaWdnZXJDb2x1bW4gPSByZXF1ZXN0LmJ1ZmZlclBvc2l0aW9uLmNvbHVtbiAtIHByZWZpeFdpdGhUcmlnZ2VyLmxlbmd0aDtcclxuICAgIGNvbnN0IHRyaWdnZXJQb2ludCA9IG5ldyBQb2ludChyZXF1ZXN0LmJ1ZmZlclBvc2l0aW9uLnJvdywgdHJpZ2dlckNvbHVtbik7XHJcblxyXG4gICAgLy8gT25seSBhdXRvLXRyaWdnZXIgb24gYSB0cmlnZ2VyIGNoYXJhY3RlciBvciBhZnRlciB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBmcm9tIGF1dG9jb21wbGV0ZS1wbHVzXHJcbiAgICBtaW5pbXVtV29yZExlbmd0aCA9IG1pbmltdW1Xb3JkTGVuZ3RoIHx8IDA7XHJcbiAgICBpZiAoIXJlcXVlc3QuYWN0aXZhdGVkTWFudWFsbHkgJiYgdHJpZ2dlckNoYXIgPT09ICcnICYmXHJcbiAgICAgICAgbWluaW11bVdvcmRMZW5ndGggPiAwICYmIHJlcXVlc3QucHJlZml4Lmxlbmd0aCA8IG1pbmltdW1Xb3JkTGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX3N1Z2dlc3Rpb25DYWNoZS5nZXQoc2VydmVyKTtcclxuICAgIGxldCBzdWdnZXN0aW9uTWFwID0gbnVsbDtcclxuXHJcbiAgICAvLyBEbyB3ZSBoYXZlIGNvbXBsZXRlIGNhY2hlZCBzdWdnZXN0aW9ucyB0aGF0IGFyZSBzdGlsbCB2YWxpZCBmb3IgdGhpcyByZXF1ZXN0XHJcbiAgICBpZiAoY2FjaGUgJiYgIWNhY2hlLmlzSW5jb21wbGV0ZSAmJiB0cmlnZ2VyQ2hhciAhPT0gJycgJiZcclxuICAgICAgICBjYWNoZS50cmlnZ2VyQ2hhciA9PT0gdHJpZ2dlckNoYXIgJiYgY2FjaGUudHJpZ2dlclBvaW50LmlzRXF1YWwodHJpZ2dlclBvaW50KSkge1xyXG4gICAgICBzdWdnZXN0aW9uTWFwID0gY2FjaGUuc3VnZ2VzdGlvbk1hcDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE91ciBjYWNoZWQgc3VnZ2VzdGlvbnMgY2FuJ3QgYmUgdXNlZCBzbyBvYnRhaW4gbmV3IG9uZXMgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgICAgIGNvbnN0IGNvbXBsZXRpb25zID1cclxuICAgICAgICBhd2FpdCBVdGlscy5kb1dpdGhDYW5jZWxsYXRpb25Ub2tlbihcclxuICAgICAgICAgIHNlcnZlci5jb25uZWN0aW9uLFxyXG4gICAgICAgICAgdGhpcy5fY2FuY2VsbGF0aW9uVG9rZW5zLFxyXG4gICAgICAgICAgKGNhbmNlbGxhdGlvblRva2VuKSA9PlxyXG4gICAgICAgICAgICBzZXJ2ZXIuY29ubmVjdGlvbi5jb21wbGV0aW9uKFxyXG4gICAgICAgICAgICAgIEF1dG9jb21wbGV0ZUFkYXB0ZXIuY3JlYXRlQ29tcGxldGlvblBhcmFtcyhyZXF1ZXN0LCB0cmlnZ2VyQ2hhciksIGNhbmNlbGxhdGlvblRva2VuKSxcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgaXNJbmNvbXBsZXRlID0gIUFycmF5LmlzQXJyYXkoY29tcGxldGlvbnMpICYmIGNvbXBsZXRpb25zLmlzSW5jb21wbGV0ZTtcclxuICAgICAgc3VnZ2VzdGlvbk1hcCA9IHRoaXMuY29tcGxldGlvbkl0ZW1zVG9TdWdnZXN0aW9ucyhjb21wbGV0aW9ucywgcmVxdWVzdCwgb25EaWRDb252ZXJ0Q29tcGxldGlvbkl0ZW0pO1xyXG4gICAgICB0aGlzLl9zdWdnZXN0aW9uQ2FjaGUuc2V0KHNlcnZlciwge2lzSW5jb21wbGV0ZSwgdHJpZ2dlckNoYXIsIHRyaWdnZXJQb2ludCwgc3VnZ2VzdGlvbk1hcH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbHRlciB0aGUgcmVzdWx0cyB0byByZWNhbGN1bGF0ZSB0aGUgc2NvcmUgYW5kIG9yZGVyaW5nICh1bmxlc3Mgb25seSB0cmlnZ2VyQ2hhcilcclxuICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gQXJyYXkuZnJvbShzdWdnZXN0aW9uTWFwLmtleXMoKSk7XHJcbiAgICBjb25zdCByZXBsYWNlbWVudFByZWZpeCA9IHJlcXVlc3QucHJlZml4ICE9PSB0cmlnZ2VyQ2hhciA/IHJlcXVlc3QucHJlZml4IDogJyc7XHJcbiAgICBBdXRvY29tcGxldGVBZGFwdGVyLnNldFJlcGxhY2VtZW50UHJlZml4T25TdWdnZXN0aW9ucyhzdWdnZXN0aW9ucywgcmVwbGFjZW1lbnRQcmVmaXgpO1xyXG4gICAgcmV0dXJuIHJlcXVlc3QucHJlZml4ID09PSBcIlwiIHx8IHJlcXVlc3QucHJlZml4ID09PSB0cmlnZ2VyQ2hhclxyXG4gICAgICA/IHN1Z2dlc3Rpb25zXHJcbiAgICAgIDogZmlsdGVyKHN1Z2dlc3Rpb25zLCByZXF1ZXN0LnByZWZpeCwge2tleTogJ3RleHQnfSk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IE9idGFpbiBhIGNvbXBsZXRlIHZlcnNpb24gb2YgYSBzdWdnZXN0aW9uIHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gIC8vIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgY2FuIHByb3ZpZGUgYnkgd2F5IG9mIHRoZSBgY29tcGxldGlvbkl0ZW0vcmVzb2x2ZWAgcmVxdWVzdC5cclxuICAvL1xyXG4gIC8vICogYHNlcnZlcmAgQW4ge0FjdGl2ZVNlcnZlcn0gcG9pbnRpbmcgdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0byBxdWVyeS5cclxuICAvLyAqIGBzdWdnZXN0aW9uYCBBbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSBzdWdnZXN0aW9uIHRoYXQgc2hvdWxkIGJlIHJlc29sdmVkLlxyXG4gIC8vICogYHJlcXVlc3RgIEFuIHtPYmplY3R9IHdpdGggdGhlIEF1dG9Db21wbGV0ZSsgcmVxdWVzdCB0byBzYXRpc2Z5LlxyXG4gIC8vICogYG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtYCBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0NvbXBsZXRpb25JdGVtfSwgYW4ge2F0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbn1cclxuICAvLyAgIGFuZCBhIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IGFsbG93aW5nIHlvdSB0byBhZGp1c3QgY29udmVydGVkIGl0ZW1zLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBvZiBhbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSB3aXRoIHRoZSByZXNvbHZlZCBBdXRvQ29tcGxldGUrIHN1Z2dlc3Rpb24uXHJcbiAgcHVibGljIGFzeW5jIGNvbXBsZXRlU3VnZ2VzdGlvbihcclxuICAgIHNlcnZlcjogQWN0aXZlU2VydmVyLFxyXG4gICAgc3VnZ2VzdGlvbjogYWMuQW55U3VnZ2VzdGlvbixcclxuICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsXHJcbiAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbT86IChpdGVtOiBDb21wbGV0aW9uSXRlbSwgc3VnZ2VzdGlvbjogYWMuQW55U3VnZ2VzdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQpID0+IHZvaWQsXHJcbiAgKTogUHJvbWlzZTxhYy5BbnlTdWdnZXN0aW9uPiB7XHJcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX3N1Z2dlc3Rpb25DYWNoZS5nZXQoc2VydmVyKTtcclxuICAgIGlmIChjYWNoZSkge1xyXG4gICAgICBjb25zdCBvcmlnaW5hbENvbXBsZXRpb25JdGVtID0gY2FjaGUuc3VnZ2VzdGlvbk1hcC5nZXQoc3VnZ2VzdGlvbik7XHJcbiAgICAgIGlmIChvcmlnaW5hbENvbXBsZXRpb25JdGVtICE9IG51bGwgJiYgb3JpZ2luYWxDb21wbGV0aW9uSXRlbVsxXSA9PT0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCByZXNvbHZlZENvbXBsZXRpb25JdGVtID0gYXdhaXQgc2VydmVyLmNvbm5lY3Rpb24uY29tcGxldGlvbkl0ZW1SZXNvbHZlKG9yaWdpbmFsQ29tcGxldGlvbkl0ZW1bMF0pO1xyXG4gICAgICAgIGlmIChyZXNvbHZlZENvbXBsZXRpb25JdGVtICE9IG51bGwpIHtcclxuICAgICAgICAgIEF1dG9jb21wbGV0ZUFkYXB0ZXIuY29tcGxldGlvbkl0ZW1Ub1N1Z2dlc3Rpb24oXHJcbiAgICAgICAgICAgIHJlc29sdmVkQ29tcGxldGlvbkl0ZW0sIHN1Z2dlc3Rpb24sIHJlcXVlc3QsIG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtKTtcclxuICAgICAgICAgIG9yaWdpbmFsQ29tcGxldGlvbkl0ZW1bMV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1Z2dlc3Rpb247XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IFNldCB0aGUgcmVwbGFjZW1lbnRQcmVmaXggcHJvcGVydHkgb24gYWxsIGdpdmVuIHN1Z2dlc3Rpb25zIHRvIHRoZVxyXG4gIC8vIHByZWZpeCBzcGVjaWZpZWQuXHJcbiAgLy9cclxuICAvLyAqIGBzdWdnZXN0aW9uc2AgQW4ge0FycmF5fSBvZiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufXMgdG8gc2V0IHRoZSByZXBsYWNlbWVudFByZWZpeCBvbi5cclxuICAvLyAqIGBwcmVmaXhgIFRoZSB7c3RyaW5nfSBjb250YWluaW5nIHRoZSBwcmVmaXggdGhhdCBzaG91bGQgYmUgc2V0IGFzIHJlcGxhY2VtZW50UHJlZml4IG9uIGFsbCBzdWdnZXN0aW9ucy5cclxuICBwdWJsaWMgc3RhdGljIHNldFJlcGxhY2VtZW50UHJlZml4T25TdWdnZXN0aW9ucyhzdWdnZXN0aW9uczogYWMuQW55U3VnZ2VzdGlvbltdLCBwcmVmaXg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgZm9yIChjb25zdCBzdWdnZXN0aW9uIG9mIHN1Z2dlc3Rpb25zKSB7XHJcbiAgICAgIHN1Z2dlc3Rpb24ucmVwbGFjZW1lbnRQcmVmaXggPSBwcmVmaXg7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IEdldCB0aGUgdHJpZ2dlciBjaGFyYWN0ZXIgdGhhdCBjYXVzZWQgdGhlIGF1dG9jb21wbGV0ZSAoaWYgYW55KS4gIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZVxyXG4gIC8vIEF1dG9Db21wbGV0ZS1wbHVzIGRvZXMgbm90IGhhdmUgdHJpZ2dlciBjaGFyYWN0ZXJzLiAgQWx0aG91Z2ggdGhlIHRlcm1pbm9sb2d5IGlzICdjaGFyYWN0ZXInIHdlIHRyZWF0XHJcbiAgLy8gdGhlbSBhcyB2YXJpYWJsZSBsZW5ndGggc3RyaW5ncyBhcyB0aGlzIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSB0byBzdXBwb3J0ICctPicgZXRjLlxyXG4gIC8vXHJcbiAgLy8gKiBgcmVxdWVzdGAgQW4ge0FycmF5fSBvZiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufXMgdG8gbG9jYXRlIHRoZSBwcmVmaXgsIGVkaXRvciwgYnVmZmVyUG9zaXRpb24gZXRjLlxyXG4gIC8vICogYHRyaWdnZXJDaGFyc2AgVGhlIHtBcnJheX0gb2Yge3N0cmluZ31zIHRoYXQgY2FuIGJlIHRyaWdnZXIgY2hhcmFjdGVycy5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7c3RyaW5nfSBjb250YWluaW5nIHRoZSBtYXRjaGluZyB0cmlnZ2VyIGNoYXJhY3RlciBvciBhbiBlbXB0eSBzdHJpbmcgaWYgb25lIHdhcyBub3QgbWF0Y2hlZC5cclxuICBwdWJsaWMgc3RhdGljIGdldFRyaWdnZXJDaGFyYWN0ZXIocmVxdWVzdDogYWMuU3VnZ2VzdGlvbnNSZXF1ZXN0ZWRFdmVudCwgdHJpZ2dlckNoYXJzOiBzdHJpbmdbXSk6IHN0cmluZyB7XHJcbiAgICAvLyBBdXRvQ29tcGxldGUtUGx1cyBjb25zaWRlcnMgdGV4dCBhZnRlciBhIHN5bWJvbCB0byBiZSBhIG5ldyB0cmlnZ2VyLiBTbyB3ZSBzaG91bGQgbG9vayBiYWNrd2FyZFxyXG4gICAgLy8gZnJvbSB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24gdG8gc2VlIGlmIG9uZSBpcyB0aGVyZSBhbmQgdGh1cyBzaW11bGF0ZSBpdC5cclxuICAgIGNvbnN0IGJ1ZmZlciA9IHJlcXVlc3QuZWRpdG9yLmdldEJ1ZmZlcigpO1xyXG4gICAgY29uc3QgY3Vyc29yID0gcmVxdWVzdC5idWZmZXJQb3NpdGlvbjtcclxuICAgIGNvbnN0IHByZWZpeFN0YXJ0Q29sdW1uID0gY3Vyc29yLmNvbHVtbiAtIHJlcXVlc3QucHJlZml4Lmxlbmd0aDtcclxuICAgIGZvciAoY29uc3QgdHJpZ2dlckNoYXIgb2YgdHJpZ2dlckNoYXJzKSB7XHJcbiAgICAgIGlmICh0cmlnZ2VyQ2hhciA9PT0gcmVxdWVzdC5wcmVmaXgpIHtcclxuICAgICAgICByZXR1cm4gdHJpZ2dlckNoYXI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByZWZpeFN0YXJ0Q29sdW1uID49IHRyaWdnZXJDaGFyLmxlbmd0aCkgeyAvLyBGYXIgZW5vdWdoIGFsb25nIGEgbGluZSB0byBmaXQgdGhlIHRyaWdnZXIgY2hhclxyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IFBvaW50KGN1cnNvci5yb3csIHByZWZpeFN0YXJ0Q29sdW1uIC0gdHJpZ2dlckNoYXIubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBwb3NzaWJsZVRyaWdnZXIgPSBidWZmZXIuZ2V0VGV4dEluUmFuZ2UoW3N0YXJ0LCBbY3Vyc29yLnJvdywgcHJlZml4U3RhcnRDb2x1bW5dXSk7XHJcbiAgICAgICAgaWYgKHBvc3NpYmxlVHJpZ2dlciA9PT0gdHJpZ2dlckNoYXIpIHsgLy8gVGhlIHRleHQgYmVmb3JlIG91ciB0cmlnZ2VyIGlzIGEgdHJpZ2dlciBjaGFyIVxyXG4gICAgICAgICAgcmV0dXJuIHRyaWdnZXJDaGFyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXJlIHdhcyBubyBleHBsaWNpdCB0cmlnZ2VyIGNoYXJcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zIHRvIGJlIHNlbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGJhc2VkIG9uIHRoZSBlZGl0b3IgYW5kIHBvc2l0aW9uIGZyb20gdGhlIEF1dG9Db21wbGV0ZVJlcXVlc3QuXHJcbiAgLy9cclxuICAvLyAqIGByZXF1ZXN0YCBUaGUge2F0b20kQXV0b2NvbXBsZXRlUmVxdWVzdH0gdG8gb2J0YWluIHRoZSBlZGl0b3IgZnJvbS5cclxuICAvLyAqIGB0cmlnZ2VyUG9pbnRgIFRoZSB7YXRvbSRQb2ludH0gd2hlcmUgdGhlIHRyaWdnZXIgc3RhcnRlZC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7c3RyaW5nfSBjb250YWluaW5nIHRoZSBwcmVmaXggaW5jbHVkaW5nIHRoZSB0cmlnZ2VyIGNoYXJhY3Rlci5cclxuICBwdWJsaWMgc3RhdGljIGdldFByZWZpeFdpdGhUcmlnZ2VyKHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsIHRyaWdnZXJQb2ludDogUG9pbnQpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHJlcXVlc3QuZWRpdG9yXHJcbiAgICAgIC5nZXRCdWZmZXIoKVxyXG4gICAgICAuZ2V0VGV4dEluUmFuZ2UoW1t0cmlnZ2VyUG9pbnQucm93LCB0cmlnZ2VyUG9pbnQuY29sdW1uXSwgcmVxdWVzdC5idWZmZXJQb3NpdGlvbl0pO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUge0NvbXBsZXRpb25QYXJhbXN9IHRvIGJlIHNlbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGJhc2VkIG9uIHRoZSBlZGl0b3IgYW5kIHBvc2l0aW9uIGZyb20gdGhlIEF1dG9jb21wbGV0ZSByZXF1ZXN0IGV0Yy5cclxuICAvL1xyXG4gIC8vICogYHJlcXVlc3RgIFRoZSB7YXRvbSRBdXRvY29tcGxldGVSZXF1ZXN0fSBjb250YWluaW5nIHRoZSByZXF1ZXN0IGRldGFpbHMuXHJcbiAgLy8gKiBgdHJpZ2dlckNoYXJhY3RlcmAgVGhlIHtzdHJpbmd9IGNvbnRhaW5pbmcgdGhlIHRyaWdnZXIgY2hhcmFjdGVyIChlbXB0eSBpZiBub25lKS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYW4ge0NvbXBsZXRpb25QYXJhbXN9IHdpdGggdGhlIGtleXM6XHJcbiAgLy8gICogYHRleHREb2N1bWVudGAgdGhlIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCB0ZXh0RG9jdW1lbnQgaWRlbnRpZmljYXRpb24uXHJcbiAgLy8gICogYHBvc2l0aW9uYCB0aGUgcG9zaXRpb24gd2l0aGluIHRoZSB0ZXh0IGRvY3VtZW50IHRvIGRpc3BsYXkgY29tcGxldGlvbiByZXF1ZXN0IGZvci5cclxuICAvLyAgKiBgY29udGV4dGAgY29udGFpbmluZyB0aGUgdHJpZ2dlciBjaGFyYWN0ZXIgYW5kIGtpbmQuXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVDb21wbGV0aW9uUGFyYW1zKFxyXG4gICAgcmVxdWVzdDogYWMuU3VnZ2VzdGlvbnNSZXF1ZXN0ZWRFdmVudCwgdHJpZ2dlckNoYXJhY3Rlcjogc3RyaW5nKTogQ29tcGxldGlvblBhcmFtcyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKHJlcXVlc3QuZWRpdG9yKSxcclxuICAgICAgcG9zaXRpb246IENvbnZlcnQucG9pbnRUb1Bvc2l0aW9uKHJlcXVlc3QuYnVmZmVyUG9zaXRpb24pLFxyXG4gICAgICBjb250ZXh0OiBBdXRvY29tcGxldGVBZGFwdGVyLmNyZWF0ZUNvbXBsZXRpb25Db250ZXh0KHRyaWdnZXJDaGFyYWN0ZXIpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIHtDb21wbGV0aW9uQ29udGV4dH0gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gYmFzZWQgb24gdGhlIHRyaWdnZXIgY2hhcmFjdGVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgdHJpZ2dlckNoYXJhY3RlcmAgVGhlIHtzdHJpbmd9IGNvbnRhaW5pbmcgdGhlIHRyaWdnZXIgY2hhcmFjdGVyIG9yICcnIGlmIG5vbmUuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGFuIHtDb21wbGV0aW9uQ29udGV4dH0gdGhhdCBzcGVjaWZpZXMgdGhlIHRyaWdnZXJLaW5kIGFuZCB0aGUgdHJpZ2dlckNoYXJhY3RlclxyXG4gIC8vIGlmIHRoZXJlIGlzIG9uZS5cclxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUNvbXBsZXRpb25Db250ZXh0KHRyaWdnZXJDaGFyYWN0ZXI6IHN0cmluZyk6IENvbXBsZXRpb25Db250ZXh0IHtcclxuICAgIHJldHVybiB0cmlnZ2VyQ2hhcmFjdGVyID09PSAnJ1xyXG4gICAgICA/IHt0cmlnZ2VyS2luZDogQ29tcGxldGlvblRyaWdnZXJLaW5kLkludm9rZWR9XHJcbiAgICAgIDoge3RyaWdnZXJLaW5kOiBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckNoYXJhY3RlciwgdHJpZ2dlckNoYXJhY3Rlcn07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgQ29tcGxldGlvbkl0ZW0gYXJyYXkgb3IgQ29tcGxldGlvbkxpc3QgdG9cclxuICAvLyBhbiBhcnJheSBvZiBvcmRlcmVkIEF1dG9Db21wbGV0ZSsgc3VnZ2VzdGlvbnMuXHJcbiAgLy9cclxuICAvLyAqIGBjb21wbGV0aW9uSXRlbXNgIEFuIHtBcnJheX0gb2Yge0NvbXBsZXRpb25JdGVtfSBvYmplY3RzIG9yIGEge0NvbXBsZXRpb25MaXN0fSBjb250YWluaW5nIGNvbXBsZXRpb25cclxuICAvLyAgICAgICAgICAgaXRlbXMgdG8gYmUgY29udmVydGVkLlxyXG4gIC8vICogYHJlcXVlc3RgIFRoZSB7YXRvbSRBdXRvY29tcGxldGVSZXF1ZXN0fSB0byBzYXRpc2Z5LlxyXG4gIC8vICogYG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtYCBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7Q29tcGxldGlvbkl0ZW19LCBhbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufVxyXG4gIC8vICAgYW5kIGEge2F0b20kQXV0b2NvbXBsZXRlUmVxdWVzdH0gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBjb252ZXJ0ZWQgaXRlbXMuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge01hcH0gb2YgQXV0b0NvbXBsZXRlKyBzdWdnZXN0aW9ucyBvcmRlcmVkIGJ5IHRoZSBDb21wbGV0aW9uSXRlbXMgc29ydFRleHQuXHJcbiAgcHVibGljIGNvbXBsZXRpb25JdGVtc1RvU3VnZ2VzdGlvbnMoXHJcbiAgICBjb21wbGV0aW9uSXRlbXM6IENvbXBsZXRpb25JdGVtW10gfCBDb21wbGV0aW9uTGlzdCxcclxuICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsXHJcbiAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbT86IChpdGVtOiBDb21wbGV0aW9uSXRlbSwgc3VnZ2VzdGlvbjogYWMuQW55U3VnZ2VzdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQpID0+IHZvaWQsXHJcbiAgKTogTWFwPGFjLkFueVN1Z2dlc3Rpb24sIFtDb21wbGV0aW9uSXRlbSwgYm9vbGVhbl0+IHtcclxuICAgIHJldHVybiBuZXcgTWFwKChBcnJheS5pc0FycmF5KGNvbXBsZXRpb25JdGVtcykgPyBjb21wbGV0aW9uSXRlbXMgOiBjb21wbGV0aW9uSXRlbXMuaXRlbXMgfHwgW10pXHJcbiAgICAgIC5zb3J0KChhLCBiKSA9PiAoYS5zb3J0VGV4dCB8fCBhLmxhYmVsKS5sb2NhbGVDb21wYXJlKGIuc29ydFRleHQgfHwgYi5sYWJlbCkpXHJcbiAgICAgIC5tYXA8W2FjLkFueVN1Z2dlc3Rpb24sIFtDb21wbGV0aW9uSXRlbSwgYm9vbGVhbl1dPihcclxuICAgICAgICAocykgPT4gW1xyXG4gICAgICAgICAgQXV0b2NvbXBsZXRlQWRhcHRlci5jb21wbGV0aW9uSXRlbVRvU3VnZ2VzdGlvbihcclxuICAgICAgICAgICAgcywge30gYXMgYWMuQW55U3VnZ2VzdGlvbiwgcmVxdWVzdCwgb25EaWRDb252ZXJ0Q29tcGxldGlvbkl0ZW0pLFxyXG4gICAgICAgICAgW3MsIGZhbHNlXV0pKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCBDb21wbGV0aW9uSXRlbSB0byBhbiBBdXRvQ29tcGxldGUrIHN1Z2dlc3Rpb24uXHJcbiAgLy9cclxuICAvLyAqIGBpdGVtYCBBbiB7Q29tcGxldGlvbkl0ZW19IGNvbnRhaW5pbmcgYSBjb21wbGV0aW9uIGl0ZW0gdG8gYmUgY29udmVydGVkLlxyXG4gIC8vICogYHN1Z2dlc3Rpb25gIEEge2F0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbn0gdG8gaGF2ZSB0aGUgY29udmVyc2lvbiBhcHBsaWVkIHRvLlxyXG4gIC8vICogYHJlcXVlc3RgIFRoZSB7YXRvbSRBdXRvY29tcGxldGVSZXF1ZXN0fSB0byBzYXRpc2Z5LlxyXG4gIC8vICogYG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtYCBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7Q29tcGxldGlvbkl0ZW19LCBhbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufVxyXG4gIC8vICAgYW5kIGEge2F0b20kQXV0b2NvbXBsZXRlUmVxdWVzdH0gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBjb252ZXJ0ZWQgaXRlbXMuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIHRoZSB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSBwYXNzZWQgaW4gYXMgc3VnZ2VzdGlvbiB3aXRoIHRoZSBjb252ZXJzaW9uIGFwcGxpZWQuXHJcbiAgcHVibGljIHN0YXRpYyBjb21wbGV0aW9uSXRlbVRvU3VnZ2VzdGlvbihcclxuICAgIGl0ZW06IENvbXBsZXRpb25JdGVtLFxyXG4gICAgc3VnZ2VzdGlvbjogYWMuQW55U3VnZ2VzdGlvbixcclxuICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsXHJcbiAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbT86IChpdGVtOiBDb21wbGV0aW9uSXRlbSwgc3VnZ2VzdGlvbjogYWMuQW55U3VnZ2VzdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQpID0+IHZvaWQsXHJcbiAgKTogYWMuQW55U3VnZ2VzdGlvbiB7XHJcbiAgICBBdXRvY29tcGxldGVBZGFwdGVyLmFwcGx5Q29tcGxldGlvbkl0ZW1Ub1N1Z2dlc3Rpb24oaXRlbSwgc3VnZ2VzdGlvbiBhcyBhYy5UZXh0U3VnZ2VzdGlvbik7XHJcbiAgICBBdXRvY29tcGxldGVBZGFwdGVyLmFwcGx5VGV4dEVkaXRUb1N1Z2dlc3Rpb24oaXRlbS50ZXh0RWRpdCwgcmVxdWVzdC5lZGl0b3IsIHN1Z2dlc3Rpb24gYXMgYWMuVGV4dFN1Z2dlc3Rpb24pO1xyXG4gICAgQXV0b2NvbXBsZXRlQWRhcHRlci5hcHBseVNuaXBwZXRUb1N1Z2dlc3Rpb24oaXRlbSwgc3VnZ2VzdGlvbiBhcyBhYy5TbmlwcGV0U3VnZ2VzdGlvbik7XHJcbiAgICBpZiAob25EaWRDb252ZXJ0Q29tcGxldGlvbkl0ZW0gIT0gbnVsbCkge1xyXG4gICAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbShpdGVtLCBzdWdnZXN0aW9uLCByZXF1ZXN0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3VnZ2VzdGlvbjtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCB0aGUgcHJpbWFyeSBwYXJ0cyBvZiBhIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCBDb21wbGV0aW9uSXRlbSB0byBhbiBBdXRvQ29tcGxldGUrIHN1Z2dlc3Rpb24uXHJcbiAgLy9cclxuICAvLyAqIGBpdGVtYCBBbiB7Q29tcGxldGlvbkl0ZW19IGNvbnRhaW5pbmcgdGhlIGNvbXBsZXRpb24gaXRlbXMgdG8gYmUgbWVyZ2VkIGludG8uXHJcbiAgLy8gKiBgc3VnZ2VzdGlvbmAgVGhlIHthdG9tJEF1dG9jb21wbGV0ZVN1Z2dlc3Rpb259IHRvIG1lcmdlIHRoZSBjb252ZXJzaW9uIGludG8uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGFuIHthdG9tJEF1dG9jb21wbGV0ZVN1Z2dlc3Rpb259IGNyZWF0ZWQgZnJvbSB0aGUge0NvbXBsZXRpb25JdGVtfS5cclxuICBwdWJsaWMgc3RhdGljIGFwcGx5Q29tcGxldGlvbkl0ZW1Ub1N1Z2dlc3Rpb24oaXRlbTogQ29tcGxldGlvbkl0ZW0sIHN1Z2dlc3Rpb246IGFjLlRleHRTdWdnZXN0aW9uKSB7XHJcbiAgICBzdWdnZXN0aW9uLnRleHQgPSBpdGVtLmluc2VydFRleHQgfHwgaXRlbS5sYWJlbDtcclxuICAgIHN1Z2dlc3Rpb24uZGlzcGxheVRleHQgPSBpdGVtLmxhYmVsO1xyXG4gICAgc3VnZ2VzdGlvbi50eXBlID0gQXV0b2NvbXBsZXRlQWRhcHRlci5jb21wbGV0aW9uS2luZFRvU3VnZ2VzdGlvblR5cGUoaXRlbS5raW5kKTtcclxuICAgIHN1Z2dlc3Rpb24ucmlnaHRMYWJlbCA9IGl0ZW0uZGV0YWlsO1xyXG5cclxuICAgIC8vIE9sZGVyIGZvcm1hdCwgY2FuJ3Qga25vdyB3aGF0IGl0IGlzIHNvIGFzc2lnbiB0byBib3RoIGFuZCBob3BlIGZvciBiZXN0XHJcbiAgICBpZiAodHlwZW9mKGl0ZW0uZG9jdW1lbnRhdGlvbikgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHN1Z2dlc3Rpb24uZGVzY3JpcHRpb25NYXJrZG93biA9IGl0ZW0uZG9jdW1lbnRhdGlvbjtcclxuICAgICAgc3VnZ2VzdGlvbi5kZXNjcmlwdGlvbiA9IGl0ZW0uZG9jdW1lbnRhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXRlbS5kb2N1bWVudGF0aW9uICE9IG51bGwgJiYgdHlwZW9mKGl0ZW0uZG9jdW1lbnRhdGlvbikgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIC8vIE5ld2VyIGZvcm1hdCBzcGVjaWZpZXMgdGhlIGtpbmQgb2YgZG9jdW1lbnRhdGlvbiwgYXNzaWduIGFwcHJvcHJpYXRlbHlcclxuICAgICAgaWYgKGl0ZW0uZG9jdW1lbnRhdGlvbi5raW5kID09PSAnbWFya2Rvd24nKSB7XHJcbiAgICAgICAgc3VnZ2VzdGlvbi5kZXNjcmlwdGlvbk1hcmtkb3duID0gaXRlbS5kb2N1bWVudGF0aW9uLnZhbHVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN1Z2dlc3Rpb24uZGVzY3JpcHRpb24gPSBpdGVtLmRvY3VtZW50YXRpb24udmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQXBwbGllcyB0aGUgdGV4dEVkaXQgcGFydCBvZiBhIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCBDb21wbGV0aW9uSXRlbSB0byBhblxyXG4gIC8vIEF1dG9Db21wbGV0ZSsgU3VnZ2VzdGlvbiB2aWEgdGhlIHJlcGxhY2VtZW50UHJlZml4IGFuZCB0ZXh0IHByb3BlcnRpZXMuXHJcbiAgLy9cclxuICAvLyAqIGB0ZXh0RWRpdGAgQSB7VGV4dEVkaXR9IGZyb20gYSBDb21wbGV0aW9uSXRlbSB0byBhcHBseS5cclxuICAvLyAqIGBlZGl0b3JgIEFuIEF0b20ge1RleHRFZGl0b3J9IHVzZWQgdG8gb2J0YWluIHRoZSBuZWNlc3NhcnkgdGV4dCByZXBsYWNlbWVudC5cclxuICAvLyAqIGBzdWdnZXN0aW9uYCBBbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSB0byBzZXQgdGhlIHJlcGxhY2VtZW50UHJlZml4IGFuZCB0ZXh0IHByb3BlcnRpZXMgb2YuXHJcbiAgcHVibGljIHN0YXRpYyBhcHBseVRleHRFZGl0VG9TdWdnZXN0aW9uKFxyXG4gICAgdGV4dEVkaXQ6IFRleHRFZGl0IHwgdW5kZWZpbmVkLFxyXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxyXG4gICAgc3VnZ2VzdGlvbjogYWMuVGV4dFN1Z2dlc3Rpb24sXHJcbiAgKTogdm9pZCB7XHJcbiAgICBpZiAodGV4dEVkaXQpIHtcclxuICAgICAgc3VnZ2VzdGlvbi5yZXBsYWNlbWVudFByZWZpeCA9IGVkaXRvci5nZXRUZXh0SW5CdWZmZXJSYW5nZShDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZSh0ZXh0RWRpdC5yYW5nZSkpO1xyXG4gICAgICBzdWdnZXN0aW9uLnRleHQgPSB0ZXh0RWRpdC5uZXdUZXh0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBBZGRzIGEgc25pcHBldCB0byB0aGUgc3VnZ2VzdGlvbiBpZiB0aGUgQ29tcGxldGlvbkl0ZW0gY29udGFpbnNcclxuICAvLyBzbmlwcGV0LWZvcm1hdHRlZCB0ZXh0XHJcbiAgLy9cclxuICAvLyAqIGBpdGVtYCBBbiB7Q29tcGxldGlvbkl0ZW19IGNvbnRhaW5pbmcgdGhlIGNvbXBsZXRpb24gaXRlbXMgdG8gYmUgbWVyZ2VkIGludG8uXHJcbiAgLy8gKiBgc3VnZ2VzdGlvbmAgVGhlIHthdG9tJEF1dG9jb21wbGV0ZVN1Z2dlc3Rpb259IHRvIG1lcmdlIHRoZSBjb252ZXJzaW9uIGludG8uXHJcbiAgLy9cclxuICBwdWJsaWMgc3RhdGljIGFwcGx5U25pcHBldFRvU3VnZ2VzdGlvbihpdGVtOiBDb21wbGV0aW9uSXRlbSwgc3VnZ2VzdGlvbjogYWMuU25pcHBldFN1Z2dlc3Rpb24pOiB2b2lkIHtcclxuICAgIGlmIChpdGVtLmluc2VydFRleHRGb3JtYXQgPT09IEluc2VydFRleHRGb3JtYXQuU25pcHBldCkge1xyXG4gICAgICBzdWdnZXN0aW9uLnNuaXBwZXQgPSBpdGVtLnRleHRFZGl0ICE9IG51bGwgPyBpdGVtLnRleHRFZGl0Lm5ld1RleHQgOiAoaXRlbS5pbnNlcnRUZXh0IHx8ICcnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogT2J0YWluIHRoZSB0ZXh0dWFsIHN1Z2dlc3Rpb24gdHlwZSByZXF1aXJlZCBieSBBdXRvQ29tcGxldGUrIHRoYXRcclxuICAvLyBtb3N0IGNsb3NlbHkgbWFwcyB0byB0aGUgbnVtZXJpYyBjb21wbGV0aW9uIGtpbmQgc3VwcGxpZXMgYnkgdGhlIGxhbmd1YWdlIHNlcnZlci5cclxuICAvL1xyXG4gIC8vICogYGtpbmRgIEEge051bWJlcn0gdGhhdCByZXByZXNlbnRzIHRoZSBzdWdnZXN0aW9uIGtpbmQgdG8gYmUgY29udmVydGVkLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtTdHJpbmd9IGNvbnRhaW5pbmcgdGhlIEF1dG9Db21wbGV0ZSsgc3VnZ2VzdGlvbiB0eXBlIGVxdWl2YWxlbnRcclxuICAvLyB0byB0aGUgZ2l2ZW4gY29tcGxldGlvbiBraW5kLlxyXG4gIHB1YmxpYyBzdGF0aWMgY29tcGxldGlvbktpbmRUb1N1Z2dlc3Rpb25UeXBlKGtpbmQ6IG51bWJlciB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XHJcbiAgICBzd2l0Y2ggKGtpbmQpIHtcclxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQ6XHJcbiAgICAgICAgcmV0dXJuICdjb25zdGFudCc7XHJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZDpcclxuICAgICAgICByZXR1cm4gJ21ldGhvZCc7XHJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uOlxyXG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvcjpcclxuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uJztcclxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuRmllbGQ6XHJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5OlxyXG4gICAgICAgIHJldHVybiAncHJvcGVydHknO1xyXG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5WYXJpYWJsZTpcclxuICAgICAgICByZXR1cm4gJ3ZhcmlhYmxlJztcclxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3M6XHJcbiAgICAgICAgcmV0dXJuICdjbGFzcyc7XHJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdDpcclxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuVHlwZVBhcmFtZXRlcjpcclxuICAgICAgICByZXR1cm4gJ3R5cGUnO1xyXG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5PcGVyYXRvcjpcclxuICAgICAgICByZXR1cm4gJ3NlbGVjdG9yJztcclxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuSW50ZXJmYWNlOlxyXG4gICAgICAgIHJldHVybiAnbWl4aW4nO1xyXG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU6XHJcbiAgICAgICAgcmV0dXJuICdtb2R1bGUnO1xyXG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5Vbml0OlxyXG4gICAgICAgIHJldHVybiAnYnVpbHRpbic7XHJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW06XHJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXI6XHJcbiAgICAgICAgcmV0dXJuICdlbnVtJztcclxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZDpcclxuICAgICAgICByZXR1cm4gJ2tleXdvcmQnO1xyXG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5TbmlwcGV0OlxyXG4gICAgICAgIHJldHVybiAnc25pcHBldCc7XHJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGU6XHJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkZvbGRlcjpcclxuICAgICAgICByZXR1cm4gJ2ltcG9ydCc7XHJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLlJlZmVyZW5jZTpcclxuICAgICAgICByZXR1cm4gJ3JlcXVpcmUnO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiAndmFsdWUnO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=
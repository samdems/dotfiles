"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const Utils = require("../utils");
const atom_1 = require("atom");
// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
class DefinitionAdapter {
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing a definitionProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.definitionProvider === true;
    }
    // Public: Get the definitions for a symbol at a given {Point} within a
    // {TextEditor} including optionally highlighting all other references
    // within the document if the langauge server also supports highlighting.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will provide definitions and highlights.
    // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
    // * `languageName` The name of the programming language.
    // * `editor` The Atom {TextEditor} containing the symbol and potential highlights.
    // * `point` The Atom {Point} containing the position of the text that represents the symbol
    //           for which the definition and highlights should be provided.
    //
    // Returns a {Promise} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    getDefinition(connection, serverCapabilities, languageName, editor, point) {
        return __awaiter(this, void 0, void 0, function* () {
            const documentPositionParams = convert_1.default.editorToTextDocumentPositionParams(editor, point);
            const definitionLocations = DefinitionAdapter.normalizeLocations(yield connection.gotoDefinition(documentPositionParams));
            if (definitionLocations == null || definitionLocations.length === 0) {
                return null;
            }
            let queryRange;
            if (serverCapabilities.documentHighlightProvider) {
                const highlights = yield connection.documentHighlight(documentPositionParams);
                if (highlights != null && highlights.length > 0) {
                    queryRange = highlights.map((h) => convert_1.default.lsRangeToAtomRange(h.range));
                }
            }
            return {
                queryRange: queryRange || [Utils.getWordAtPosition(editor, point)],
                definitions: DefinitionAdapter.convertLocationsToDefinitions(definitionLocations, languageName),
            };
        });
    }
    // Public: Normalize the locations so a single {Location} becomes an {Array} of just
    // one. The language server protocol return either as the protocol evolved between v1 and v2.
    //
    // * `locationResult` either a single {Location} object or an {Array} of {Locations}
    //
    // Returns an {Array} of {Location}s or {null} if the locationResult was null.
    static normalizeLocations(locationResult) {
        if (locationResult == null) {
            return null;
        }
        return (Array.isArray(locationResult) ? locationResult : [locationResult]).filter((d) => d.range.start != null);
    }
    // Public: Convert an {Array} of {Location} objects into an Array of {Definition}s.
    //
    // * `locations` An {Array} of {Location} objects to be converted.
    // * `languageName` The name of the language these objects are written in.
    //
    // Returns an {Array} of {Definition}s that represented the converted {Location}s.
    static convertLocationsToDefinitions(locations, languageName) {
        return locations.map((d) => ({
            path: convert_1.default.uriToPath(d.uri),
            position: convert_1.default.positionToPoint(d.range.start),
            range: atom_1.Range.fromObject(convert_1.default.lsRangeToAtomRange(d.range)),
            language: languageName,
        }));
    }
}
exports.default = DefinitionAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmaW5pdGlvbi1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2FkYXB0ZXJzL2RlZmluaXRpb24tYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0Esd0NBQWlDO0FBQ2pDLGtDQUFrQztBQU1sQywrQkFJYztBQUVkLGdFQUFnRTtBQUNoRSx3RUFBd0U7QUFDeEU7SUFDRSxnRkFBZ0Y7SUFDaEYsMEVBQTBFO0lBQzFFLEVBQUU7SUFDRixzRkFBc0Y7SUFDdEYsRUFBRTtJQUNGLDJFQUEyRTtJQUMzRSw0QkFBNEI7SUFDckIsTUFBTSxDQUFDLFFBQVEsQ0FBQyxrQkFBc0M7UUFDM0QsT0FBTyxrQkFBa0IsQ0FBQyxrQkFBa0IsS0FBSyxJQUFJLENBQUM7SUFDeEQsQ0FBQztJQUVELHVFQUF1RTtJQUN2RSxzRUFBc0U7SUFDdEUseUVBQXlFO0lBQ3pFLEVBQUU7SUFDRixtSEFBbUg7SUFDbkgsNEZBQTRGO0lBQzVGLHlEQUF5RDtJQUN6RCxtRkFBbUY7SUFDbkYsNEZBQTRGO0lBQzVGLHdFQUF3RTtJQUN4RSxFQUFFO0lBQ0YsMkVBQTJFO0lBQzNFLDRCQUE0QjtJQUNmLGFBQWEsQ0FDeEIsVUFBb0MsRUFDcEMsa0JBQXNDLEVBQ3RDLFlBQW9CLEVBQ3BCLE1BQWtCLEVBQ2xCLEtBQVk7O1lBRVosTUFBTSxzQkFBc0IsR0FBRyxpQkFBTyxDQUFDLGtDQUFrQyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUN6RixNQUFNLG1CQUFtQixHQUFHLGlCQUFpQixDQUFDLGtCQUFrQixDQUM5RCxNQUFNLFVBQVUsQ0FBQyxjQUFjLENBQUMsc0JBQXNCLENBQUMsQ0FDeEQsQ0FBQztZQUNGLElBQUksbUJBQW1CLElBQUksSUFBSSxJQUFJLG1CQUFtQixDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQ25FLE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFFRCxJQUFJLFVBQVUsQ0FBQztZQUNmLElBQUksa0JBQWtCLENBQUMseUJBQXlCLEVBQUU7Z0JBQ2hELE1BQU0sVUFBVSxHQUFHLE1BQU0sVUFBVSxDQUFDLGlCQUFpQixDQUFDLHNCQUFzQixDQUFDLENBQUM7Z0JBQzlFLElBQUksVUFBVSxJQUFJLElBQUksSUFBSSxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDL0MsVUFBVSxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7aUJBQ3pFO2FBQ0Y7WUFFRCxPQUFPO2dCQUNMLFVBQVUsRUFBRSxVQUFVLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNsRSxXQUFXLEVBQUUsaUJBQWlCLENBQUMsNkJBQTZCLENBQUMsbUJBQW1CLEVBQUUsWUFBWSxDQUFDO2FBQ2hHLENBQUM7UUFDSixDQUFDO0tBQUE7SUFFRCxvRkFBb0Y7SUFDcEYsNkZBQTZGO0lBQzdGLEVBQUU7SUFDRixvRkFBb0Y7SUFDcEYsRUFBRTtJQUNGLDhFQUE4RTtJQUN2RSxNQUFNLENBQUMsa0JBQWtCLENBQUMsY0FBcUM7UUFDcEUsSUFBSSxjQUFjLElBQUksSUFBSSxFQUFFO1lBQzFCLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQztJQUNsSCxDQUFDO0lBRUQsbUZBQW1GO0lBQ25GLEVBQUU7SUFDRixrRUFBa0U7SUFDbEUsMEVBQTBFO0lBQzFFLEVBQUU7SUFDRixrRkFBa0Y7SUFDM0UsTUFBTSxDQUFDLDZCQUE2QixDQUFDLFNBQXFCLEVBQUUsWUFBb0I7UUFDckYsT0FBTyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzNCLElBQUksRUFBRSxpQkFBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQzlCLFFBQVEsRUFBRSxpQkFBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUNoRCxLQUFLLEVBQUUsWUFBSyxDQUFDLFVBQVUsQ0FBQyxpQkFBTyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM1RCxRQUFRLEVBQUUsWUFBWTtTQUN2QixDQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7Q0FDRjtBQWpGRCxvQ0FpRkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhdG9tSWRlIGZyb20gJ2F0b20taWRlJztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XHJcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gJy4uL3V0aWxzJztcclxuaW1wb3J0IHtcclxuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgTG9jYXRpb24sXHJcbiAgU2VydmVyQ2FwYWJpbGl0aWVzLFxyXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcclxuaW1wb3J0IHtcclxuICBQb2ludCxcclxuICBUZXh0RWRpdG9yLFxyXG4gIFJhbmdlLFxyXG59IGZyb20gJ2F0b20nO1xyXG5cclxuLy8gUHVibGljOiBBZGFwdHMgdGhlIGxhbmd1YWdlIHNlcnZlciBkZWZpbml0aW9uIHByb3ZpZGVyIHRvIHRoZVxyXG4vLyBBdG9tIElERSBVSSBEZWZpbml0aW9ucyBwYWNrYWdlIGZvciAnR28gVG8gRGVmaW5pdGlvbicgZnVuY3Rpb25hbGl0eS5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmaW5pdGlvbkFkYXB0ZXIge1xyXG4gIC8vIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIGRlZmluaXRpb25Qcm92aWRlci5cclxuICAvL1xyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgcHVibGljIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5kZWZpbml0aW9uUHJvdmlkZXIgPT09IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IEdldCB0aGUgZGVmaW5pdGlvbnMgZm9yIGEgc3ltYm9sIGF0IGEgZ2l2ZW4ge1BvaW50fSB3aXRoaW4gYVxyXG4gIC8vIHtUZXh0RWRpdG9yfSBpbmNsdWRpbmcgb3B0aW9uYWxseSBoaWdobGlnaHRpbmcgYWxsIG90aGVyIHJlZmVyZW5jZXNcclxuICAvLyB3aXRoaW4gdGhlIGRvY3VtZW50IGlmIHRoZSBsYW5nYXVnZSBzZXJ2ZXIgYWxzbyBzdXBwb3J0cyBoaWdobGlnaHRpbmcuXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIHByb3ZpZGUgZGVmaW5pdGlvbnMgYW5kIGhpZ2hsaWdodHMuXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgdXNlZC5cclxuICAvLyAqIGBsYW5ndWFnZU5hbWVgIFRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtbWluZyBsYW5ndWFnZS5cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBzeW1ib2wgYW5kIHBvdGVudGlhbCBoaWdobGlnaHRzLlxyXG4gIC8vICogYHBvaW50YCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSB0ZXh0IHRoYXQgcmVwcmVzZW50cyB0aGUgc3ltYm9sXHJcbiAgLy8gICAgICAgICAgIGZvciB3aGljaCB0aGUgZGVmaW5pdGlvbiBhbmQgaGlnaGxpZ2h0cyBzaG91bGQgYmUgcHJvdmlkZWQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgcHVibGljIGFzeW5jIGdldERlZmluaXRpb24oXHJcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgICBzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyxcclxuICAgIGxhbmd1YWdlTmFtZTogc3RyaW5nLFxyXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxyXG4gICAgcG9pbnQ6IFBvaW50LFxyXG4gICk6IFByb21pc2U8YXRvbUlkZS5EZWZpbml0aW9uUXVlcnlSZXN1bHQgfCBudWxsPiB7XHJcbiAgICBjb25zdCBkb2N1bWVudFBvc2l0aW9uUGFyYW1zID0gQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGVkaXRvciwgcG9pbnQpO1xyXG4gICAgY29uc3QgZGVmaW5pdGlvbkxvY2F0aW9ucyA9IERlZmluaXRpb25BZGFwdGVyLm5vcm1hbGl6ZUxvY2F0aW9ucyhcclxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5nb3RvRGVmaW5pdGlvbihkb2N1bWVudFBvc2l0aW9uUGFyYW1zKSxcclxuICAgICk7XHJcbiAgICBpZiAoZGVmaW5pdGlvbkxvY2F0aW9ucyA9PSBudWxsIHx8IGRlZmluaXRpb25Mb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBxdWVyeVJhbmdlO1xyXG4gICAgaWYgKHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudEhpZ2hsaWdodFByb3ZpZGVyKSB7XHJcbiAgICAgIGNvbnN0IGhpZ2hsaWdodHMgPSBhd2FpdCBjb25uZWN0aW9uLmRvY3VtZW50SGlnaGxpZ2h0KGRvY3VtZW50UG9zaXRpb25QYXJhbXMpO1xyXG4gICAgICBpZiAoaGlnaGxpZ2h0cyAhPSBudWxsICYmIGhpZ2hsaWdodHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHF1ZXJ5UmFuZ2UgPSBoaWdobGlnaHRzLm1hcCgoaCkgPT4gQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UoaC5yYW5nZSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcXVlcnlSYW5nZTogcXVlcnlSYW5nZSB8fCBbVXRpbHMuZ2V0V29yZEF0UG9zaXRpb24oZWRpdG9yLCBwb2ludCldLFxyXG4gICAgICBkZWZpbml0aW9uczogRGVmaW5pdGlvbkFkYXB0ZXIuY29udmVydExvY2F0aW9uc1RvRGVmaW5pdGlvbnMoZGVmaW5pdGlvbkxvY2F0aW9ucywgbGFuZ3VhZ2VOYW1lKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IE5vcm1hbGl6ZSB0aGUgbG9jYXRpb25zIHNvIGEgc2luZ2xlIHtMb2NhdGlvbn0gYmVjb21lcyBhbiB7QXJyYXl9IG9mIGp1c3RcclxuICAvLyBvbmUuIFRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgcmV0dXJuIGVpdGhlciBhcyB0aGUgcHJvdG9jb2wgZXZvbHZlZCBiZXR3ZWVuIHYxIGFuZCB2Mi5cclxuICAvL1xyXG4gIC8vICogYGxvY2F0aW9uUmVzdWx0YCBlaXRoZXIgYSBzaW5nbGUge0xvY2F0aW9ufSBvYmplY3Qgb3IgYW4ge0FycmF5fSBvZiB7TG9jYXRpb25zfVxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhbiB7QXJyYXl9IG9mIHtMb2NhdGlvbn1zIG9yIHtudWxsfSBpZiB0aGUgbG9jYXRpb25SZXN1bHQgd2FzIG51bGwuXHJcbiAgcHVibGljIHN0YXRpYyBub3JtYWxpemVMb2NhdGlvbnMobG9jYXRpb25SZXN1bHQ6IExvY2F0aW9uIHwgTG9jYXRpb25bXSk6IExvY2F0aW9uW10gfCBudWxsIHtcclxuICAgIGlmIChsb2NhdGlvblJlc3VsdCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KGxvY2F0aW9uUmVzdWx0KSA/IGxvY2F0aW9uUmVzdWx0IDogW2xvY2F0aW9uUmVzdWx0XSkuZmlsdGVyKChkKSA9PiBkLnJhbmdlLnN0YXJ0ICE9IG51bGwpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGFuIHtBcnJheX0gb2Yge0xvY2F0aW9ufSBvYmplY3RzIGludG8gYW4gQXJyYXkgb2Yge0RlZmluaXRpb259cy5cclxuICAvL1xyXG4gIC8vICogYGxvY2F0aW9uc2AgQW4ge0FycmF5fSBvZiB7TG9jYXRpb259IG9iamVjdHMgdG8gYmUgY29udmVydGVkLlxyXG4gIC8vICogYGxhbmd1YWdlTmFtZWAgVGhlIG5hbWUgb2YgdGhlIGxhbmd1YWdlIHRoZXNlIG9iamVjdHMgYXJlIHdyaXR0ZW4gaW4uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGFuIHtBcnJheX0gb2Yge0RlZmluaXRpb259cyB0aGF0IHJlcHJlc2VudGVkIHRoZSBjb252ZXJ0ZWQge0xvY2F0aW9ufXMuXHJcbiAgcHVibGljIHN0YXRpYyBjb252ZXJ0TG9jYXRpb25zVG9EZWZpbml0aW9ucyhsb2NhdGlvbnM6IExvY2F0aW9uW10sIGxhbmd1YWdlTmFtZTogc3RyaW5nKTogYXRvbUlkZS5EZWZpbml0aW9uW10ge1xyXG4gICAgcmV0dXJuIGxvY2F0aW9ucy5tYXAoKGQpID0+ICh7XHJcbiAgICAgIHBhdGg6IENvbnZlcnQudXJpVG9QYXRoKGQudXJpKSxcclxuICAgICAgcG9zaXRpb246IENvbnZlcnQucG9zaXRpb25Ub1BvaW50KGQucmFuZ2Uuc3RhcnQpLFxyXG4gICAgICByYW5nZTogUmFuZ2UuZnJvbU9iamVjdChDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShkLnJhbmdlKSksXHJcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZU5hbWUsXHJcbiAgICB9KSk7XHJcbiAgfVxyXG59XHJcbiJdfQ==
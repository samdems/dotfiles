'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var path = require('path');
var temp = require('temp');
var gitParser = require('./git-parser');
var winston = require('winston');
var usageStatistics = require('./usage-statistics');
var os = require('os');
var mkdirp = require('mkdirp');
var rimraf = require('rimraf');
var _ = require('lodash');
var gitPromise = require('./git-promise');
var fs = require('./utils/fs-async');
var ignore = require('ignore');
var Bluebird = require('bluebird');
var crypto = require('crypto');

var isMac = /^darwin/.test(process.platform);
var isWindows = /^win/.test(process.platform);
var tenMinTimeoutMs = 10 * 60 * 1000;

exports.pathPrefix = '';

exports.registerApi = function (env) {
  var app = env.app;
  var server = env.server;
  var ensureAuthenticated = env.ensureAuthenticated || function (req, res, next) {
    return next();
  };
  var config = env.config;
  var io = env.socketIO;
  var socketsById = env.socketsById || {};

  if (config.dev) temp.track();

  if (io) {
    io.sockets.on('connection', function (socket) {
      socket.on('disconnect', function () {
        stopDirectoryWatch(socket);
      });
      socket.on('watch', function (data, callback) {
        stopDirectoryWatch(socket); // clean possibly lingering connections
        socket.watcherPath = path.normalize(data.path);
        socket.join(socket.watcherPath); // join room for this path

        fs.readFileAsync(path.join(socket.watcherPath, ".gitignore")).then(function (ignoreContent) {
          return socket.ignore = ignore().add(ignoreContent.toString());
        }).catch(function () {}).then(function () {
          socket.watcher = [];
          return watchPath(socket, '.', { 'recursive': true });
        }).then(function () {
          if (!isMac && !isWindows) {
            // recursive fs.watch only works on mac and windows
            var promises = [];
            promises.push(watchPath(socket, path.join('.git', 'HEAD')));
            promises.push(watchPath(socket, path.join('.git', 'refs', 'heads')));
            promises.push(watchPath(socket, path.join('.git', 'refs', 'remotes')));
            promises.push(watchPath(socket, path.join('.git', 'refs', 'tags')));
            return Bluebird.all(promises);
          }
        }).catch(function (err) {
          // Sometimes fs.watch crashes with errors such as ENOSPC (no space available)
          // which is pretty weird, but hard to do anything about, so we just log them here.
          usageStatistics.addEvent('fs-watch-exception');
          return null;
        }).finally(callback);
      });
    });
  }

  var watchPath = function watchPath(socket, subfolderPath, options) {
    var pathToWatch = path.join(socket.watcherPath, subfolderPath);
    winston.info('Start watching ' + pathToWatch);
    return fs.isExists(pathToWatch).then(function (isExists) {
      // Sometimes necessary folders, '.../.git/refs/heads' and etc, are not created on git init
      if (!isExists) {
        winston.debug('intended folder to watch doesn\'t exists, creating: ' + pathToWatch);
        return new Bluebird(function (resolve, reject) {
          mkdirp(pathToWatch, function (err) {
            if (err) reject(err);else resolve();
          });
        });
      }
    }).then(function () {
      socket.watcher.push(fs.watch(pathToWatch, options || {}, function (event, filename) {
        if (!filename) return;
        var filePath = path.join(subfolderPath, filename);
        winston.debug('File change: ' + filePath);
        if (isFileWatched(filePath, socket.ignore)) {
          winston.info(filePath + ' triggered refresh for ' + socket.watcherPath);
          emitGitDirectoryChanged(socket.watcherPath);
          emitWorkingTreeChanged(socket.watcherPath);
        }
      }));
    });
  };

  var stopDirectoryWatch = function stopDirectoryWatch(socket) {
    socket.leave(socket.watcherPath);
    socket.ignore = undefined;
    (socket.watcher || []).forEach(function (watcher) {
      return watcher.close();
    });
    winston.info('Stop watching ' + socket.watcherPath);
  };

  // The .git dir changes on for instance 'git status', so we
  // can't trigger a change here (since that would lead to an endless
  // loop of the client getting the change and then requesting the new data)
  var isFileWatched = function isFileWatched(filename, ignore) {
    if (ignore && ignore.filter(filename).length == 0) {
      return false; // ignore files that are in .gitignore
    } else if (filename.endsWith(".lock")) {
      return false;
    } else if (filename.indexOf(path.join(".git", "refs")) > -1) {
      return true; // trigger for all changes under refs
    } else if (filename == path.join(".git", "HEAD")) {
      return true; // Explicitly return true for ".git/HEAD" for branch changes
    } else if (filename.indexOf(".git") > -1) {
      return false; // Ignore other changes under ".git/*"
    } else {
      return true;
    }
  };

  var ensurePathExists = function ensurePathExists(req, res, next) {
    fs.isExists(req.query.path || req.body.path).then(function (isExists) {
      if (isExists) {
        next();
      } else {
        res.status(400).json({ error: '\'No such path: ' + path, errorCode: 'no-such-path' });
      }
    });
  };

  var ensureValidSocketId = function ensureValidSocketId(req, res, next) {
    var socketId = req.query.socketId || req.body.socketId;
    if (socketId == 'ignore') return next(); // Used in unit tests
    var socket = socketsById[socketId];
    if (!socket) {
      res.status(400).json({ error: 'No such socket: ' + socketId, errorCode: 'invalid-socket-id' });
    } else {
      next();
    }
  };

  var emitWorkingTreeChanged = _.debounce(function (repoPath) {
    if (io) {
      io.sockets.in(path.normalize(repoPath)).emit('working-tree-changed', { repository: repoPath });
      winston.info('emitting working-tree-changed to sockets, manually triggered');
    }
  }, 500, { 'maxWait': 2000 });
  var emitGitDirectoryChanged = _.debounce(function (repoPath) {
    if (io) {
      io.sockets.in(path.normalize(repoPath)).emit('git-directory-changed', { repository: repoPath });
      winston.info('emitting git-directory-changed to sockets, manually triggered');
    }
  }, 500, { 'maxWait': 2000 });

  var autoStashExecuteAndPop = function autoStashExecuteAndPop(commands, repoPath, allowedCodes, outPipe, inPipe, timeout) {
    if (config.autoStashAndPop) {
      return gitPromise.stashExecuteAndPop(commands, repoPath, allowedCodes, outPipe, inPipe, timeout);
    } else {
      return gitPromise(commands, repoPath, allowedCodes, outPipe, inPipe, timeout);
    }
  };

  var jsonResultOrFailProm = function jsonResultOrFailProm(res, promise) {
    return promise.then(function (result) {
      res.json(result || {});
    }).catch(function (err) {
      winston.warn('Responding with ERROR: ', JSON.stringify(err));
      res.status(400).json(err);
    });
  };

  var credentialsOption = function credentialsOption(socketId, remote) {
    var portAndRootPath = '' + config.port;
    if (config.rootPath) {
      portAndRootPath = '' + config.port + config.rootPath;
    }
    var credentialsHelperPath = path.resolve(__dirname, '..', 'bin', 'credentials-helper').replace(/\\/g, '/');
    return ['-c', 'credential.helper=' + credentialsHelperPath + ' ' + socketId + ' ' + portAndRootPath + ' ' + remote];
  };

  var getNumber = function getNumber(value, nullValue) {
    var finalValue = parseInt(value ? value : nullValue);
    if (finalValue || finalValue === 0) {
      return finalValue;
    } else {
      throw { error: "invalid number" };
    }
  };

  app.get(exports.pathPrefix + '/status', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise.status(req.query.path, null));
  });

  app.post(exports.pathPrefix + '/init', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(req.body.bare ? ['init', '--bare', '--shared'] : ['init'], req.body.path));
  });

  app.post(exports.pathPrefix + '/clone', ensureAuthenticated, ensurePathExists, ensureValidSocketId, function (req, res) {
    // Default timeout is 2min but clone can take much longer than that (allows up to 2h)
    var timeoutMs = 2 * 60 * 60 * 1000;
    if (res.setTimeout) res.setTimeout(timeoutMs);

    var url = req.body.url.trim();
    if (url.indexOf('git clone ') == 0) url = url.slice('git clone '.length);

    var commands = ['clone', url, req.body.destinationDir.trim()];
    if (req.body.isRecursiveSubmodule) {
      commands.push('--recurse-submodules');
    }

    var task = gitPromise({
      commands: credentialsOption(req.body.socketId, url).concat(commands),
      repoPath: req.body.path,
      timeout: timeoutMs
    }).then(function () {
      return { path: path.resolve(req.body.path, req.body.destinationDir) };
    });

    jsonResultOrFailProm(res, task).finally(emitGitDirectoryChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/fetch', ensureAuthenticated, ensurePathExists, ensureValidSocketId, function (req, res) {
    // Allow a little longer timeout on fetch (10min)
    if (res.setTimeout) res.setTimeout(tenMinTimeoutMs);

    var task = gitPromise({
      commands: credentialsOption(req.body.socketId, req.body.remote).concat(['fetch', req.body.remote, req.body.ref ? req.body.ref : '', config.autoPruneOnFetch ? '--prune' : '']),
      repoPath: req.body.path,
      timeout: tenMinTimeoutMs
    });

    jsonResultOrFailProm(res, task).finally(emitGitDirectoryChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/push', ensureAuthenticated, ensurePathExists, ensureValidSocketId, function (req, res) {
    // Allow a little longer timeout on push (10min)
    if (res.setTimeout) res.setTimeout(tenMinTimeoutMs);
    var task = gitPromise({
      commands: credentialsOption(req.body.socketId, req.body.remote).concat(['push', req.body.remote, (req.body.refSpec ? req.body.refSpec : 'HEAD') + (req.body.remoteBranch ? ':' + req.body.remoteBranch : ''), req.body.force ? '-f' : '']),
      repoPath: req.body.path,
      timeout: tenMinTimeoutMs
    });

    jsonResultOrFailProm(res, task).finally(emitGitDirectoryChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/reset', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, autoStashExecuteAndPop(['reset', '--' + req.body.mode, req.body.to], req.body.path)).then(emitGitDirectoryChanged.bind(null, req.body.path)).then(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.get(exports.pathPrefix + '/diff', ensureAuthenticated, ensurePathExists, function (req, res) {
    var isIgnoreWhiteSpace = req.query.whiteSpace === "true" ? true : false;
    jsonResultOrFailProm(res, gitPromise.diffFile(req.query.path, req.query.file, req.query.sha1, isIgnoreWhiteSpace));
  });

  app.get(exports.pathPrefix + '/diff/image', ensureAuthenticated, ensurePathExists, function (req, res) {
    res.type(path.extname(req.query.filename));
    if (req.query.version !== 'current') {
      gitPromise.binaryFileContent(req.query.path, req.query.filename, req.query.version, res);
    } else {
      res.sendFile(path.join(req.query.path, req.query.filename));
    }
  });

  app.post(exports.pathPrefix + '/discardchanges', ensureAuthenticated, ensurePathExists, function (req, res) {
    var task = req.body.all ? gitPromise.discardAllChanges(req.body.path) : gitPromise.discardChangesInFile(req.body.path, req.body.file.trim());
    jsonResultOrFailProm(res, task.then(emitWorkingTreeChanged.bind(null, req.body.path)));
  });

  app.post(exports.pathPrefix + '/ignorefile', ensureAuthenticated, ensurePathExists, function (req, res) {
    var currentPath = req.body.path.trim();
    var gitIgnoreFile = currentPath + '/.gitignore';
    var ignoreFile = req.body.file.trim();
    var task = fs.appendFileAsync(gitIgnoreFile, os.EOL + ignoreFile).catch(function (err) {
      throw { errorCode: 'error-appending-ignore', error: 'Error while appending to .gitignore file.' };
    });

    jsonResultOrFailProm(res, task).finally(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/commit', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise.commit(req.body.path, req.body.amend, req.body.emptyCommit, req.body.message, req.body.files)).then(emitGitDirectoryChanged.bind(null, req.body.path)).then(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/revert', ensureAuthenticated, ensurePathExists, function (req, res) {
    var task = gitPromise(['revert', req.body.commit], req.body.path).catch(function (e) {
      if (e.message.indexOf("is a merge but no -m option was given.") > 0) {
        return gitPromise(['revert', '-m', 1, req.body.commit], req.body.path);
      } else {
        throw e;
      }
    });
    jsonResultOrFailProm(res, task).finally(emitGitDirectoryChanged.bind(null, req.body.path)).finally(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.get(exports.pathPrefix + '/gitlog', ensureAuthenticated, ensurePathExists, function (req, res) {
    var limit = getNumber(req.query.limit, config.numberOfNodesPerLoad || 25);
    var skip = getNumber(req.query.skip, 0);
    var task = gitPromise.log(req.query.path, limit, skip, 100).catch(function (err) {
      if (err.stderr && err.stderr.indexOf('fatal: bad default revision \'HEAD\'') == 0) {
        return { "limit": limit, "skip": skip, "nodes": [] };
      } else if (/fatal: your current branch \'.+\' does not have any commits yet.*/.test(err.stderr)) {
        return { "limit": limit, "skip": skip, "nodes": [] };
      } else if (err.stderr && err.stderr.indexOf('fatal: Not a git repository') == 0) {
        return { "limit": limit, "skip": skip, "nodes": [] };
      } else {
        throw err;
      }
    });
    jsonResultOrFailProm(res, task);
  });

  app.get(exports.pathPrefix + '/show', ensureAuthenticated, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['show', '--numstat', req.query.sha1], req.query.path).then(gitParser.parseGitLog));
  });

  app.get(exports.pathPrefix + '/head', ensureAuthenticated, ensurePathExists, function (req, res) {
    var task = gitPromise(['log', '--decorate=full', '--pretty=fuller', '--parents', '--max-count=1'], req.query.path).then(gitParser.parseGitLog).catch(function (err) {
      if (err.stderr.indexOf('fatal: bad default revision \'HEAD\'') == 0) return [];else if (/fatal: your current branch \'.+\' does not have any commits yet.*/.test(err.stderr)) return [];else if (err.stderr.indexOf('fatal: Not a git repository') == 0) return [];
      throw err;
    });
    jsonResultOrFailProm(res, task);
  });

  app.get(exports.pathPrefix + '/refs', ensureAuthenticated, ensurePathExists, function (req, res) {
    if (res.setTimeout) res.setTimeout(tenMinTimeoutMs);

    var task = gitPromise(['remote'], req.query.path).then(function (remoteText) {
      var remotes = remoteText.trim().split('\n');

      // making calls serially as credential helpers may get confused to which cred to get.
      return Bluebird.each(remotes, function (remote) {
        if (!remote || remote === '') return;
        return gitPromise({
          commands: credentialsOption(req.query.socketId, remote).concat(['fetch', remote]),
          repoPath: req.query.path,
          timeout: tenMinTimeoutMs
        }).catch(function (e) {
          return winston.warn("err during remote fetch for /refs", e);
        }); // ignore fetch err as it is most likely credential
      });
    }).then(function () {
      return gitPromise(['show-ref', '-d'], req.query.path);
    })
    // On new fresh repos, empty string is returned but has status code of error, simply ignoring them
    .catch(function (e) {
      if (e.message !== '') throw e;
    }).then(function (refs) {
      var results = [];
      if (refs) {
        refs.trim().split('\n').forEach(function (n) {
          var splitted = n.split(' ');
          var sha1 = splitted[0];
          var name = splitted[1];
          if (name.indexOf('refs/tags') > -1 && name.indexOf('^{}') > -1) {
            results[results.length - 1].sha1 = sha1;
          } else {
            results.push({
              name: name,
              sha1: sha1
            });
          }
        });
      }
      return results;
    });
    jsonResultOrFailProm(res, task);
  });

  app.get(exports.pathPrefix + '/branches', ensureAuthenticated, ensurePathExists, function (req, res) {
    var isLocalBranchOnly = req.query.isLocalBranchOnly == 'false';
    jsonResultOrFailProm(res, gitPromise(['branch', isLocalBranchOnly ? '-a' : ''], req.query.path).then(gitParser.parseGitBranches));
  });

  app.post(exports.pathPrefix + '/branches', ensureAuthenticated, ensurePathExists, function (req, res) {
    var commands = ['branch', req.body.force ? '-f' : '', req.body.name.trim(), (req.body.sha1 || 'HEAD').trim()];

    jsonResultOrFailProm(res, gitPromise(commands, req.body.path)).finally(emitGitDirectoryChanged.bind(null, req.body.path));
  });

  app.delete(exports.pathPrefix + '/branches', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['branch', '-D', req.query.name.trim()], req.query.path)).finally(emitGitDirectoryChanged.bind(null, req.query.path));
  });

  app.delete(exports.pathPrefix + '/remote/branches', ensureAuthenticated, ensurePathExists, ensureValidSocketId, function (req, res) {
    var commands = credentialsOption(req.query.socketId, req.query.remote).concat(['push', req.query.remote, ':' + req.query.name.trim()]);
    var task = gitPromise(commands, req.query.path).catch(function (err) {
      if (!(err.stderr && err.stderr.indexOf("remote ref does not exist") > -1)) {
        throw err;
      }
    });

    jsonResultOrFailProm(res, task).finally(emitGitDirectoryChanged.bind(null, req.query.path));
  });

  app.get(exports.pathPrefix + '/tags', ensureAuthenticated, ensurePathExists, function (req, res) {
    var task = gitPromise(['tag', '-l'], req.query.path).then(gitParser.parseGitTags);
    jsonResultOrFailProm(res, task);
  });

  app.get(exports.pathPrefix + '/remote/tags', ensureAuthenticated, ensurePathExists, ensureValidSocketId, function (req, res) {
    var task = gitPromise(credentialsOption(req.query.socketId, req.query.remote).concat(['ls-remote', '--tags', req.query.remote]), req.query.path).then(gitParser.parseGitLsRemote).then(function (result) {
      result.forEach(function (r) {
        r.remote = req.query.remote;
      });
      return result;
    });
    jsonResultOrFailProm(res, task);
  });

  app.post(exports.pathPrefix + '/tags', ensureAuthenticated, ensurePathExists, function (req, res) {
    var annotateFlag = config.isForceGPGSign ? '-s' : '-a';
    var forceFlag = req.body.force ? '-f' : '';
    var sha1 = (req.body.sha1 || 'HEAD').trim();
    var commands = ['tag', forceFlag, annotateFlag, req.body.name.trim(), '-m', req.body.name.trim(), sha1];

    jsonResultOrFailProm(res, gitPromise(commands, req.body.path)).finally(emitGitDirectoryChanged.bind(null, req.body.path));
  });

  app.delete(exports.pathPrefix + '/tags', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['tag', '-d', req.query.name.trim()], req.query.path)).finally(emitGitDirectoryChanged.bind(null, req.query.path));
  });

  app.delete(exports.pathPrefix + '/remote/tags', ensureAuthenticated, ensurePathExists, function (req, res) {
    var commands = credentialsOption(req.query.socketId, req.query.remote).concat(['push', req.query.remote, ':refs/tags/' + req.query.name.trim()]);
    var task = gitPromise(['tag', '-d', req.query.name.trim()], req.query.path).catch(function () {}) // might have already deleted, so ignoring error
    .then(function () {
      return gitPromise(commands, req.query.path);
    });

    jsonResultOrFailProm(res, task).finally(emitGitDirectoryChanged.bind(null, req.query.path));
  });

  app.post(exports.pathPrefix + '/checkout', ensureAuthenticated, ensurePathExists, function (req, res) {
    var arg = !!req.body.sha1 ? ['checkout', '-b', req.body.name.trim(), req.body.sha1] : ['checkout', req.body.name.trim()];

    jsonResultOrFailProm(res, autoStashExecuteAndPop(arg, req.body.path)).then(emitGitDirectoryChanged.bind(null, req.body.path)).then(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/cherrypick', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, autoStashExecuteAndPop(['cherry-pick', req.body.name.trim()], req.body.path)).then(emitGitDirectoryChanged.bind(null, req.body.path)).then(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.get(exports.pathPrefix + '/checkout', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise.getCurrentBranch(req.query.path));
  });

  app.get(exports.pathPrefix + '/remotes', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['remote'], req.query.path).then(gitParser.parseGitRemotes));
  });

  app.get(exports.pathPrefix + '/remotes/:name', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise.getRemoteAddress(req.query.path, req.params.name));
  });

  app.post(exports.pathPrefix + '/remotes/:name', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['remote', 'add', req.params.name, req.body.url], req.body.path));
  });

  app.delete(exports.pathPrefix + '/remotes/:name', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['remote', 'remove', req.params.name], req.query.path));
  });

  app.post(exports.pathPrefix + '/merge', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['merge', config.noFFMerge ? '--no-ff' : '', req.body.with.trim()], req.body.path)).finally(emitGitDirectoryChanged.bind(null, req.body.path)).finally(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/merge/continue', ensureAuthenticated, ensurePathExists, function (req, res) {
    var args = {
      commands: ['commit', '--file=-'],
      repoPath: req.body.path,
      inPipe: req.body.message
    };

    jsonResultOrFailProm(res, gitPromise(args)).finally(emitGitDirectoryChanged.bind(null, req.body.path)).finally(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/merge/abort', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['merge', '--abort'], req.body.path)).finally(emitGitDirectoryChanged.bind(null, req.body.path)).finally(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/squash', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['merge', '--squash', req.body.target.trim()], req.body.path)).finally(emitGitDirectoryChanged.bind(null, req.body.path)).finally(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/rebase', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['rebase', req.body.onto.trim()], req.body.path)).finally(emitGitDirectoryChanged.bind(null, req.body.path)).finally(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/rebase/continue', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['rebase', '--continue'], req.body.path)).finally(emitGitDirectoryChanged.bind(null, req.body.path)).finally(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/rebase/abort', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['rebase', '--abort'], req.body.path)).finally(emitGitDirectoryChanged.bind(null, req.body.path)).finally(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/resolveconflicts', ensureAuthenticated, ensurePathExists, function (req, res) {
    winston.info('resolve conflicts');
    jsonResultOrFailProm(res, gitPromise.resolveConflicts(req.body.path, req.body.files)).then(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.post(exports.pathPrefix + '/launchmergetool', ensureAuthenticated, ensurePathExists, function (req, res) {
    var commands = ['mergetool'].concat(_toConsumableArray(typeof req.body.tool === 'string' ? ['--tool ', req.body.tool] : []), ['--no-prompt', req.body.file]);
    gitPromise(commands, req.body.path);
    // Send immediate response, this is because merging may take a long time
    // and there is no need to wait for it to finish.
    res.json({});
  });

  app.get(exports.pathPrefix + '/baserepopath', ensureAuthenticated, ensurePathExists, function (req, res) {
    var currentPath = path.resolve(path.join(req.query.path, '..'));
    jsonResultOrFailProm(res, gitPromise(['rev-parse', '--show-toplevel'], currentPath).then(function (baseRepoPath) {
      return { path: path.resolve(baseRepoPath.trim()) };
    }).catch(function (e) {
      if (e.errorCode === 'not-a-repository') {
        return {};
      }
      throw e;
    }));
  });

  app.get(exports.pathPrefix + '/submodules', ensureAuthenticated, ensurePathExists, function (req, res) {
    var filename = path.join(req.query.path, '.gitmodules');

    var task = fs.isExists(filename).then(function (exists) {
      if (exists) {
        return fs.readFileAsync(filename, { encoding: 'utf8' }).catch(function () {
          return {};
        }).then(gitParser.parseGitSubmodule);
      } else {
        return {};
      }
    });
    jsonResultOrFailProm(res, task);
  });

  app.post(exports.pathPrefix + '/submodules/update', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['submodule', 'init'], req.body.path).then(gitPromise.bind(null, ['submodule', 'update'], req.body.path)));
  });

  app.post(exports.pathPrefix + '/submodules/add', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['submodule', 'add', req.body.submoduleUrl.trim(), req.body.submodulePath.trim()], req.body.path)).finally(emitGitDirectoryChanged.bind(null, req.body.path)).finally(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.delete(exports.pathPrefix + '/submodules', ensureAuthenticated, ensurePathExists, function (req, res) {
    // -f is needed for the cases when added submodule change is not in the staging or committed
    var task = gitPromise(['submodule', 'deinit', "-f", req.query.submoduleName], req.query.path).then(gitPromise.bind(null, ['rm', '-f', req.query.submoduleName], req.query.path)).then(function () {
      rimraf.sync(path.join(req.query.path, req.query.submodulePath));
      rimraf.sync(path.join(req.query.path, '.git', 'modules', req.query.submodulePath));
    });

    jsonResultOrFailProm(res, task);
  });

  app.get(exports.pathPrefix + '/quickstatus', ensureAuthenticated, function (req, res) {
    var task = fs.isExists(req.query.path).then(function (exists) {
      return exists ? gitPromise.revParse(req.query.path) : { type: 'no-such-path', gitRootPath: req.query.path };
    });
    jsonResultOrFailProm(res, task);
  });

  app.get(exports.pathPrefix + '/stashes', ensureAuthenticated, ensurePathExists, function (req, res) {
    var task = gitPromise(['stash', 'list', '--decorate=full', '--pretty=fuller', '--parents', '--numstat'], req.query.path).then(gitParser.parseGitLog);
    jsonResultOrFailProm(res, task);
  });

  app.post(exports.pathPrefix + '/stashes', ensureAuthenticated, ensurePathExists, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['stash', 'save', '--include-untracked', req.body.message || ''], req.body.path)).finally(emitGitDirectoryChanged.bind(null, req.body.path)).finally(emitWorkingTreeChanged.bind(null, req.body.path));
  });

  app.delete(exports.pathPrefix + '/stashes/:id', ensureAuthenticated, ensurePathExists, function (req, res) {
    var type = req.query.apply === 'true' ? 'apply' : 'drop';
    jsonResultOrFailProm(res, gitPromise(['stash', type, 'stash@{' + req.params.id + '}'], req.query.path)).finally(emitGitDirectoryChanged.bind(null, req.query.path)).finally(emitWorkingTreeChanged.bind(null, req.query.path));
  });

  app.get(exports.pathPrefix + '/gitconfig', ensureAuthenticated, function (req, res) {
    jsonResultOrFailProm(res, gitPromise(['config', '--list']).then(gitParser.parseGitConfig));
  });

  // This method isn't called by the client but by credentials-helper.js
  app.get(exports.pathPrefix + '/credentials', function (req, res) {
    // this endpoint can only be invoked from localhost, since the credentials-helper is always
    // on the same machine that we're running ungit on
    if (req.ip != '127.0.0.1' && req.ip != '::ffff:127.0.0.1') {
      winston.info('Trying to get credentials from unathorized ip: ' + req.ip);
      res.status(400).json({ errorCode: 'request-from-unathorized-location' });
      return;
    }
    var socket = socketsById[req.query.socketId];
    var remote = req.query.remote;
    if (!socket) {
      // We're using the socket to display an authentication dialog in the ui,
      // so if the socket is closed/unavailable we pretty much can't get the username/password.
      winston.info('Trying to get credentials from unavailable socket: ' + req.query.socketId);
      res.status(400).json({ errorCode: 'socket-unavailable' });
    } else {
      socket.once('credentials', function (data) {
        return res.json(data);
      });
      socket.emit('request-credentials', { remote: remote });
    }
  });

  app.post(exports.pathPrefix + '/createdir', ensureAuthenticated, function (req, res) {
    var dir = req.query.dir || req.body.dir;
    if (!dir) {
      return res.status(400).json({ errorCode: 'missing-request-parameter', error: 'You need to supply the path request parameter' });
    }

    mkdirp(dir, function (err) {
      if (err) return res.status(400).json(err);else return res.json({});
    });
  });

  app.get(exports.pathPrefix + '/gitignore', ensureAuthenticated, ensurePathExists, function (req, res) {
    fs.readFileAsync(path.join(req.query.path, ".gitignore")).then(function (ignoreContent) {
      return res.status(200).json({ content: ignoreContent.toString() });
    }).catch(function (e) {
      if (e && e.message && e.message.indexOf('no such file or directory') > -1) {
        res.status(200).json({ content: '' });
      } else {
        res.status(500).json(e);
      }
    });
  });
  app.put(exports.pathPrefix + '/gitignore', ensureAuthenticated, ensurePathExists, function (req, res) {
    if (!req.body.data || req.body.data == '') {
      return res.status(500).json({ message: "Invalid .gitignore content" });
    }
    fs.writeFileAsync(path.join(req.body.path, ".gitignore"), req.body.data).then(function () {
      return res.status(200).json({});
    }).finally(emitGitDirectoryChanged.bind(null, req.body.path)).catch(function (e) {
      return res.status(500).json(e);
    });
  });

  if (config.dev) {
    app.post(exports.pathPrefix + '/testing/createtempdir', ensureAuthenticated, function (req, res) {
      temp.mkdir('test-temp-dir', function (err, tempPath) {
        return res.json({ path: path.normalize(tempPath) });
      });
    });
    app.post(exports.pathPrefix + '/testing/createfile', ensureAuthenticated, function (req, res) {
      var content = req.body.content ? req.body.content : 'test content\n' + Math.random() + '\n';
      fs.writeFileSync(req.body.file, content);
      res.json({});
    });
    app.post(exports.pathPrefix + '/testing/changefile', ensureAuthenticated, function (req, res) {
      var content = req.body.content ? req.body.content : 'test content\n' + Math.random() + '\n';
      fs.writeFileSync(req.body.file, content);
      res.json({});
    });
    app.post(exports.pathPrefix + '/testing/createimagefile', ensureAuthenticated, function (req, res) {
      fs.writeFile(req.body.file, 'png', { encoding: 'binary' });
      res.json({});
    });
    app.post(exports.pathPrefix + '/testing/changeimagefile', ensureAuthenticated, function (req, res) {
      fs.writeFile(req.body.file, 'png ~~', { encoding: 'binary' });
      res.json({});
    });
    app.post(exports.pathPrefix + '/testing/removefile', ensureAuthenticated, function (req, res) {
      fs.unlinkSync(req.body.file);
      res.json({});
    });
    app.post(exports.pathPrefix + '/testing/git', ensureAuthenticated, function (req, res) {
      jsonResultOrFailProm(res, gitPromise(req.body.command, req.body.repo));
    });
    app.post(exports.pathPrefix + '/testing/cleanup', ensureAuthenticated, function (req, res) {
      //winston.info('Cleaned up: ' + JSON.stringify(cleaned));
      res.json({ result: temp.cleanup() });
    });
    app.post(exports.pathPrefix + '/testing/shutdown', ensureAuthenticated, function (req, res) {
      res.json({});
      process.exit();
    });
  }
};

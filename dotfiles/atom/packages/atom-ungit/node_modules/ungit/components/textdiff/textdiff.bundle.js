(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

var ko = require('knockout');
var components = require('ungit-components');
var diff2html = require('diff2html').Diff2Html;
var programEvents = require('ungit-program-events');
var Promise = require("bluebird");

components.register('textdiff', function (args) {
  return new TextDiffViewModel(args);
});

components.register('textdiff.type', function () {
  return new Type();
});

components.register('textdiff.wordwrap', function () {
  return new WordWrap();
});

components.register('textdiff.whitespace', function () {
  return new WhiteSpace();
});

var loadLimit = 100;

var WordWrap = function () {
  var self = this;

  this.text = ko.observable("No Wrap");
  this.value = ko.observable(false);
  this.value.subscribe(function (value) {
    self.text(value ? "Word Wrap" : "No Wrap");
  });
  this.toggle = function () {
    self.value(!self.value());
  }
  this.isActive = ko.computed(function () { return !!self.value(); });
}

var Type = function () {
  var self = this;
  var sideBySideDiff = 'sidebysidediff'
  var textDiff = 'textdiff'

  this.text = ko.observable("Default");

  if (!!ungit.config.diffType && ungit.config.diffType !== 'textdiff' && ungit.config.diffType !== 'sidebysidediff') {
    ungit.config.diffType = 'textdiff';
    console.log('Config "diffType" must be either "textdiff" or "sidebysidediff".');
  }

  this.value = ko.observable(ungit.config.diffType || textDiff);
  this.value.subscribe(function (value) {
    self.text(value === textDiff ? "Default" : "Side By Side");
    programEvents.dispatch({ event: 'invalidate-diff-and-render' });
  });
  this.toggle = function () {
    self.value(self.value() === textDiff ? sideBySideDiff : textDiff);
  }
  this.isActive = ko.computed(function () {
    return self.value() === 'textdiff';
  });
}

var WhiteSpace = function () {
  var self = this;

  this.text = ko.observable("Showing White Space diff");
  this.value = ko.observable(false);
  this.value.subscribe(function (value) {
    self.text(value ? "Ignoring White Space diff" : "Showing White Space diff");
    programEvents.dispatch({ event: 'invalidate-diff-and-render' });
  });
  this.toggle = function () {
    self.value(!self.value());
  }
  this.isActive = ko.computed(function () { return !self.value(); });
}

var TextDiffViewModel = function (args) {
  var self = this;
  this.filename = args.filename;
  this.repoPath = args.repoPath;
  this.server = args.server;
  this.sha1 = args.sha1;
  this.loadMoreCount = ko.observable(0);
  this.diffJson = null;
  this.loadCount = loadLimit;
  this.textDiffType = args.textDiffType;
  this.whiteSpace = args.whiteSpace;
  this.isShowingDiffs = args.isShowingDiffs;
  this.editState = args.editState;
  this.wordWrap = args.wordWrap;
  this.patchLineList = args.patchLineList;
  this.numberOfSelectedPatchLines = 0;
  this.htmlSrc = undefined;
  this.isParsed = ko.observable(false);

  programEvents.add(function (event) {
    if (event.event === "invalidate-diff-and-render" || event.event === "working-tree-changed") {
      self.invalidateDiff();
      if (self.isShowingDiffs()) self.render();
    }
  });

  this.isShowingDiffs.subscribe(function (newValue) {
    if (newValue) self.render();
  });

  if (this.isShowingDiffs()) { this.render(); }
}
TextDiffViewModel.prototype.updateNode = function (parentElement) {
  ko.renderTemplate('textdiff', this, {}, parentElement);
}
TextDiffViewModel.prototype.getDiffArguments = function () {
  return {
    file: this.filename,
    path: this.repoPath(),
    sha1: this.sha1 ? this.sha1 : '',
    whiteSpace: this.whiteSpace.value()
  };
}

TextDiffViewModel.prototype.invalidateDiff = function () {
  this.diffJson = null;
}

TextDiffViewModel.prototype.getDiffJson = function () {
  var self = this;
  return self.server.getPromise('/diff', self.getDiffArguments()).then(function (diffs) {
    if (typeof diffs !== 'string') {
      // Invalid value means there is no changes, show dummy diff withotu any changes
      diffs = `diff --git a/${this.filename} b/${this.filename}
                index aaaaaaaa..bbbbbbbb 111111
                --- a/${this.filename}
                +++ b/${this.filename}`;
    }
    self.diffJson = diff2html.getJsonFromDiff(diffs);
  }).catch(function (err) {
    // The file existed before but has been removed, but we're trying to get a diff for it
    // Most likely it will just disappear with the next refresh of the staging area
    // so we just ignore the error here
    if (err.errorCode != 'no-such-file') self.server.unhandledRejection(err);
  });
}

TextDiffViewModel.prototype.render = function (isInvalidate) {
  var self = this;
  return Promise.resolve().then(function () {
    if (!self.diffJson || isInvalidate) {
      return self.getDiffJson();
    }
  }).then(function () {
    if (!self.diffJson || self.diffJson.length == 0) return; // check if diffs are available (binary files do not support them)
    var lineCount = 0;

    if (!self.diffJson[0].isTrimmed) {
      self.diffJson[0].blocks = self.diffJson[0].blocks.reduce(function (blocks, block) {
        var length = block.lines.length;
        if (lineCount < self.loadCount) {
          block.lines = block.lines.slice(0, self.loadCount - lineCount);
          blocks.push(block);
        }
        lineCount += length;
        return blocks;
      }, []);
    }
    self.diffJson[0].isTrimmed = true;

    self.loadMoreCount(Math.min(loadLimit, Math.max(0, lineCount - self.loadCount)));

    var html;

    if (self.textDiffType.value() === 'sidebysidediff') {
      html = diff2html.getPrettySideBySideHtmlFromJson(self.diffJson);
    } else {
      html = diff2html.getPrettyHtmlFromJson(self.diffJson);
    }

    self.numberOfSelectedPatchLines = 0;
    var index = 0;

    // ko's binding resolution is not recursive, which means below ko.bind refresh method doesn't work for
    // data bind at getPatchCheckBox that is rendered with "html" binding.
    // which is reason why manually updating the html content and refreshing kobinding to have it render...
    if (self.patchLineList) {
      html = html.replace(/<span class="d2h-code-line-[a-z]+">(\+|\-)/g, function (match, capture) {
        if (self.patchLineList()[index] === undefined) {
          self.patchLineList()[index] = true;
        }

        return self.getPatchCheckBox(capture, index, self.patchLineList()[index++]);
      });
    }

    if (html !== self.htmlSrc) {
      // diff has changed since last we displayed and need refresh
      self.htmlSrc = html;
      self.isParsed(false);
      self.isParsed(true);
    }
  });
};

TextDiffViewModel.prototype.loadMore = function () {
  this.loadCount += this.loadMoreCount();
  programEvents.dispatch({ event: 'invalidate-diff-and-render' });
}

TextDiffViewModel.prototype.getPatchCheckBox = function (symbol, index, isActive) {
  if (isActive) {
    this.numberOfSelectedPatchLines++;
  }
  return '<div class="d2h-code-line-prefix"><span data-bind="visible: editState() !== \'patched\'">' + symbol + '</span><input ' + (isActive ? 'checked' : '') + ' type="checkbox" data-bind="visible: editState() === \'patched\', click: togglePatchLine.bind($data, ' + index + ')"></input>';
}

TextDiffViewModel.prototype.togglePatchLine = function (index) {
  this.patchLineList()[index] = !this.patchLineList()[index];

  if (this.patchLineList()[index]) {
    this.numberOfSelectedPatchLines++;
  } else {
    this.numberOfSelectedPatchLines--;
  }

  if (this.numberOfSelectedPatchLines === 0) {
    this.editState('none');
  }

  return true;
}

},{"bluebird":undefined,"diff2html":undefined,"knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3RleHRkaWZmL3RleHRkaWZmLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbnZhciBkaWZmMmh0bWwgPSByZXF1aXJlKCdkaWZmMmh0bWwnKS5EaWZmMkh0bWw7XG52YXIgcHJvZ3JhbUV2ZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LXByb2dyYW0tZXZlbnRzJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoXCJibHVlYmlyZFwiKTtcblxuY29tcG9uZW50cy5yZWdpc3RlcigndGV4dGRpZmYnLCBmdW5jdGlvbiAoYXJncykge1xuICByZXR1cm4gbmV3IFRleHREaWZmVmlld01vZGVsKGFyZ3MpO1xufSk7XG5cbmNvbXBvbmVudHMucmVnaXN0ZXIoJ3RleHRkaWZmLnR5cGUnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgVHlwZSgpO1xufSk7XG5cbmNvbXBvbmVudHMucmVnaXN0ZXIoJ3RleHRkaWZmLndvcmR3cmFwJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFdvcmRXcmFwKCk7XG59KTtcblxuY29tcG9uZW50cy5yZWdpc3RlcigndGV4dGRpZmYud2hpdGVzcGFjZScsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBXaGl0ZVNwYWNlKCk7XG59KTtcblxudmFyIGxvYWRMaW1pdCA9IDEwMDtcblxudmFyIFdvcmRXcmFwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy50ZXh0ID0ga28ub2JzZXJ2YWJsZShcIk5vIFdyYXBcIik7XG4gIHRoaXMudmFsdWUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy52YWx1ZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgc2VsZi50ZXh0KHZhbHVlID8gXCJXb3JkIFdyYXBcIiA6IFwiTm8gV3JhcFwiKTtcbiAgfSk7XG4gIHRoaXMudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYudmFsdWUoIXNlbGYudmFsdWUoKSk7XG4gIH1cbiAgdGhpcy5pc0FjdGl2ZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhc2VsZi52YWx1ZSgpOyB9KTtcbn1cblxudmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNpZGVCeVNpZGVEaWZmID0gJ3NpZGVieXNpZGVkaWZmJ1xuICB2YXIgdGV4dERpZmYgPSAndGV4dGRpZmYnXG5cbiAgdGhpcy50ZXh0ID0ga28ub2JzZXJ2YWJsZShcIkRlZmF1bHRcIik7XG5cbiAgaWYgKCEhdW5naXQuY29uZmlnLmRpZmZUeXBlICYmIHVuZ2l0LmNvbmZpZy5kaWZmVHlwZSAhPT0gJ3RleHRkaWZmJyAmJiB1bmdpdC5jb25maWcuZGlmZlR5cGUgIT09ICdzaWRlYnlzaWRlZGlmZicpIHtcbiAgICB1bmdpdC5jb25maWcuZGlmZlR5cGUgPSAndGV4dGRpZmYnO1xuICAgIGNvbnNvbGUubG9nKCdDb25maWcgXCJkaWZmVHlwZVwiIG11c3QgYmUgZWl0aGVyIFwidGV4dGRpZmZcIiBvciBcInNpZGVieXNpZGVkaWZmXCIuJyk7XG4gIH1cblxuICB0aGlzLnZhbHVlID0ga28ub2JzZXJ2YWJsZSh1bmdpdC5jb25maWcuZGlmZlR5cGUgfHwgdGV4dERpZmYpO1xuICB0aGlzLnZhbHVlLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBzZWxmLnRleHQodmFsdWUgPT09IHRleHREaWZmID8gXCJEZWZhdWx0XCIgOiBcIlNpZGUgQnkgU2lkZVwiKTtcbiAgICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdpbnZhbGlkYXRlLWRpZmYtYW5kLXJlbmRlcicgfSk7XG4gIH0pO1xuICB0aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnZhbHVlKHNlbGYudmFsdWUoKSA9PT0gdGV4dERpZmYgPyBzaWRlQnlTaWRlRGlmZiA6IHRleHREaWZmKTtcbiAgfVxuICB0aGlzLmlzQWN0aXZlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZWxmLnZhbHVlKCkgPT09ICd0ZXh0ZGlmZic7XG4gIH0pO1xufVxuXG52YXIgV2hpdGVTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMudGV4dCA9IGtvLm9ic2VydmFibGUoXCJTaG93aW5nIFdoaXRlIFNwYWNlIGRpZmZcIik7XG4gIHRoaXMudmFsdWUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy52YWx1ZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgc2VsZi50ZXh0KHZhbHVlID8gXCJJZ25vcmluZyBXaGl0ZSBTcGFjZSBkaWZmXCIgOiBcIlNob3dpbmcgV2hpdGUgU3BhY2UgZGlmZlwiKTtcbiAgICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdpbnZhbGlkYXRlLWRpZmYtYW5kLXJlbmRlcicgfSk7XG4gIH0pO1xuICB0aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnZhbHVlKCFzZWxmLnZhbHVlKCkpO1xuICB9XG4gIHRoaXMuaXNBY3RpdmUgPSBrby5jb21wdXRlZChmdW5jdGlvbiAoKSB7IHJldHVybiAhc2VsZi52YWx1ZSgpOyB9KTtcbn1cblxudmFyIFRleHREaWZmVmlld01vZGVsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmZpbGVuYW1lID0gYXJncy5maWxlbmFtZTtcbiAgdGhpcy5yZXBvUGF0aCA9IGFyZ3MucmVwb1BhdGg7XG4gIHRoaXMuc2VydmVyID0gYXJncy5zZXJ2ZXI7XG4gIHRoaXMuc2hhMSA9IGFyZ3Muc2hhMTtcbiAgdGhpcy5sb2FkTW9yZUNvdW50ID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgdGhpcy5kaWZmSnNvbiA9IG51bGw7XG4gIHRoaXMubG9hZENvdW50ID0gbG9hZExpbWl0O1xuICB0aGlzLnRleHREaWZmVHlwZSA9IGFyZ3MudGV4dERpZmZUeXBlO1xuICB0aGlzLndoaXRlU3BhY2UgPSBhcmdzLndoaXRlU3BhY2U7XG4gIHRoaXMuaXNTaG93aW5nRGlmZnMgPSBhcmdzLmlzU2hvd2luZ0RpZmZzO1xuICB0aGlzLmVkaXRTdGF0ZSA9IGFyZ3MuZWRpdFN0YXRlO1xuICB0aGlzLndvcmRXcmFwID0gYXJncy53b3JkV3JhcDtcbiAgdGhpcy5wYXRjaExpbmVMaXN0ID0gYXJncy5wYXRjaExpbmVMaXN0O1xuICB0aGlzLm51bWJlck9mU2VsZWN0ZWRQYXRjaExpbmVzID0gMDtcbiAgdGhpcy5odG1sU3JjID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzUGFyc2VkID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG5cbiAgcHJvZ3JhbUV2ZW50cy5hZGQoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmV2ZW50ID09PSBcImludmFsaWRhdGUtZGlmZi1hbmQtcmVuZGVyXCIgfHwgZXZlbnQuZXZlbnQgPT09IFwid29ya2luZy10cmVlLWNoYW5nZWRcIikge1xuICAgICAgc2VsZi5pbnZhbGlkYXRlRGlmZigpO1xuICAgICAgaWYgKHNlbGYuaXNTaG93aW5nRGlmZnMoKSkgc2VsZi5yZW5kZXIoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuaXNTaG93aW5nRGlmZnMuc3Vic2NyaWJlKGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgIGlmIChuZXdWYWx1ZSkgc2VsZi5yZW5kZXIoKTtcbiAgfSk7XG5cbiAgaWYgKHRoaXMuaXNTaG93aW5nRGlmZnMoKSkgeyB0aGlzLnJlbmRlcigpOyB9XG59XG5UZXh0RGlmZlZpZXdNb2RlbC5wcm90b3R5cGUudXBkYXRlTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50KSB7XG4gIGtvLnJlbmRlclRlbXBsYXRlKCd0ZXh0ZGlmZicsIHRoaXMsIHt9LCBwYXJlbnRFbGVtZW50KTtcbn1cblRleHREaWZmVmlld01vZGVsLnByb3RvdHlwZS5nZXREaWZmQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGZpbGU6IHRoaXMuZmlsZW5hbWUsXG4gICAgcGF0aDogdGhpcy5yZXBvUGF0aCgpLFxuICAgIHNoYTE6IHRoaXMuc2hhMSA/IHRoaXMuc2hhMSA6ICcnLFxuICAgIHdoaXRlU3BhY2U6IHRoaXMud2hpdGVTcGFjZS52YWx1ZSgpXG4gIH07XG59XG5cblRleHREaWZmVmlld01vZGVsLnByb3RvdHlwZS5pbnZhbGlkYXRlRGlmZiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kaWZmSnNvbiA9IG51bGw7XG59XG5cblRleHREaWZmVmlld01vZGVsLnByb3RvdHlwZS5nZXREaWZmSnNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gc2VsZi5zZXJ2ZXIuZ2V0UHJvbWlzZSgnL2RpZmYnLCBzZWxmLmdldERpZmZBcmd1bWVudHMoKSkudGhlbihmdW5jdGlvbiAoZGlmZnMpIHtcbiAgICBpZiAodHlwZW9mIGRpZmZzICE9PSAnc3RyaW5nJykge1xuICAgICAgLy8gSW52YWxpZCB2YWx1ZSBtZWFucyB0aGVyZSBpcyBubyBjaGFuZ2VzLCBzaG93IGR1bW15IGRpZmYgd2l0aG90dSBhbnkgY2hhbmdlc1xuICAgICAgZGlmZnMgPSBgZGlmZiAtLWdpdCBhLyR7dGhpcy5maWxlbmFtZX0gYi8ke3RoaXMuZmlsZW5hbWV9XG4gICAgICAgICAgICAgICAgaW5kZXggYWFhYWFhYWEuLmJiYmJiYmJiIDExMTExMVxuICAgICAgICAgICAgICAgIC0tLSBhLyR7dGhpcy5maWxlbmFtZX1cbiAgICAgICAgICAgICAgICArKysgYi8ke3RoaXMuZmlsZW5hbWV9YDtcbiAgICB9XG4gICAgc2VsZi5kaWZmSnNvbiA9IGRpZmYyaHRtbC5nZXRKc29uRnJvbURpZmYoZGlmZnMpO1xuICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgLy8gVGhlIGZpbGUgZXhpc3RlZCBiZWZvcmUgYnV0IGhhcyBiZWVuIHJlbW92ZWQsIGJ1dCB3ZSdyZSB0cnlpbmcgdG8gZ2V0IGEgZGlmZiBmb3IgaXRcbiAgICAvLyBNb3N0IGxpa2VseSBpdCB3aWxsIGp1c3QgZGlzYXBwZWFyIHdpdGggdGhlIG5leHQgcmVmcmVzaCBvZiB0aGUgc3RhZ2luZyBhcmVhXG4gICAgLy8gc28gd2UganVzdCBpZ25vcmUgdGhlIGVycm9yIGhlcmVcbiAgICBpZiAoZXJyLmVycm9yQ29kZSAhPSAnbm8tc3VjaC1maWxlJykgc2VsZi5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGVycik7XG4gIH0pO1xufVxuXG5UZXh0RGlmZlZpZXdNb2RlbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGlzSW52YWxpZGF0ZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNlbGYuZGlmZkpzb24gfHwgaXNJbnZhbGlkYXRlKSB7XG4gICAgICByZXR1cm4gc2VsZi5nZXREaWZmSnNvbigpO1xuICAgIH1cbiAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzZWxmLmRpZmZKc29uIHx8IHNlbGYuZGlmZkpzb24ubGVuZ3RoID09IDApIHJldHVybjsgLy8gY2hlY2sgaWYgZGlmZnMgYXJlIGF2YWlsYWJsZSAoYmluYXJ5IGZpbGVzIGRvIG5vdCBzdXBwb3J0IHRoZW0pXG4gICAgdmFyIGxpbmVDb3VudCA9IDA7XG5cbiAgICBpZiAoIXNlbGYuZGlmZkpzb25bMF0uaXNUcmltbWVkKSB7XG4gICAgICBzZWxmLmRpZmZKc29uWzBdLmJsb2NrcyA9IHNlbGYuZGlmZkpzb25bMF0uYmxvY2tzLnJlZHVjZShmdW5jdGlvbiAoYmxvY2tzLCBibG9jaykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYmxvY2subGluZXMubGVuZ3RoO1xuICAgICAgICBpZiAobGluZUNvdW50IDwgc2VsZi5sb2FkQ291bnQpIHtcbiAgICAgICAgICBibG9jay5saW5lcyA9IGJsb2NrLmxpbmVzLnNsaWNlKDAsIHNlbGYubG9hZENvdW50IC0gbGluZUNvdW50KTtcbiAgICAgICAgICBibG9ja3MucHVzaChibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZUNvdW50ICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGJsb2NrcztcbiAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgc2VsZi5kaWZmSnNvblswXS5pc1RyaW1tZWQgPSB0cnVlO1xuXG4gICAgc2VsZi5sb2FkTW9yZUNvdW50KE1hdGgubWluKGxvYWRMaW1pdCwgTWF0aC5tYXgoMCwgbGluZUNvdW50IC0gc2VsZi5sb2FkQ291bnQpKSk7XG5cbiAgICB2YXIgaHRtbDtcblxuICAgIGlmIChzZWxmLnRleHREaWZmVHlwZS52YWx1ZSgpID09PSAnc2lkZWJ5c2lkZWRpZmYnKSB7XG4gICAgICBodG1sID0gZGlmZjJodG1sLmdldFByZXR0eVNpZGVCeVNpZGVIdG1sRnJvbUpzb24oc2VsZi5kaWZmSnNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh0bWwgPSBkaWZmMmh0bWwuZ2V0UHJldHR5SHRtbEZyb21Kc29uKHNlbGYuZGlmZkpzb24pO1xuICAgIH1cblxuICAgIHNlbGYubnVtYmVyT2ZTZWxlY3RlZFBhdGNoTGluZXMgPSAwO1xuICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAvLyBrbydzIGJpbmRpbmcgcmVzb2x1dGlvbiBpcyBub3QgcmVjdXJzaXZlLCB3aGljaCBtZWFucyBiZWxvdyBrby5iaW5kIHJlZnJlc2ggbWV0aG9kIGRvZXNuJ3Qgd29yayBmb3JcbiAgICAvLyBkYXRhIGJpbmQgYXQgZ2V0UGF0Y2hDaGVja0JveCB0aGF0IGlzIHJlbmRlcmVkIHdpdGggXCJodG1sXCIgYmluZGluZy5cbiAgICAvLyB3aGljaCBpcyByZWFzb24gd2h5IG1hbnVhbGx5IHVwZGF0aW5nIHRoZSBodG1sIGNvbnRlbnQgYW5kIHJlZnJlc2hpbmcga29iaW5kaW5nIHRvIGhhdmUgaXQgcmVuZGVyLi4uXG4gICAgaWYgKHNlbGYucGF0Y2hMaW5lTGlzdCkge1xuICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvPHNwYW4gY2xhc3M9XCJkMmgtY29kZS1saW5lLVthLXpdK1wiPihcXCt8XFwtKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGNhcHR1cmUpIHtcbiAgICAgICAgaWYgKHNlbGYucGF0Y2hMaW5lTGlzdCgpW2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZi5wYXRjaExpbmVMaXN0KClbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmLmdldFBhdGNoQ2hlY2tCb3goY2FwdHVyZSwgaW5kZXgsIHNlbGYucGF0Y2hMaW5lTGlzdCgpW2luZGV4KytdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChodG1sICE9PSBzZWxmLmh0bWxTcmMpIHtcbiAgICAgIC8vIGRpZmYgaGFzIGNoYW5nZWQgc2luY2UgbGFzdCB3ZSBkaXNwbGF5ZWQgYW5kIG5lZWQgcmVmcmVzaFxuICAgICAgc2VsZi5odG1sU3JjID0gaHRtbDtcbiAgICAgIHNlbGYuaXNQYXJzZWQoZmFsc2UpO1xuICAgICAgc2VsZi5pc1BhcnNlZCh0cnVlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuVGV4dERpZmZWaWV3TW9kZWwucHJvdG90eXBlLmxvYWRNb3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvYWRDb3VudCArPSB0aGlzLmxvYWRNb3JlQ291bnQoKTtcbiAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAnaW52YWxpZGF0ZS1kaWZmLWFuZC1yZW5kZXInIH0pO1xufVxuXG5UZXh0RGlmZlZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UGF0Y2hDaGVja0JveCA9IGZ1bmN0aW9uIChzeW1ib2wsIGluZGV4LCBpc0FjdGl2ZSkge1xuICBpZiAoaXNBY3RpdmUpIHtcbiAgICB0aGlzLm51bWJlck9mU2VsZWN0ZWRQYXRjaExpbmVzKys7XG4gIH1cbiAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiZDJoLWNvZGUtbGluZS1wcmVmaXhcIj48c3BhbiBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiBlZGl0U3RhdGUoKSAhPT0gXFwncGF0Y2hlZFxcJ1wiPicgKyBzeW1ib2wgKyAnPC9zcGFuPjxpbnB1dCAnICsgKGlzQWN0aXZlID8gJ2NoZWNrZWQnIDogJycpICsgJyB0eXBlPVwiY2hlY2tib3hcIiBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiBlZGl0U3RhdGUoKSA9PT0gXFwncGF0Y2hlZFxcJywgY2xpY2s6IHRvZ2dsZVBhdGNoTGluZS5iaW5kKCRkYXRhLCAnICsgaW5kZXggKyAnKVwiPjwvaW5wdXQ+Jztcbn1cblxuVGV4dERpZmZWaWV3TW9kZWwucHJvdG90eXBlLnRvZ2dsZVBhdGNoTGluZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB0aGlzLnBhdGNoTGluZUxpc3QoKVtpbmRleF0gPSAhdGhpcy5wYXRjaExpbmVMaXN0KClbaW5kZXhdO1xuXG4gIGlmICh0aGlzLnBhdGNoTGluZUxpc3QoKVtpbmRleF0pIHtcbiAgICB0aGlzLm51bWJlck9mU2VsZWN0ZWRQYXRjaExpbmVzKys7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5udW1iZXJPZlNlbGVjdGVkUGF0Y2hMaW5lcy0tO1xuICB9XG5cbiAgaWYgKHRoaXMubnVtYmVyT2ZTZWxlY3RlZFBhdGNoTGluZXMgPT09IDApIHtcbiAgICB0aGlzLmVkaXRTdGF0ZSgnbm9uZScpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iXX0=

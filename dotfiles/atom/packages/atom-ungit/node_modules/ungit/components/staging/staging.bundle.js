(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var ko = require('knockout');
var inherits = require('util').inherits;
var components = require('ungit-components');
var programEvents = require('ungit-program-events');
var _ = require('lodash');
var Promise = require("bluebird");
var filesToDisplayIncrmentBy = 50;
var filesToDisplayLimit = filesToDisplayIncrmentBy;
// when discard button is clicked and disable discard warning is selected, for next 5 minutes disable discard warnings
var muteGraceTimeDuration = 60 * 1000 * 5;
var mergeTool = ungit.config.mergeTool;

components.register('staging', function(args) {
  return new StagingViewModel(args.server, args.repoPath, args.graph);
});

var StagingViewModel = function(server, repoPath, graph) {
  var self = this;
  this.server = server;
  this.repoPath = repoPath;
  this.graph = graph;
  this.filesByPath = {};
  this.files = ko.observableArray();
  this.commitMessageTitleCount = ko.observable(0);
  this.commitMessageTitle = ko.observable();
  this.commitMessageTitle.subscribe(function(value) {
    self.commitMessageTitleCount(value.length);
  });
  this.commitMessageBody = ko.observable();
  this.wordWrap = components.create("textdiff.wordwrap");
  this.textDiffType = components.create('textdiff.type');
  this.whiteSpace = components.create('textdiff.whitespace');
  this.inRebase = ko.observable(false);
  this.inMerge = ko.observable(false);
  this.inCherry = ko.observable(false);
  this.conflictText = ko.computed(function() {
    if (self.inMerge()) {
      self.conflictContinue = self.conflictResolution.bind(self, '/merge/continue');
      self.conflictAbort = self.conflictResolution.bind(self, '/merge/abort');
      return "Merge";
    } else if (self.inRebase()) {
      self.conflictContinue = self.conflictResolution.bind(self, '/rebase/continue');
      self.conflictAbort = self.conflictResolution.bind(self, '/rebase/abort');
      return "Rebase";
    } else if (self.inCherry()) {
      self.conflictContinue = self.commit;
      self.conflictAbort = self.discardAllChanges;
      return "Cherry-pick";
    } else {
      self.conflictContinue = undefined;
      self.conflictAbort = undefined;
      return undefined;
    }
  });
  this.HEAD = ko.observable();
  this.isStageValid = ko.computed(function() {
    return !self.inRebase() && !self.inMerge() && !self.inCherry();
  });
  this.nFiles = ko.computed(function() {
    return self.files().length;
  });
  this.nStagedFiles = ko.computed(function() {
    return self.files().filter(function(f) { return f.editState() === 'staged'; }).length;
  });
  this.allStageFlag = ko.computed(function() {
    return self.nFiles() !== self.nStagedFiles();
  });
  this.stats = ko.computed(function() {
    return self.nFiles() + ' files, ' + self.nStagedFiles() + ' to be commited';
  });
  this.amend = ko.observable(false);
  this.canAmend = ko.computed(function() {
    return self.HEAD() && !self.inRebase() && !self.inMerge() && !self.emptyCommit();
  });
  this.emptyCommit = ko.observable(false);
  this.canEmptyCommit = ko.computed(function() {
    return self.HEAD() && !self.inRebase() && !self.inMerge();
  });
  this.canStashAll = ko.computed(function() {
    return !self.amend();
  });
  this.canPush = ko.computed(function() {
    return !!self.graph.currentRemote();
  });
  this.showNux = ko.computed(function() {
    return self.files().length == 0 && !self.amend() && !self.inRebase() && !self.emptyCommit();
  });
  this.showCancelButton = ko.computed(function() {
    return self.amend() || self.emptyCommit();
  });
  this.commitValidationError = ko.computed(function() {
    if (self.conflictText()) {
      if (self.files().some((file) => file.conflict())) return "Files in conflict";
    } else {
      if (!self.emptyCommit() && !self.amend() && !self.files().some((file) => file.editState() === 'staged' || file.editState() === 'patched')) {
        return "No files to commit";
      }
      if (!self.commitMessageTitle()) {
        return "Provide a title"
      }

      if (self.textDiffType.value() === 'sidebysidediff') {
        var patchFiles = self.files().filter(function(file) { return file.editState() === 'patched'; });
        if (patchFiles.length > 0) return "Cannot patch with side by side view."
      }
    }
    return ""
  });
  this.toggleSelectAllGlyphClass = ko.computed(function() {
    if (self.allStageFlag()) return 'glyphicon-unchecked';
    else return 'glyphicon-check';
  });

  this.refreshContentThrottled = _.throttle(this.refreshContent.bind(this), 400, { trailing: true });
  this.invalidateFilesDiffsThrottled = _.throttle(this.invalidateFilesDiffs.bind(this), 400, { trailing: true });
  this.refreshContentThrottled();
  if (window.location.search.indexOf('noheader=true') >= 0)
    this.refreshButton = components.create('refreshbutton');
  this.loadAnyway = false;
  this.isDiagOpen = false;
  this.mutedTime = null;
}
StagingViewModel.prototype.updateNode = function(parentElement) {
  ko.renderTemplate('staging', this, {}, parentElement);
}
StagingViewModel.prototype.onProgramEvent = function(event) {
  if (event.event == 'request-app-content-refresh') {
    this.refreshContent();
    this.invalidateFilesDiffs();
  }
  if (event.event == 'working-tree-changed') {
    this.refreshContentThrottled();
    this.invalidateFilesDiffsThrottled();
  }
}
StagingViewModel.prototype.refreshContent = function() {
  var self = this;
  return Promise.all([this.server.getPromise('/head', { path: this.repoPath(), limit: 1 })
      .then(function(log) {
        if (log.length > 0) {
          var array = log[0].message.split('\n');
          self.HEAD({title: array[0], body: array.slice(2).join('\n')});
        }
        else self.HEAD(null);
      }).catch(function(err) {
        if (err.errorCode != 'must-be-in-working-tree' && err.errorCode != 'no-such-path') {
          self.server.unhandledRejection(err);
        }
      }),
    this.server.getPromise('/status', { path: this.repoPath(), fileLimit: filesToDisplayLimit })
      .then(function(status) {
        if (Object.keys(status.files).length > filesToDisplayLimit && !self.loadAnyway) {
          if (self.isDiagOpen) {
            return;
          }
          self.isDiagOpen = true;
          return components.create('toomanyfilesdialogviewmodel', { title: 'Too many unstaged files', details: 'It is recommended to use command line as ungit may be too slow.'})
            .show()
            .closeThen(function(diag) {
              self.isDiagOpen = false;
              if (diag.result()) {
                self.loadAnyway = true;
                self.loadStatus(status);
              } else {
                window.location.href = '/#/';
              }
            });
        } else {
          self.loadStatus(status);
        }
      }).catch(function(err) {
        if (err.errorCode != 'must-be-in-working-tree' && err.errorCode != 'no-such-path') {
          self.server.unhandledRejection(err);
        }
      })]);
}
StagingViewModel.prototype.loadStatus = function(status) {
  this.setFiles(status.files);
  this.inRebase(!!status.inRebase);
  this.inMerge(!!status.inMerge);
  // There are time where '.git/CHERRY_PICK_HEAD' file is created and no files are in conflicts.
  // in such cases we should ignore exception as no good way to resolve it.
  this.inCherry(!!status.inCherry && !!status.inConflict);

  if (this.inRebase()) {
    this.commitMessageTitle('Rebase conflict');
    this.commitMessageBody('Commit messages are not applicable!\n(╯°□°）╯︵ ┻━┻');
  } else if (this.inMerge() || this.inCherry()) {
    var lines = status.commitMessage.split('\n');
    if (!this.commitMessageTitle()) {
      this.commitMessageTitle(lines[0]);
      this.commitMessageBody(lines.slice(1).join('\n'));
    }
  }
}
StagingViewModel.prototype.setFiles = function(files) {
  var self = this;
  var newFiles = [];
  for(var file in files) {
    var fileViewModel = this.filesByPath[file];
    if (!fileViewModel) {
      this.filesByPath[file] = fileViewModel = new FileViewModel(self, file);
    } else {
      // this is mainly for patching and it may not fire due to the fact that
      // '/commit' triggers working-tree-changed which triggers throttled refresh
      fileViewModel.diff().invalidateDiff();
    }
    fileViewModel.setState(files[file]);
    newFiles.push(fileViewModel);
  }
  this.files(newFiles);
  programEvents.dispatch({ event: 'init-tooltip' });
}
StagingViewModel.prototype.toggleAmend = function() {
  if (!this.amend() && !this.commitMessageTitle()) {
    this.commitMessageTitle(this.HEAD().title);
    this.commitMessageBody(this.HEAD().body);
  } else if(this.amend()) {
    var isPrevDefaultMsg =
      this.commitMessageTitle() == this.HEAD().title &&
      this.commitMessageBody() == this.HEAD().body;
    if (isPrevDefaultMsg) {
      this.commitMessageTitle('');
      this.commitMessageBody('');
    }
  }
  this.amend(!this.amend());
}
StagingViewModel.prototype.toggleEmptyCommit = function() {
  this.commitMessageTitle("Empty commit");
  this.commitMessageBody();
  this.emptyCommit(true);
}
StagingViewModel.prototype.resetMessages = function() {
  this.commitMessageTitle('');
  this.commitMessageBody('');
  for (var key in this.filesByPath) {
    var element = this.filesByPath[key];
    element.diff().invalidateDiff();
    element.patchLineList.removeAll();
    element.isShowingDiffs(false);
    element.editState(element.editState() === 'patched' ? 'none' : element.editState())
  }
  this.amend(false);
  this.emptyCommit(false);
}
StagingViewModel.prototype.commit = function() {
  var self = this;
  var files = this.files().filter(function(file) {
    return file.editState() !== 'none';
  }).map(function(file) {
    return { name: file.name(), patchLineList: file.editState() === 'patched' ? file.patchLineList() : null };
  });
  var commitMessage = this.commitMessageTitle();
  if (this.commitMessageBody()) commitMessage += '\n\n' + this.commitMessageBody();

  this.server.postPromise('/commit', { path: this.repoPath(), message: commitMessage, files: files, amend: this.amend(), emptyCommit: this.emptyCommit() })
    .then(() => { self.resetMessages(); })
    .catch((e) => this.server.unhandledRejection(e));
}
StagingViewModel.prototype.commitnpush = function() {
  var self = this;
  var files = this.files().filter(function(file) {
    return file.editState() !== 'none';
  }).map(function(file) {
    return { name: file.name(), patchLineList: file.editState() === 'patched' ? file.patchLineList() : null };
  });
  var commitMessage = this.commitMessageTitle();
  if (this.commitMessageBody()) commitMessage += '\n\n' + this.commitMessageBody();

  this.server.postPromise('/commit', { path: this.repoPath(), message: commitMessage, files: files, amend: this.amend(), emptyCommit: this.emptyCommit() })
    .then(() => {
      self.resetMessages();
      return this.server.postPromise('/push', { path: this.repoPath(), remote: this.graph.currentRemote() })
    })
    .catch(function(err) {
      if (err.errorCode == 'non-fast-forward') {
        return components.create('yesnodialog', { title: 'Force push?', details: 'The remote branch can\'t be fast-forwarded.' })
          .show()
          .closeThen(function(diag) {
            if (!diag.result()) return false;
            return self.server.postPromise('/push', { path: self.repoPath(), remote: self.graph.currentRemote(), force: true });
          }).closePromise;
      } else {
        self.server.unhandledRejection(err);
      }
    });
}
StagingViewModel.prototype.conflictResolution = function(apiPath) {
  var self = this;
  var commitMessage = this.commitMessageTitle();
  if (this.commitMessageBody()) commitMessage += '\n\n' + this.commitMessageBody();
  this.server.postPromise(apiPath, { path: this.repoPath(), message: commitMessage })
    .catch((e) => this.server.unhandledRejection(e))
    .finally((err) => { self.resetMessages(); });
}
StagingViewModel.prototype.invalidateFilesDiffs = function() {
  this.files().forEach(function(file) {
    file.diff().invalidateDiff();
  });
}
StagingViewModel.prototype.cancelAmendEmpty = function() {
  var self = this;
  self.resetMessages();
}
StagingViewModel.prototype.discardAllChanges = function() {
  var self = this;
  components.create('yesnodialog', { title: 'Are you sure you want to discard all changes?', details: 'This operation cannot be undone.'})
    .show()
    .closeThen(function(diag) {
      if (diag.result()) {
        self.server.postPromise('/discardchanges', { path: self.repoPath(), all: true })
          .catch((e) => this.server.unhandledRejection(e))
      }
    });
}
StagingViewModel.prototype.stashAll = function() {
  var self = this;
  this.server.postPromise('/stashes', { path: this.repoPath(), message: this.commitMessageTitle() })
    .catch((e) => this.server.unhandledRejection(e));
}
StagingViewModel.prototype.toggleAllStages = function() {
  var self = this;
  var allStageFlag = self.allStageFlag()
  for (var n in self.files()){
    self.files()[n].editState(allStageFlag ? 'staged' : 'none');
  }
}
StagingViewModel.prototype.onEnter = function(d, e){
    if (e.keyCode === 13 && !this.commitValidationError()) {
      this.commit();
    }
    return true;
};
StagingViewModel.prototype.onAltEnter = function(d, e){
    if (e.keyCode === 13 && e.altKey && !this.commitValidationError()) {
      this.commit();
    }
    return true;
};

var FileViewModel = function(staging, name) {
  var self = this;
  this.staging = staging;
  this.server = staging.server;
  this.editState = ko.observable('staged'); // staged, patched and none
  this.name = ko.observable(name);
  this.displayName = ko.observable(name);
  this.isNew = ko.observable(false);
  this.removed = ko.observable(false);
  this.conflict = ko.observable(false);
  this.renamed = ko.observable(false);
  this.isShowingDiffs = ko.observable(false);
  this.additions = ko.observable('');
  this.deletions = ko.observable('');
  this.fileType = ko.observable('text');
  this.patchLineList = ko.observableArray();
  this.diff = ko.observable();
  this.isShowPatch = ko.computed(function() {
    // if not new file
    // and if not merging
    // and if not rebasing
    // and if text file
    // and if diff is showing, display patch button
    return !self.isNew() && !staging.inMerge() && !staging.inRebase() && self.fileType() === 'text' && self.isShowingDiffs();
  });
  this.mergeTool = ko.computed(function() {
    return self.conflict() && mergeTool !== false;
  });

  this.editState.subscribe(function (value) {
    if (value === 'none') {
      self.patchLineList.removeAll();
    } else if (value === 'patched') {
      if (self.diff().render) self.diff().render();
    }
  });
}
FileViewModel.prototype.getSpecificDiff = function() {
  return components.create(!this.name() || this.fileType() + 'diff', {
    filename: this.name(),
    repoPath: this.staging.repoPath,
    server: this.server,
    textDiffType: this.staging.textDiffType,
    whiteSpace: this.staging.whiteSpace,
    isShowingDiffs: this.isShowingDiffs,
    patchLineList: this.patchLineList,
    editState: this.editState,
    wordWrap: this.staging.wordWrap
  });
}
FileViewModel.prototype.setState = function(state) {
  this.displayName(state.displayName);
  this.isNew(state.isNew);
  this.removed(state.removed);
  this.conflict(state.conflict);
  this.renamed(state.renamed);
  this.fileType(state.type);
  this.additions(state.additions != '-' ? '+' + state.additions : '');
  this.deletions(state.deletions != '-' ? '-' + state.deletions : '');
  if (this.diff()) {
    this.diff().invalidateDiff();
  } else {
    this.diff(this.getSpecificDiff());
  }
  if (this.diff().isNew) this.diff().isNew(state.isNew);
  if (this.diff().isRemoved) this.diff().isRemoved(state.removed);
}
FileViewModel.prototype.toggleStaged = function() {
  if (this.editState() === 'none') {
    this.editState('staged');
  } else {
    this.editState('none');
  }
  this.patchLineList([]);
}
FileViewModel.prototype.discardChanges = function() {
  var self = this;
  if (ungit.config.disableDiscardWarning || new Date().getTime() - this.staging.mutedTime < ungit.config.disableDiscardMuteTime) {
    self.server.postPromise('/discardchanges', { path: self.staging.repoPath(), file: self.name() })
      .catch((e) => this.server.unhandledRejection(e));
  } else {
    components.create('yesnomutedialog', { title: 'Are you sure you want to discard these changes?', details: 'This operation cannot be undone.'})
      .show()
      .closeThen(function(diag) {
        if (diag.result()) {
          self.server.postPromise('/discardchanges', { path: self.staging.repoPath(), file: self.name() })
            .catch((e) => this.server.unhandledRejection(e));
        }
        if (diag.result() === "mute") self.staging.mutedTime = new Date().getTime();
      });
  }
}
FileViewModel.prototype.ignoreFile = function() {
  var self = this;
  this.server.postPromise('/ignorefile', { path: this.staging.repoPath(), file: this.name() })
    .catch(function(err) {
      if (err.errorCode == 'file-already-git-ignored') {
        // The file was already in the .gitignore, so force an update of the staging area (to hopefully clear away this file)
        programEvents.dispatch({ event: 'working-tree-changed' });
      } else {
        self.server.unhandledRejection(err);
      }
    });
}
FileViewModel.prototype.resolveConflict = function() {
  this.server.postPromise('/resolveconflicts', { path: this.staging.repoPath(), files: [this.name()] })
    .catch((e) => this.server.unhandledRejection(e));
}
FileViewModel.prototype.launchMergeTool = function() {
  this.server.postPromise('/launchmergetool', { path: this.staging.repoPath(), file: this.name(), tool: mergeTool })
    .catch((e) => this.server.unhandledRejection(e));
}
FileViewModel.prototype.toggleDiffs = function() {
  if (this.renamed()) return; // do not show diffs for renames
  this.isShowingDiffs(!this.isShowingDiffs());
}
FileViewModel.prototype.patchClick = function() {
  if (!this.isShowingDiffs()) return;

  if (this.editState() === 'patched') {
    this.editState('staged');
  } else {
    this.editState('patched');
  }
}

},{"bluebird":undefined,"knockout":"knockout","lodash":"lodash","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events","util":undefined}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3N0YWdpbmcvc3RhZ2luZy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG52YXIgcHJvZ3JhbUV2ZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LXByb2dyYW0tZXZlbnRzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKFwiYmx1ZWJpcmRcIik7XG52YXIgZmlsZXNUb0Rpc3BsYXlJbmNybWVudEJ5ID0gNTA7XG52YXIgZmlsZXNUb0Rpc3BsYXlMaW1pdCA9IGZpbGVzVG9EaXNwbGF5SW5jcm1lbnRCeTtcbi8vIHdoZW4gZGlzY2FyZCBidXR0b24gaXMgY2xpY2tlZCBhbmQgZGlzYWJsZSBkaXNjYXJkIHdhcm5pbmcgaXMgc2VsZWN0ZWQsIGZvciBuZXh0IDUgbWludXRlcyBkaXNhYmxlIGRpc2NhcmQgd2FybmluZ3NcbnZhciBtdXRlR3JhY2VUaW1lRHVyYXRpb24gPSA2MCAqIDEwMDAgKiA1O1xudmFyIG1lcmdlVG9vbCA9IHVuZ2l0LmNvbmZpZy5tZXJnZVRvb2w7XG5cbmNvbXBvbmVudHMucmVnaXN0ZXIoJ3N0YWdpbmcnLCBmdW5jdGlvbihhcmdzKSB7XG4gIHJldHVybiBuZXcgU3RhZ2luZ1ZpZXdNb2RlbChhcmdzLnNlcnZlciwgYXJncy5yZXBvUGF0aCwgYXJncy5ncmFwaCk7XG59KTtcblxudmFyIFN0YWdpbmdWaWV3TW9kZWwgPSBmdW5jdGlvbihzZXJ2ZXIsIHJlcG9QYXRoLCBncmFwaCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICB0aGlzLnJlcG9QYXRoID0gcmVwb1BhdGg7XG4gIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5maWxlc0J5UGF0aCA9IHt9O1xuICB0aGlzLmZpbGVzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlQ291bnQgPSBrby5vYnNlcnZhYmxlKDApO1xuICB0aGlzLmNvbW1pdE1lc3NhZ2VUaXRsZSA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5jb21taXRNZXNzYWdlVGl0bGUuc3Vic2NyaWJlKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgc2VsZi5jb21taXRNZXNzYWdlVGl0bGVDb3VudCh2YWx1ZS5sZW5ndGgpO1xuICB9KTtcbiAgdGhpcy5jb21taXRNZXNzYWdlQm9keSA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy53b3JkV3JhcCA9IGNvbXBvbmVudHMuY3JlYXRlKFwidGV4dGRpZmYud29yZHdyYXBcIik7XG4gIHRoaXMudGV4dERpZmZUeXBlID0gY29tcG9uZW50cy5jcmVhdGUoJ3RleHRkaWZmLnR5cGUnKTtcbiAgdGhpcy53aGl0ZVNwYWNlID0gY29tcG9uZW50cy5jcmVhdGUoJ3RleHRkaWZmLndoaXRlc3BhY2UnKTtcbiAgdGhpcy5pblJlYmFzZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmluTWVyZ2UgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5pbkNoZXJyeSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNvbmZsaWN0VGV4dCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLmluTWVyZ2UoKSkge1xuICAgICAgc2VsZi5jb25mbGljdENvbnRpbnVlID0gc2VsZi5jb25mbGljdFJlc29sdXRpb24uYmluZChzZWxmLCAnL21lcmdlL2NvbnRpbnVlJyk7XG4gICAgICBzZWxmLmNvbmZsaWN0QWJvcnQgPSBzZWxmLmNvbmZsaWN0UmVzb2x1dGlvbi5iaW5kKHNlbGYsICcvbWVyZ2UvYWJvcnQnKTtcbiAgICAgIHJldHVybiBcIk1lcmdlXCI7XG4gICAgfSBlbHNlIGlmIChzZWxmLmluUmViYXNlKCkpIHtcbiAgICAgIHNlbGYuY29uZmxpY3RDb250aW51ZSA9IHNlbGYuY29uZmxpY3RSZXNvbHV0aW9uLmJpbmQoc2VsZiwgJy9yZWJhc2UvY29udGludWUnKTtcbiAgICAgIHNlbGYuY29uZmxpY3RBYm9ydCA9IHNlbGYuY29uZmxpY3RSZXNvbHV0aW9uLmJpbmQoc2VsZiwgJy9yZWJhc2UvYWJvcnQnKTtcbiAgICAgIHJldHVybiBcIlJlYmFzZVwiO1xuICAgIH0gZWxzZSBpZiAoc2VsZi5pbkNoZXJyeSgpKSB7XG4gICAgICBzZWxmLmNvbmZsaWN0Q29udGludWUgPSBzZWxmLmNvbW1pdDtcbiAgICAgIHNlbGYuY29uZmxpY3RBYm9ydCA9IHNlbGYuZGlzY2FyZEFsbENoYW5nZXM7XG4gICAgICByZXR1cm4gXCJDaGVycnktcGlja1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmNvbmZsaWN0Q29udGludWUgPSB1bmRlZmluZWQ7XG4gICAgICBzZWxmLmNvbmZsaWN0QWJvcnQgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuSEVBRCA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5pc1N0YWdlVmFsaWQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXNlbGYuaW5SZWJhc2UoKSAmJiAhc2VsZi5pbk1lcmdlKCkgJiYgIXNlbGYuaW5DaGVycnkoKTtcbiAgfSk7XG4gIHRoaXMubkZpbGVzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuZmlsZXMoKS5sZW5ndGg7XG4gIH0pO1xuICB0aGlzLm5TdGFnZWRGaWxlcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLmZpbGVzKCkuZmlsdGVyKGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGYuZWRpdFN0YXRlKCkgPT09ICdzdGFnZWQnOyB9KS5sZW5ndGg7XG4gIH0pO1xuICB0aGlzLmFsbFN0YWdlRmxhZyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLm5GaWxlcygpICE9PSBzZWxmLm5TdGFnZWRGaWxlcygpO1xuICB9KTtcbiAgdGhpcy5zdGF0cyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLm5GaWxlcygpICsgJyBmaWxlcywgJyArIHNlbGYublN0YWdlZEZpbGVzKCkgKyAnIHRvIGJlIGNvbW1pdGVkJztcbiAgfSk7XG4gIHRoaXMuYW1lbmQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5jYW5BbWVuZCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLkhFQUQoKSAmJiAhc2VsZi5pblJlYmFzZSgpICYmICFzZWxmLmluTWVyZ2UoKSAmJiAhc2VsZi5lbXB0eUNvbW1pdCgpO1xuICB9KTtcbiAgdGhpcy5lbXB0eUNvbW1pdCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNhbkVtcHR5Q29tbWl0ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuSEVBRCgpICYmICFzZWxmLmluUmViYXNlKCkgJiYgIXNlbGYuaW5NZXJnZSgpO1xuICB9KTtcbiAgdGhpcy5jYW5TdGFzaEFsbCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhc2VsZi5hbWVuZCgpO1xuICB9KTtcbiAgdGhpcy5jYW5QdXNoID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhc2VsZi5ncmFwaC5jdXJyZW50UmVtb3RlKCk7XG4gIH0pO1xuICB0aGlzLnNob3dOdXggPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5maWxlcygpLmxlbmd0aCA9PSAwICYmICFzZWxmLmFtZW5kKCkgJiYgIXNlbGYuaW5SZWJhc2UoKSAmJiAhc2VsZi5lbXB0eUNvbW1pdCgpO1xuICB9KTtcbiAgdGhpcy5zaG93Q2FuY2VsQnV0dG9uID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuYW1lbmQoKSB8fCBzZWxmLmVtcHR5Q29tbWl0KCk7XG4gIH0pO1xuICB0aGlzLmNvbW1pdFZhbGlkYXRpb25FcnJvciA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLmNvbmZsaWN0VGV4dCgpKSB7XG4gICAgICBpZiAoc2VsZi5maWxlcygpLnNvbWUoKGZpbGUpID0+IGZpbGUuY29uZmxpY3QoKSkpIHJldHVybiBcIkZpbGVzIGluIGNvbmZsaWN0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc2VsZi5lbXB0eUNvbW1pdCgpICYmICFzZWxmLmFtZW5kKCkgJiYgIXNlbGYuZmlsZXMoKS5zb21lKChmaWxlKSA9PiBmaWxlLmVkaXRTdGF0ZSgpID09PSAnc3RhZ2VkJyB8fCBmaWxlLmVkaXRTdGF0ZSgpID09PSAncGF0Y2hlZCcpKSB7XG4gICAgICAgIHJldHVybiBcIk5vIGZpbGVzIHRvIGNvbW1pdFwiO1xuICAgICAgfVxuICAgICAgaWYgKCFzZWxmLmNvbW1pdE1lc3NhZ2VUaXRsZSgpKSB7XG4gICAgICAgIHJldHVybiBcIlByb3ZpZGUgYSB0aXRsZVwiXG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnRleHREaWZmVHlwZS52YWx1ZSgpID09PSAnc2lkZWJ5c2lkZWRpZmYnKSB7XG4gICAgICAgIHZhciBwYXRjaEZpbGVzID0gc2VsZi5maWxlcygpLmZpbHRlcihmdW5jdGlvbihmaWxlKSB7IHJldHVybiBmaWxlLmVkaXRTdGF0ZSgpID09PSAncGF0Y2hlZCc7IH0pO1xuICAgICAgICBpZiAocGF0Y2hGaWxlcy5sZW5ndGggPiAwKSByZXR1cm4gXCJDYW5ub3QgcGF0Y2ggd2l0aCBzaWRlIGJ5IHNpZGUgdmlldy5cIlxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIlxuICB9KTtcbiAgdGhpcy50b2dnbGVTZWxlY3RBbGxHbHlwaENsYXNzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuYWxsU3RhZ2VGbGFnKCkpIHJldHVybiAnZ2x5cGhpY29uLXVuY2hlY2tlZCc7XG4gICAgZWxzZSByZXR1cm4gJ2dseXBoaWNvbi1jaGVjayc7XG4gIH0pO1xuXG4gIHRoaXMucmVmcmVzaENvbnRlbnRUaHJvdHRsZWQgPSBfLnRocm90dGxlKHRoaXMucmVmcmVzaENvbnRlbnQuYmluZCh0aGlzKSwgNDAwLCB7IHRyYWlsaW5nOiB0cnVlIH0pO1xuICB0aGlzLmludmFsaWRhdGVGaWxlc0RpZmZzVGhyb3R0bGVkID0gXy50aHJvdHRsZSh0aGlzLmludmFsaWRhdGVGaWxlc0RpZmZzLmJpbmQodGhpcyksIDQwMCwgeyB0cmFpbGluZzogdHJ1ZSB9KTtcbiAgdGhpcy5yZWZyZXNoQ29udGVudFRocm90dGxlZCgpO1xuICBpZiAod2luZG93LmxvY2F0aW9uLnNlYXJjaC5pbmRleE9mKCdub2hlYWRlcj10cnVlJykgPj0gMClcbiAgICB0aGlzLnJlZnJlc2hCdXR0b24gPSBjb21wb25lbnRzLmNyZWF0ZSgncmVmcmVzaGJ1dHRvbicpO1xuICB0aGlzLmxvYWRBbnl3YXkgPSBmYWxzZTtcbiAgdGhpcy5pc0RpYWdPcGVuID0gZmFsc2U7XG4gIHRoaXMubXV0ZWRUaW1lID0gbnVsbDtcbn1cblN0YWdpbmdWaWV3TW9kZWwucHJvdG90eXBlLnVwZGF0ZU5vZGUgPSBmdW5jdGlvbihwYXJlbnRFbGVtZW50KSB7XG4gIGtvLnJlbmRlclRlbXBsYXRlKCdzdGFnaW5nJywgdGhpcywge30sIHBhcmVudEVsZW1lbnQpO1xufVxuU3RhZ2luZ1ZpZXdNb2RlbC5wcm90b3R5cGUub25Qcm9ncmFtRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICBpZiAoZXZlbnQuZXZlbnQgPT0gJ3JlcXVlc3QtYXBwLWNvbnRlbnQtcmVmcmVzaCcpIHtcbiAgICB0aGlzLnJlZnJlc2hDb250ZW50KCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlRmlsZXNEaWZmcygpO1xuICB9XG4gIGlmIChldmVudC5ldmVudCA9PSAnd29ya2luZy10cmVlLWNoYW5nZWQnKSB7XG4gICAgdGhpcy5yZWZyZXNoQ29udGVudFRocm90dGxlZCgpO1xuICAgIHRoaXMuaW52YWxpZGF0ZUZpbGVzRGlmZnNUaHJvdHRsZWQoKTtcbiAgfVxufVxuU3RhZ2luZ1ZpZXdNb2RlbC5wcm90b3R5cGUucmVmcmVzaENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoW3RoaXMuc2VydmVyLmdldFByb21pc2UoJy9oZWFkJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIGxpbWl0OiAxIH0pXG4gICAgICAudGhlbihmdW5jdGlvbihsb2cpIHtcbiAgICAgICAgaWYgKGxvZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGFycmF5ID0gbG9nWzBdLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIHNlbGYuSEVBRCh7dGl0bGU6IGFycmF5WzBdLCBib2R5OiBhcnJheS5zbGljZSgyKS5qb2luKCdcXG4nKX0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Ugc2VsZi5IRUFEKG51bGwpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIuZXJyb3JDb2RlICE9ICdtdXN0LWJlLWluLXdvcmtpbmctdHJlZScgJiYgZXJyLmVycm9yQ29kZSAhPSAnbm8tc3VjaC1wYXRoJykge1xuICAgICAgICAgIHNlbGYuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlcnIpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICB0aGlzLnNlcnZlci5nZXRQcm9taXNlKCcvc3RhdHVzJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIGZpbGVMaW1pdDogZmlsZXNUb0Rpc3BsYXlMaW1pdCB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzdGF0dXMuZmlsZXMpLmxlbmd0aCA+IGZpbGVzVG9EaXNwbGF5TGltaXQgJiYgIXNlbGYubG9hZEFueXdheSkge1xuICAgICAgICAgIGlmIChzZWxmLmlzRGlhZ09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5pc0RpYWdPcGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50cy5jcmVhdGUoJ3Rvb21hbnlmaWxlc2RpYWxvZ3ZpZXdtb2RlbCcsIHsgdGl0bGU6ICdUb28gbWFueSB1bnN0YWdlZCBmaWxlcycsIGRldGFpbHM6ICdJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgY29tbWFuZCBsaW5lIGFzIHVuZ2l0IG1heSBiZSB0b28gc2xvdy4nfSlcbiAgICAgICAgICAgIC5zaG93KClcbiAgICAgICAgICAgIC5jbG9zZVRoZW4oZnVuY3Rpb24oZGlhZykge1xuICAgICAgICAgICAgICBzZWxmLmlzRGlhZ09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGRpYWcucmVzdWx0KCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmxvYWRBbnl3YXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYubG9hZFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy8jLyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYubG9hZFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVyci5lcnJvckNvZGUgIT0gJ211c3QtYmUtaW4td29ya2luZy10cmVlJyAmJiBlcnIuZXJyb3JDb2RlICE9ICduby1zdWNoLXBhdGgnKSB7XG4gICAgICAgICAgc2VsZi5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pXSk7XG59XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5sb2FkU3RhdHVzID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gIHRoaXMuc2V0RmlsZXMoc3RhdHVzLmZpbGVzKTtcbiAgdGhpcy5pblJlYmFzZSghIXN0YXR1cy5pblJlYmFzZSk7XG4gIHRoaXMuaW5NZXJnZSghIXN0YXR1cy5pbk1lcmdlKTtcbiAgLy8gVGhlcmUgYXJlIHRpbWUgd2hlcmUgJy5naXQvQ0hFUlJZX1BJQ0tfSEVBRCcgZmlsZSBpcyBjcmVhdGVkIGFuZCBubyBmaWxlcyBhcmUgaW4gY29uZmxpY3RzLlxuICAvLyBpbiBzdWNoIGNhc2VzIHdlIHNob3VsZCBpZ25vcmUgZXhjZXB0aW9uIGFzIG5vIGdvb2Qgd2F5IHRvIHJlc29sdmUgaXQuXG4gIHRoaXMuaW5DaGVycnkoISFzdGF0dXMuaW5DaGVycnkgJiYgISFzdGF0dXMuaW5Db25mbGljdCk7XG5cbiAgaWYgKHRoaXMuaW5SZWJhc2UoKSkge1xuICAgIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCdSZWJhc2UgY29uZmxpY3QnKTtcbiAgICB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCdDb21taXQgbWVzc2FnZXMgYXJlIG5vdCBhcHBsaWNhYmxlIVxcbijila/CsOKWocKw77yJ4pWv77i1IOKUu+KUgeKUuycpO1xuICB9IGVsc2UgaWYgKHRoaXMuaW5NZXJnZSgpIHx8IHRoaXMuaW5DaGVycnkoKSkge1xuICAgIHZhciBsaW5lcyA9IHN0YXR1cy5jb21taXRNZXNzYWdlLnNwbGl0KCdcXG4nKTtcbiAgICBpZiAoIXRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCkpIHtcbiAgICAgIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKGxpbmVzWzBdKTtcbiAgICAgIHRoaXMuY29tbWl0TWVzc2FnZUJvZHkobGluZXMuc2xpY2UoMSkuam9pbignXFxuJykpO1xuICAgIH1cbiAgfVxufVxuU3RhZ2luZ1ZpZXdNb2RlbC5wcm90b3R5cGUuc2V0RmlsZXMgPSBmdW5jdGlvbihmaWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBuZXdGaWxlcyA9IFtdO1xuICBmb3IodmFyIGZpbGUgaW4gZmlsZXMpIHtcbiAgICB2YXIgZmlsZVZpZXdNb2RlbCA9IHRoaXMuZmlsZXNCeVBhdGhbZmlsZV07XG4gICAgaWYgKCFmaWxlVmlld01vZGVsKSB7XG4gICAgICB0aGlzLmZpbGVzQnlQYXRoW2ZpbGVdID0gZmlsZVZpZXdNb2RlbCA9IG5ldyBGaWxlVmlld01vZGVsKHNlbGYsIGZpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGlzIGlzIG1haW5seSBmb3IgcGF0Y2hpbmcgYW5kIGl0IG1heSBub3QgZmlyZSBkdWUgdG8gdGhlIGZhY3QgdGhhdFxuICAgICAgLy8gJy9jb21taXQnIHRyaWdnZXJzIHdvcmtpbmctdHJlZS1jaGFuZ2VkIHdoaWNoIHRyaWdnZXJzIHRocm90dGxlZCByZWZyZXNoXG4gICAgICBmaWxlVmlld01vZGVsLmRpZmYoKS5pbnZhbGlkYXRlRGlmZigpO1xuICAgIH1cbiAgICBmaWxlVmlld01vZGVsLnNldFN0YXRlKGZpbGVzW2ZpbGVdKTtcbiAgICBuZXdGaWxlcy5wdXNoKGZpbGVWaWV3TW9kZWwpO1xuICB9XG4gIHRoaXMuZmlsZXMobmV3RmlsZXMpO1xuICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdpbml0LXRvb2x0aXAnIH0pO1xufVxuU3RhZ2luZ1ZpZXdNb2RlbC5wcm90b3R5cGUudG9nZ2xlQW1lbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmFtZW5kKCkgJiYgIXRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCkpIHtcbiAgICB0aGlzLmNvbW1pdE1lc3NhZ2VUaXRsZSh0aGlzLkhFQUQoKS50aXRsZSk7XG4gICAgdGhpcy5jb21taXRNZXNzYWdlQm9keSh0aGlzLkhFQUQoKS5ib2R5KTtcbiAgfSBlbHNlIGlmKHRoaXMuYW1lbmQoKSkge1xuICAgIHZhciBpc1ByZXZEZWZhdWx0TXNnID1cbiAgICAgIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCkgPT0gdGhpcy5IRUFEKCkudGl0bGUgJiZcbiAgICAgIHRoaXMuY29tbWl0TWVzc2FnZUJvZHkoKSA9PSB0aGlzLkhFQUQoKS5ib2R5O1xuICAgIGlmIChpc1ByZXZEZWZhdWx0TXNnKSB7XG4gICAgICB0aGlzLmNvbW1pdE1lc3NhZ2VUaXRsZSgnJyk7XG4gICAgICB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCcnKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5hbWVuZCghdGhpcy5hbWVuZCgpKTtcbn1cblN0YWdpbmdWaWV3TW9kZWwucHJvdG90eXBlLnRvZ2dsZUVtcHR5Q29tbWl0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKFwiRW1wdHkgY29tbWl0XCIpO1xuICB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCk7XG4gIHRoaXMuZW1wdHlDb21taXQodHJ1ZSk7XG59XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5yZXNldE1lc3NhZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCcnKTtcbiAgdGhpcy5jb21taXRNZXNzYWdlQm9keSgnJyk7XG4gIGZvciAodmFyIGtleSBpbiB0aGlzLmZpbGVzQnlQYXRoKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmZpbGVzQnlQYXRoW2tleV07XG4gICAgZWxlbWVudC5kaWZmKCkuaW52YWxpZGF0ZURpZmYoKTtcbiAgICBlbGVtZW50LnBhdGNoTGluZUxpc3QucmVtb3ZlQWxsKCk7XG4gICAgZWxlbWVudC5pc1Nob3dpbmdEaWZmcyhmYWxzZSk7XG4gICAgZWxlbWVudC5lZGl0U3RhdGUoZWxlbWVudC5lZGl0U3RhdGUoKSA9PT0gJ3BhdGNoZWQnID8gJ25vbmUnIDogZWxlbWVudC5lZGl0U3RhdGUoKSlcbiAgfVxuICB0aGlzLmFtZW5kKGZhbHNlKTtcbiAgdGhpcy5lbXB0eUNvbW1pdChmYWxzZSk7XG59XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZmlsZXMgPSB0aGlzLmZpbGVzKCkuZmlsdGVyKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICByZXR1cm4gZmlsZS5lZGl0U3RhdGUoKSAhPT0gJ25vbmUnO1xuICB9KS5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgIHJldHVybiB7IG5hbWU6IGZpbGUubmFtZSgpLCBwYXRjaExpbmVMaXN0OiBmaWxlLmVkaXRTdGF0ZSgpID09PSAncGF0Y2hlZCcgPyBmaWxlLnBhdGNoTGluZUxpc3QoKSA6IG51bGwgfTtcbiAgfSk7XG4gIHZhciBjb21taXRNZXNzYWdlID0gdGhpcy5jb21taXRNZXNzYWdlVGl0bGUoKTtcbiAgaWYgKHRoaXMuY29tbWl0TWVzc2FnZUJvZHkoKSkgY29tbWl0TWVzc2FnZSArPSAnXFxuXFxuJyArIHRoaXMuY29tbWl0TWVzc2FnZUJvZHkoKTtcblxuICB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL2NvbW1pdCcsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpLCBtZXNzYWdlOiBjb21taXRNZXNzYWdlLCBmaWxlczogZmlsZXMsIGFtZW5kOiB0aGlzLmFtZW5kKCksIGVtcHR5Q29tbWl0OiB0aGlzLmVtcHR5Q29tbWl0KCkgfSlcbiAgICAudGhlbigoKSA9PiB7IHNlbGYucmVzZXRNZXNzYWdlcygpOyB9KVxuICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKTtcbn1cblN0YWdpbmdWaWV3TW9kZWwucHJvdG90eXBlLmNvbW1pdG5wdXNoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGZpbGVzID0gdGhpcy5maWxlcygpLmZpbHRlcihmdW5jdGlvbihmaWxlKSB7XG4gICAgcmV0dXJuIGZpbGUuZWRpdFN0YXRlKCkgIT09ICdub25lJztcbiAgfSkubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICByZXR1cm4geyBuYW1lOiBmaWxlLm5hbWUoKSwgcGF0Y2hMaW5lTGlzdDogZmlsZS5lZGl0U3RhdGUoKSA9PT0gJ3BhdGNoZWQnID8gZmlsZS5wYXRjaExpbmVMaXN0KCkgOiBudWxsIH07XG4gIH0pO1xuICB2YXIgY29tbWl0TWVzc2FnZSA9IHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCk7XG4gIGlmICh0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCkpIGNvbW1pdE1lc3NhZ2UgKz0gJ1xcblxcbicgKyB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCk7XG5cbiAgdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9jb21taXQnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSwgbWVzc2FnZTogY29tbWl0TWVzc2FnZSwgZmlsZXM6IGZpbGVzLCBhbWVuZDogdGhpcy5hbWVuZCgpLCBlbXB0eUNvbW1pdDogdGhpcy5lbXB0eUNvbW1pdCgpIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgc2VsZi5yZXNldE1lc3NhZ2VzKCk7XG4gICAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9wdXNoJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIHJlbW90ZTogdGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCkgfSlcbiAgICB9KVxuICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIuZXJyb3JDb2RlID09ICdub24tZmFzdC1mb3J3YXJkJykge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0ZvcmNlIHB1c2g/JywgZGV0YWlsczogJ1RoZSByZW1vdGUgYnJhbmNoIGNhblxcJ3QgYmUgZmFzdC1mb3J3YXJkZWQuJyB9KVxuICAgICAgICAgIC5zaG93KClcbiAgICAgICAgICAuY2xvc2VUaGVuKGZ1bmN0aW9uKGRpYWcpIHtcbiAgICAgICAgICAgIGlmICghZGlhZy5yZXN1bHQoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2VydmVyLnBvc3RQcm9taXNlKCcvcHVzaCcsIHsgcGF0aDogc2VsZi5yZXBvUGF0aCgpLCByZW1vdGU6IHNlbGYuZ3JhcGguY3VycmVudFJlbW90ZSgpLCBmb3JjZTogdHJ1ZSB9KTtcbiAgICAgICAgICB9KS5jbG9zZVByb21pc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbn1cblN0YWdpbmdWaWV3TW9kZWwucHJvdG90eXBlLmNvbmZsaWN0UmVzb2x1dGlvbiA9IGZ1bmN0aW9uKGFwaVBhdGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY29tbWl0TWVzc2FnZSA9IHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCk7XG4gIGlmICh0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCkpIGNvbW1pdE1lc3NhZ2UgKz0gJ1xcblxcbicgKyB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCk7XG4gIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKGFwaVBhdGgsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpLCBtZXNzYWdlOiBjb21taXRNZXNzYWdlIH0pXG4gICAgLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpXG4gICAgLmZpbmFsbHkoKGVycikgPT4geyBzZWxmLnJlc2V0TWVzc2FnZXMoKTsgfSk7XG59XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5pbnZhbGlkYXRlRmlsZXNEaWZmcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZpbGVzKCkuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XG4gICAgZmlsZS5kaWZmKCkuaW52YWxpZGF0ZURpZmYoKTtcbiAgfSk7XG59XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5jYW5jZWxBbWVuZEVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5yZXNldE1lc3NhZ2VzKCk7XG59XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5kaXNjYXJkQWxsQ2hhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNvbXBvbmVudHMuY3JlYXRlKCd5ZXNub2RpYWxvZycsIHsgdGl0bGU6ICdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGlzY2FyZCBhbGwgY2hhbmdlcz8nLCBkZXRhaWxzOiAnVGhpcyBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4nfSlcbiAgICAuc2hvdygpXG4gICAgLmNsb3NlVGhlbihmdW5jdGlvbihkaWFnKSB7XG4gICAgICBpZiAoZGlhZy5yZXN1bHQoKSkge1xuICAgICAgICBzZWxmLnNlcnZlci5wb3N0UHJvbWlzZSgnL2Rpc2NhcmRjaGFuZ2VzJywgeyBwYXRoOiBzZWxmLnJlcG9QYXRoKCksIGFsbDogdHJ1ZSB9KVxuICAgICAgICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKVxuICAgICAgfVxuICAgIH0pO1xufVxuU3RhZ2luZ1ZpZXdNb2RlbC5wcm90b3R5cGUuc3Rhc2hBbGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL3N0YXNoZXMnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSwgbWVzc2FnZTogdGhpcy5jb21taXRNZXNzYWdlVGl0bGUoKSB9KVxuICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKTtcbn1cblN0YWdpbmdWaWV3TW9kZWwucHJvdG90eXBlLnRvZ2dsZUFsbFN0YWdlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhbGxTdGFnZUZsYWcgPSBzZWxmLmFsbFN0YWdlRmxhZygpXG4gIGZvciAodmFyIG4gaW4gc2VsZi5maWxlcygpKXtcbiAgICBzZWxmLmZpbGVzKClbbl0uZWRpdFN0YXRlKGFsbFN0YWdlRmxhZyA/ICdzdGFnZWQnIDogJ25vbmUnKTtcbiAgfVxufVxuU3RhZ2luZ1ZpZXdNb2RlbC5wcm90b3R5cGUub25FbnRlciA9IGZ1bmN0aW9uKGQsIGUpe1xuICAgIGlmIChlLmtleUNvZGUgPT09IDEzICYmICF0aGlzLmNvbW1pdFZhbGlkYXRpb25FcnJvcigpKSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5vbkFsdEVudGVyID0gZnVuY3Rpb24oZCwgZSl7XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMTMgJiYgZS5hbHRLZXkgJiYgIXRoaXMuY29tbWl0VmFsaWRhdGlvbkVycm9yKCkpIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxudmFyIEZpbGVWaWV3TW9kZWwgPSBmdW5jdGlvbihzdGFnaW5nLCBuYW1lKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zdGFnaW5nID0gc3RhZ2luZztcbiAgdGhpcy5zZXJ2ZXIgPSBzdGFnaW5nLnNlcnZlcjtcbiAgdGhpcy5lZGl0U3RhdGUgPSBrby5vYnNlcnZhYmxlKCdzdGFnZWQnKTsgLy8gc3RhZ2VkLCBwYXRjaGVkIGFuZCBub25lXG4gIHRoaXMubmFtZSA9IGtvLm9ic2VydmFibGUobmFtZSk7XG4gIHRoaXMuZGlzcGxheU5hbWUgPSBrby5vYnNlcnZhYmxlKG5hbWUpO1xuICB0aGlzLmlzTmV3ID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMucmVtb3ZlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNvbmZsaWN0ID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMucmVuYW1lZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmlzU2hvd2luZ0RpZmZzID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMuYWRkaXRpb25zID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gIHRoaXMuZGVsZXRpb25zID0ga28ub2JzZXJ2YWJsZSgnJyk7XG4gIHRoaXMuZmlsZVR5cGUgPSBrby5vYnNlcnZhYmxlKCd0ZXh0Jyk7XG4gIHRoaXMucGF0Y2hMaW5lTGlzdCA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLmRpZmYgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuaXNTaG93UGF0Y2ggPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAvLyBpZiBub3QgbmV3IGZpbGVcbiAgICAvLyBhbmQgaWYgbm90IG1lcmdpbmdcbiAgICAvLyBhbmQgaWYgbm90IHJlYmFzaW5nXG4gICAgLy8gYW5kIGlmIHRleHQgZmlsZVxuICAgIC8vIGFuZCBpZiBkaWZmIGlzIHNob3dpbmcsIGRpc3BsYXkgcGF0Y2ggYnV0dG9uXG4gICAgcmV0dXJuICFzZWxmLmlzTmV3KCkgJiYgIXN0YWdpbmcuaW5NZXJnZSgpICYmICFzdGFnaW5nLmluUmViYXNlKCkgJiYgc2VsZi5maWxlVHlwZSgpID09PSAndGV4dCcgJiYgc2VsZi5pc1Nob3dpbmdEaWZmcygpO1xuICB9KTtcbiAgdGhpcy5tZXJnZVRvb2wgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5jb25mbGljdCgpICYmIG1lcmdlVG9vbCAhPT0gZmFsc2U7XG4gIH0pO1xuXG4gIHRoaXMuZWRpdFN0YXRlLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09ICdub25lJykge1xuICAgICAgc2VsZi5wYXRjaExpbmVMaXN0LnJlbW92ZUFsbCgpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdwYXRjaGVkJykge1xuICAgICAgaWYgKHNlbGYuZGlmZigpLnJlbmRlcikgc2VsZi5kaWZmKCkucmVuZGVyKCk7XG4gICAgfVxuICB9KTtcbn1cbkZpbGVWaWV3TW9kZWwucHJvdG90eXBlLmdldFNwZWNpZmljRGlmZiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY29tcG9uZW50cy5jcmVhdGUoIXRoaXMubmFtZSgpIHx8IHRoaXMuZmlsZVR5cGUoKSArICdkaWZmJywge1xuICAgIGZpbGVuYW1lOiB0aGlzLm5hbWUoKSxcbiAgICByZXBvUGF0aDogdGhpcy5zdGFnaW5nLnJlcG9QYXRoLFxuICAgIHNlcnZlcjogdGhpcy5zZXJ2ZXIsXG4gICAgdGV4dERpZmZUeXBlOiB0aGlzLnN0YWdpbmcudGV4dERpZmZUeXBlLFxuICAgIHdoaXRlU3BhY2U6IHRoaXMuc3RhZ2luZy53aGl0ZVNwYWNlLFxuICAgIGlzU2hvd2luZ0RpZmZzOiB0aGlzLmlzU2hvd2luZ0RpZmZzLFxuICAgIHBhdGNoTGluZUxpc3Q6IHRoaXMucGF0Y2hMaW5lTGlzdCxcbiAgICBlZGl0U3RhdGU6IHRoaXMuZWRpdFN0YXRlLFxuICAgIHdvcmRXcmFwOiB0aGlzLnN0YWdpbmcud29yZFdyYXBcbiAgfSk7XG59XG5GaWxlVmlld01vZGVsLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMuZGlzcGxheU5hbWUoc3RhdGUuZGlzcGxheU5hbWUpO1xuICB0aGlzLmlzTmV3KHN0YXRlLmlzTmV3KTtcbiAgdGhpcy5yZW1vdmVkKHN0YXRlLnJlbW92ZWQpO1xuICB0aGlzLmNvbmZsaWN0KHN0YXRlLmNvbmZsaWN0KTtcbiAgdGhpcy5yZW5hbWVkKHN0YXRlLnJlbmFtZWQpO1xuICB0aGlzLmZpbGVUeXBlKHN0YXRlLnR5cGUpO1xuICB0aGlzLmFkZGl0aW9ucyhzdGF0ZS5hZGRpdGlvbnMgIT0gJy0nID8gJysnICsgc3RhdGUuYWRkaXRpb25zIDogJycpO1xuICB0aGlzLmRlbGV0aW9ucyhzdGF0ZS5kZWxldGlvbnMgIT0gJy0nID8gJy0nICsgc3RhdGUuZGVsZXRpb25zIDogJycpO1xuICBpZiAodGhpcy5kaWZmKCkpIHtcbiAgICB0aGlzLmRpZmYoKS5pbnZhbGlkYXRlRGlmZigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGlmZih0aGlzLmdldFNwZWNpZmljRGlmZigpKTtcbiAgfVxuICBpZiAodGhpcy5kaWZmKCkuaXNOZXcpIHRoaXMuZGlmZigpLmlzTmV3KHN0YXRlLmlzTmV3KTtcbiAgaWYgKHRoaXMuZGlmZigpLmlzUmVtb3ZlZCkgdGhpcy5kaWZmKCkuaXNSZW1vdmVkKHN0YXRlLnJlbW92ZWQpO1xufVxuRmlsZVZpZXdNb2RlbC5wcm90b3R5cGUudG9nZ2xlU3RhZ2VkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmVkaXRTdGF0ZSgpID09PSAnbm9uZScpIHtcbiAgICB0aGlzLmVkaXRTdGF0ZSgnc3RhZ2VkJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lZGl0U3RhdGUoJ25vbmUnKTtcbiAgfVxuICB0aGlzLnBhdGNoTGluZUxpc3QoW10pO1xufVxuRmlsZVZpZXdNb2RlbC5wcm90b3R5cGUuZGlzY2FyZENoYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodW5naXQuY29uZmlnLmRpc2FibGVEaXNjYXJkV2FybmluZyB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuc3RhZ2luZy5tdXRlZFRpbWUgPCB1bmdpdC5jb25maWcuZGlzYWJsZURpc2NhcmRNdXRlVGltZSkge1xuICAgIHNlbGYuc2VydmVyLnBvc3RQcm9taXNlKCcvZGlzY2FyZGNoYW5nZXMnLCB7IHBhdGg6IHNlbGYuc3RhZ2luZy5yZXBvUGF0aCgpLCBmaWxlOiBzZWxmLm5hbWUoKSB9KVxuICAgICAgLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpO1xuICB9IGVsc2Uge1xuICAgIGNvbXBvbmVudHMuY3JlYXRlKCd5ZXNub211dGVkaWFsb2cnLCB7IHRpdGxlOiAnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRpc2NhcmQgdGhlc2UgY2hhbmdlcz8nLCBkZXRhaWxzOiAnVGhpcyBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4nfSlcbiAgICAgIC5zaG93KClcbiAgICAgIC5jbG9zZVRoZW4oZnVuY3Rpb24oZGlhZykge1xuICAgICAgICBpZiAoZGlhZy5yZXN1bHQoKSkge1xuICAgICAgICAgIHNlbGYuc2VydmVyLnBvc3RQcm9taXNlKCcvZGlzY2FyZGNoYW5nZXMnLCB7IHBhdGg6IHNlbGYuc3RhZ2luZy5yZXBvUGF0aCgpLCBmaWxlOiBzZWxmLm5hbWUoKSB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWFnLnJlc3VsdCgpID09PSBcIm11dGVcIikgc2VsZi5zdGFnaW5nLm11dGVkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgfSk7XG4gIH1cbn1cbkZpbGVWaWV3TW9kZWwucHJvdG90eXBlLmlnbm9yZUZpbGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL2lnbm9yZWZpbGUnLCB7IHBhdGg6IHRoaXMuc3RhZ2luZy5yZXBvUGF0aCgpLCBmaWxlOiB0aGlzLm5hbWUoKSB9KVxuICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIuZXJyb3JDb2RlID09ICdmaWxlLWFscmVhZHktZ2l0LWlnbm9yZWQnKSB7XG4gICAgICAgIC8vIFRoZSBmaWxlIHdhcyBhbHJlYWR5IGluIHRoZSAuZ2l0aWdub3JlLCBzbyBmb3JjZSBhbiB1cGRhdGUgb2YgdGhlIHN0YWdpbmcgYXJlYSAodG8gaG9wZWZ1bGx5IGNsZWFyIGF3YXkgdGhpcyBmaWxlKVxuICAgICAgICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICd3b3JraW5nLXRyZWUtY2hhbmdlZCcgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbn1cbkZpbGVWaWV3TW9kZWwucHJvdG90eXBlLnJlc29sdmVDb25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL3Jlc29sdmVjb25mbGljdHMnLCB7IHBhdGg6IHRoaXMuc3RhZ2luZy5yZXBvUGF0aCgpLCBmaWxlczogW3RoaXMubmFtZSgpXSB9KVxuICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKTtcbn1cbkZpbGVWaWV3TW9kZWwucHJvdG90eXBlLmxhdW5jaE1lcmdlVG9vbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL2xhdW5jaG1lcmdldG9vbCcsIHsgcGF0aDogdGhpcy5zdGFnaW5nLnJlcG9QYXRoKCksIGZpbGU6IHRoaXMubmFtZSgpLCB0b29sOiBtZXJnZVRvb2wgfSlcbiAgICAuY2F0Y2goKGUpID0+IHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSk7XG59XG5GaWxlVmlld01vZGVsLnByb3RvdHlwZS50b2dnbGVEaWZmcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5yZW5hbWVkKCkpIHJldHVybjsgLy8gZG8gbm90IHNob3cgZGlmZnMgZm9yIHJlbmFtZXNcbiAgdGhpcy5pc1Nob3dpbmdEaWZmcyghdGhpcy5pc1Nob3dpbmdEaWZmcygpKTtcbn1cbkZpbGVWaWV3TW9kZWwucHJvdG90eXBlLnBhdGNoQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmlzU2hvd2luZ0RpZmZzKCkpIHJldHVybjtcblxuICBpZiAodGhpcy5lZGl0U3RhdGUoKSA9PT0gJ3BhdGNoZWQnKSB7XG4gICAgdGhpcy5lZGl0U3RhdGUoJ3N0YWdlZCcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZWRpdFN0YXRlKCdwYXRjaGVkJyk7XG4gIH1cbn1cbiJdfQ==

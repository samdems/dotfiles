(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var ko = require('knockout');
require('mina');

module.exports = function(graph) {
  var self = this;
  this.element = ko.observable();
  this.previousGraph = undefined;
  this.element.subscribe(function(val) {
    if (val) self.animate(true);
  });
  this.animate = function(forceRefresh) {
    var currentGraph = this.getGraphAttr();
    // animate only when dom is valid and (attribute changed or force refresh due to dom change)
    if (this.element() && (forceRefresh || JSON.stringify(currentGraph) !== JSON.stringify(this.previousGraph))) {
      var now = Date.now();
      window.mina(this.previousGraph || currentGraph, currentGraph, now, now + 750, window.mina.time, function (val) {
        self.setGraphAttr(val);
      }, window.mina.elastic);
      this.previousGraph = currentGraph;
    }
  }
};

},{"knockout":"knockout","mina":undefined}],2:[function(require,module,exports){
var ko = require('knockout');
var Animateable = require('./animateable');

var EdgeViewModel = function(graph, nodeAsha1, nodeBsha1) {
  var self = this;
  Animateable.call(this);
  this.nodeA = graph.getNode(nodeAsha1);
  this.nodeB = graph.getNode(nodeBsha1);
  this.getGraphAttr = ko.computed(function() {
    if (self.nodeA.isViewable() && (!self.nodeB.isViewable() || !self.nodeB.isInited)) {
      return [self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy(),
              self.nodeA.cx(), graph.graphHeight(), self.nodeA.cx(), graph.graphHeight()];
    } else if (self.nodeB.isInited && self.nodeB.cx() && self.nodeB.cy()) {
      return [self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy(),
              self.nodeB.cx(), self.nodeB.cy(), self.nodeB.cx(), self.nodeB.cy()];
    } else {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
  });
  this.getGraphAttr.subscribe(this.animate.bind(this));
}
EdgeViewModel.prototype.setGraphAttr = function(val) {
  this.element().setAttribute('d', 'M' + val.slice(0,4).join(',') + 'L' + val.slice(4,8).join(','));
}
EdgeViewModel.prototype.edgeMouseOver = function() {
  if (this.nodeA) {
    this.nodeA.isEdgeHighlighted(true);
  }
  if (this.nodeB) {
    this.nodeB.isEdgeHighlighted(true);
  }
}
EdgeViewModel.prototype.edgeMouseOut = function() {
  if (this.nodeA) {
    this.nodeA.isEdgeHighlighted(false);
  }
  if (this.nodeB) {
    this.nodeB.isEdgeHighlighted(false);
  }
}
module.exports = EdgeViewModel;

},{"./animateable":1,"knockout":"knockout"}],3:[function(require,module,exports){

var ko = require('knockout');
var inherits = require('util').inherits;
var components = require('ungit-components');
var Promise = require('bluebird');
var RefViewModel = require('./git-ref.js');
var HoverActions = require('./hover-actions');
var programEvents = require('ungit-program-events');
var RebaseViewModel = HoverActions.RebaseViewModel;
var MergeViewModel = HoverActions.MergeViewModel;
var ResetViewModel = HoverActions.ResetViewModel;
var PushViewModel = HoverActions.PushViewModel;
var SquashViewModel = HoverActions.SquashViewModel;

var GraphActions = {};
module.exports = GraphActions;

GraphActions.ActionBase = function(graph) {
  this.graph = graph;
  this.server = graph.server;
  this.isRunning = ko.observable(false);
  this.isHighlighted = ko.computed(() => {
    return !graph.hoverGraphAction() || graph.hoverGraphAction() == this;
  });
  this.cssClasses = ko.computed(() => {
    if (!this.isHighlighted() || this.isRunning()) {
      return `${this.style} dimmed`
    } else {
      return this.style
    }
  })
}
GraphActions.ActionBase.prototype.icon = null;
GraphActions.ActionBase.prototype.doPerform = function() {
  if (this.isRunning()) return;
  this.graph.hoverGraphAction(null);
  this.isRunning(true);
  return this.perform()
    .catch((e) => this.server.unhandledRejection(e))
    .finally(() => { this.isRunning(false); });
}
GraphActions.ActionBase.prototype.dragEnter = function() {
  if (!this.visible()) return;
  this.graph.hoverGraphAction(this);
}
GraphActions.ActionBase.prototype.dragLeave = function() {
  if (!this.visible()) return;
  this.graph.hoverGraphAction(null);
}
GraphActions.ActionBase.prototype.mouseover = function() {
  this.graph.hoverGraphAction(this);
}
GraphActions.ActionBase.prototype.mouseout = function() {
  this.graph.hoverGraphAction(null);
}

GraphActions.Move = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.isRunning()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Move, GraphActions.ActionBase);
GraphActions.Move.prototype.text = 'Move';
GraphActions.Move.prototype.style = 'move';
GraphActions.Move.prototype.icon = 'glyphicon glyphicon-move';
GraphActions.Move.prototype.perform = function() {
  return this.graph.currentActionContext().moveTo(this.node.sha1);
}

GraphActions.Reset = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.isRunning()) return true;
    if (!(self.graph.currentActionContext() instanceof RefViewModel)) return false;
    var context = self.graph.currentActionContext();
    if (context.node() != self.node) return false;
    var remoteRef = context.getRemoteRef(self.graph.currentRemote());
    return remoteRef && remoteRef.node() &&
      context && context.node() &&
      remoteRef.node() != context.node() &&
      remoteRef.node().date < context.node().date;
  });
}
inherits(GraphActions.Reset, GraphActions.ActionBase);
GraphActions.Reset.prototype.text = 'Reset';
GraphActions.Reset.prototype.style = 'reset';
GraphActions.Reset.prototype.icon = 'glyphicon glyphicon-trash';
GraphActions.Reset.prototype.createHoverGraphic = function() {
  var context = this.graph.currentActionContext();
  if (!context) return null;
  var remoteRef = context.getRemoteRef(this.graph.currentRemote());
  var nodes = context.node().getPathToCommonAncestor(remoteRef.node()).slice(0, -1);
  return new ResetViewModel(nodes);
}
GraphActions.Reset.prototype.perform = function() {
  var self = this;
  var context = this.graph.currentActionContext();
  var remoteRef = context.getRemoteRef(self.graph.currentRemote());
  return components.create('yesnodialog', { title: 'Are you sure?', details: 'Resetting to ref: ' + remoteRef.name + ' cannot be undone with ungit.'})
    .show()
    .closeThen(function(diag) {
      if (!diag.result()) return;
      return self.server.postPromise('/reset', { path: self.graph.repoPath(), to: remoteRef.name, mode: 'hard' })
        .then(function() { context.node(remoteRef.node()); });
    }).closePromise;
}

GraphActions.Rebase = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.isRunning()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      (!ungit.config.showRebaseAndMergeOnlyOnRefs || self.node.refs().length > 0) &&
      self.graph.currentActionContext().current() &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Rebase, GraphActions.ActionBase);
GraphActions.Rebase.prototype.text = 'Rebase';
GraphActions.Rebase.prototype.style = 'rebase';
GraphActions.Rebase.prototype.icon = 'octicon octicon-repo-forked flip';
GraphActions.Rebase.prototype.createHoverGraphic = function() {
  var onto = this.graph.currentActionContext();
  if (!onto) return;
  if (onto instanceof RefViewModel) onto = onto.node();
  var path = onto.getPathToCommonAncestor(this.node);
  return new RebaseViewModel(this.node, path);
}
GraphActions.Rebase.prototype.perform = function() {
  return this.server.postPromise('/rebase', { path: this.graph.repoPath(), onto: this.node.sha1 })
    .catch((err) => { if (err.errorCode != 'merge-failed') this.server.unhandledRejection(err); })
}

GraphActions.Merge = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.isRunning()) return true;
    if (!self.graph.checkedOutRef() || !self.graph.checkedOutRef().node()) return false;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      !self.graph.currentActionContext().current() &&
      self.graph.checkedOutRef().node() == self.node;
  });
}
inherits(GraphActions.Merge, GraphActions.ActionBase);
GraphActions.Merge.prototype.text = 'Merge';
GraphActions.Merge.prototype.style = 'merge';
GraphActions.Merge.prototype.icon = 'octicon octicon-git-merge';
GraphActions.Merge.prototype.createHoverGraphic = function() {
  var node = this.graph.currentActionContext();
  if (!node) return null;
  if (node instanceof RefViewModel) node = node.node();
  return new MergeViewModel(this.graph, this.node, node);
}
GraphActions.Merge.prototype.perform = function() {
  return this.server.postPromise('/merge', { path: this.graph.repoPath(), with: this.graph.currentActionContext().localRefName })
    .catch((err) => { if (err.errorCode != 'merge-failed') this.server.unhandledRejection(err); })
}

GraphActions.Push = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.isRunning()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() == self.node &&
      self.graph.currentActionContext().canBePushed(self.graph.currentRemote());
  });
}
inherits(GraphActions.Push, GraphActions.ActionBase);
GraphActions.Push.prototype.text = 'Push';
GraphActions.Push.prototype.style = 'push';
GraphActions.Push.prototype.icon = 'octicon octicon-cloud-upload';
GraphActions.Push.prototype.createHoverGraphic = function() {
  var context = this.graph.currentActionContext();
  if (!context) return null;
  var remoteRef = context.getRemoteRef(this.graph.currentRemote());
  if (!remoteRef) return null;
  return new PushViewModel(remoteRef.node(), context.node());
}
GraphActions.Push.prototype.perform = function() {
  var ref = this.graph.currentActionContext();
  var remoteRef = ref.getRemoteRef(this.graph.currentRemote());

  if (remoteRef) {
    return remoteRef.moveTo(ref.node().sha1);
  } else {
    return ref.createRemoteRef()
      .then(() => {
        if (this.graph.HEAD().name == ref.name) {
          this.grah.HEADref().node(ref.node());
        }
      }).finally(() => programEvents.dispatch({ event: 'request-fetch-tags' }));
  }
}

GraphActions.Checkout = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.isRunning()) return true;
    if (self.graph.currentActionContext() instanceof RefViewModel)
      return self.graph.currentActionContext().node() == self.node &&
        !self.graph.currentActionContext().current();
    return ungit.config.allowCheckoutNodes &&
      self.graph.currentActionContext() == self.node;
  });
}
inherits(GraphActions.Checkout, GraphActions.ActionBase);
GraphActions.Checkout.prototype.text = 'Checkout';
GraphActions.Checkout.prototype.style = 'checkout';
GraphActions.Checkout.prototype.icon = 'octicon octicon-desktop-download';
GraphActions.Checkout.prototype.perform = function() {
  return this.graph.currentActionContext().checkout();
}

GraphActions.Delete = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.isRunning()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() == self.node &&
      !self.graph.currentActionContext().current();
  });
}
inherits(GraphActions.Delete, GraphActions.ActionBase);
GraphActions.Delete.prototype.text = 'Delete';
GraphActions.Delete.prototype.style = 'delete';
GraphActions.Delete.prototype.icon = 'glyphicon glyphicon-remove';
GraphActions.Delete.prototype.perform = function() {
  const context = this.graph.currentActionContext();
  let details = `"${context.refName}"`;
  if (context.isRemoteBranch) {
    details = `<code style='font-size: 100%'>REMOTE</code> ${details}`;
  }
  details = `Deleting ${details} branch or tag cannot be undone with ungit.`;

  return components.create('yesnodialog', { title: 'Are you sure?', details: details })
    .show()
    .closeThen((diag) => {
      if (diag.result()) return context.remove();
    }).closePromise;
}

GraphActions.CherryPick = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.isRunning()) return true;
    var context = self.graph.currentActionContext();
    return context === self.node && self.graph.HEAD() && context.sha1 !== self.graph.HEAD().sha1
  });
}
inherits(GraphActions.CherryPick, GraphActions.ActionBase);
GraphActions.CherryPick.prototype.text = 'Cherry pick';
GraphActions.CherryPick.prototype.style = 'cherry-pick';
GraphActions.CherryPick.prototype.icon = 'octicon octicon-circuit-board';
GraphActions.CherryPick.prototype.perform = function() {
  var self = this;
  return this.server.postPromise('/cherrypick', { path: this.graph.repoPath(), name: this.node.sha1 })
    .catch(function(err) { if (err.errorCode != 'merge-failed') self.server.unhandledRejection(err); })
}

GraphActions.Uncommit = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.isRunning()) return true;
    return self.graph.currentActionContext() == self.node &&
      self.graph.HEAD() == self.node;
  });
}
inherits(GraphActions.Uncommit, GraphActions.ActionBase);
GraphActions.Uncommit.prototype.text = 'Uncommit';
GraphActions.Uncommit.prototype.style = 'uncommit';
GraphActions.Uncommit.prototype.icon = 'octicon octicon-zap';
GraphActions.Uncommit.prototype.perform = function() {
  var self = this;
  return this.server.postPromise('/reset', { path: this.graph.repoPath(), to: 'HEAD^', mode: 'mixed' })
    .then(function() {
      var targetNode = self.node.belowNode;
      while (targetNode && !targetNode.ancestorOfHEAD()) {
        targetNode = targetNode.belowNode;
      }
      self.graph.HEADref().node(targetNode ? targetNode : null);
      self.graph.checkedOutRef().node(targetNode ? targetNode : null);
    });
}

GraphActions.Revert = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.isRunning()) return true;
    return self.graph.currentActionContext() == self.node;
  });
}
inherits(GraphActions.Revert, GraphActions.ActionBase);
GraphActions.Revert.prototype.text = 'Revert';
GraphActions.Revert.prototype.style = 'revert';
GraphActions.Revert.prototype.icon = 'octicon octicon-history';
GraphActions.Revert.prototype.perform = function() {
  var self = this;
  return this.server.postPromise('/revert', { path: this.graph.repoPath(), commit: this.node.sha1 });
}

GraphActions.Squash = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.isRunning()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().current() &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Squash, GraphActions.ActionBase);
GraphActions.Squash.prototype.text = 'Squash';
GraphActions.Squash.prototype.style = 'squash';
GraphActions.Squash.prototype.icon = 'octicon octicon-fold';
GraphActions.Squash.prototype.createHoverGraphic = function() {
  let onto = this.graph.currentActionContext();
  if (!onto) return;
  if (onto instanceof RefViewModel) onto = onto.node();

  return new SquashViewModel(this.node, onto);
}
GraphActions.Squash.prototype.perform = function() {
  let onto = this.graph.currentActionContext();
  if (!onto) return;
  if (onto instanceof RefViewModel) onto = onto.node();
  // remove last element as it would be a common ancestor.
  const path = this.node.getPathToCommonAncestor(onto).slice(0, -1);

  if (path.length > 0) {
    // squashing branched out lineage
    // c is checkout with squash target of e, results in staging changes
    // from d and e on top of c
    //
    // a - b - (c)        a - b - (c) - [de]
    //  \           ->     \
    //   d  - <e>           d - <e>
    return this.server.postPromise('/squash', { path: this.graph.repoPath(), target: this.node.sha1 });
  } else {
    // squashing backward from same lineage
    // c is checkout with squash target of a, results in current ref moved
    // to a and staging changes within b and c on top of a
    //
    // <a> - b - (c)       (a) - b - c
    //                ->     \
    //                        [bc]
    return this.graph.currentActionContext().moveTo(this.node.sha1, true)
      .then(() => this.server.postPromise('/squash', { path: this.graph.repoPath(), target: onto.sha1 }))
  }
}

},{"./git-ref.js":5,"./hover-actions":7,"bluebird":undefined,"knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events","util":undefined}],4:[function(require,module,exports){
const $ = require('jquery');
const ko = require('knockout');
const components = require('ungit-components');
const Selectable = require('./selectable');
const Animateable = require('./animateable');
const programEvents = require('ungit-program-events');
const GraphActions = require('./git-graph-actions');

const maxBranchesToDisplay = parseInt(ungit.config.numRefsToShow / 5 * 3);  // 3/5 of refs to show to branches
const maxTagsToDisplay = ungit.config.numRefsToShow - maxBranchesToDisplay; // 2/5 of refs to show to tags

var GitNodeViewModel = function(graph, sha1) {
  var self = this;
  Selectable.call(this, graph);
  Animateable.call(this);
  this.graph = graph;
  this.sha1 = sha1;
  this.isInited = false;
  this.title = undefined;
  this.parents = ko.observableArray();
  this.commitTime = undefined; // commit time in string
  this.date = undefined;       // commit time in numeric format for sort
  this.color = ko.observable();
  this.ideologicalBranch = ko.observable();
  this.remoteTags = ko.observableArray();
  this.branchesAndLocalTags = ko.observableArray();
  this.signatureDate = ko.observable();
  this.signatureMade = ko.observable();
  this.pgpVerifiedString = ko.computed(function() {
    if (self.signatureMade()) {
      return `PGP by: ${self.signatureMade()} at ${self.signatureDate()}`
    }
  });

  this.refs = ko.computed(function() {
    var rs = self.branchesAndLocalTags().concat(self.remoteTags());
    rs.sort(function(a, b) {
      if (b.current()) return 1;
      if (a.current()) return -1;
      if (a.isLocal && !b.isLocal) return -1;
      if (!a.isLocal && b.isLocal) return 1;
      return a.refName < b.refName ? -1 : 1;
    });
    return rs;
  });
  // These are split up like this because branches and local tags can be found in the git log,
  // whereas remote tags needs to be fetched with another command (which is much slower)
  this.branches = ko.observableArray();
  this.branchesToDisplay = ko.observableArray();
  this.tags = ko.observableArray();
  this.tagsToDisplay = ko.observableArray();
  this.refs.subscribe((newValue) => {
    if (newValue) {
      this.branches(newValue.filter((r) => r.isBranch));
      this.tags(newValue.filter((r) => r.isTag));
      this.tagsToDisplay(this.tags.slice(0, maxTagsToDisplay));
      this.branchesToDisplay(this.branches.slice(0, ungit.config.numRefsToShow - this.tagsToDisplay().length));
    } else {
      this.branches.removeAll();
      this.tags.removeAll();
      this.branchesToDisplay.removeAll();
      this.tagsToDisplay.removeAll();
    }
  });
  this.ancestorOfHEAD = ko.observable(false);
  this.nodeIsMousehover = ko.observable(false);
  this.commitContainerVisible = ko.computed(function() {
    return self.ancestorOfHEAD() || self.nodeIsMousehover() || self.selected();
  });
  this.isEdgeHighlighted = ko.observable(false);
  // for small empty black circle to highlight a node
  this.isNodeAccented = ko.computed(function() {
    return self.selected() || self.isEdgeHighlighted();
  });
  // to show changed files and diff boxes on the left of node
  this.highlighted = ko.computed(function() {
    return self.nodeIsMousehover() || self.selected();
  });
  this.selected.subscribe(function() {
    programEvents.dispatch({ event: 'graph-render' });
  });
  this.showNewRefAction = ko.computed(function() {
    return !graph.currentActionContext();
  });
  this.newBranchName = ko.observable();
  this.newBranchNameHasFocus = ko.observable(true);
  this.branchingFormVisible = ko.observable(false);
  this.newBranchNameHasFocus.subscribe(function(newValue) {
    if (!newValue) {
      // Small timeout because in ff the form is hidden before the submit click event is registered otherwise
      setTimeout(function() {
        self.branchingFormVisible(false);
      }, 200);
    }
  });
  this.canCreateRef = ko.computed(function() {
    return self.newBranchName() && self.newBranchName().trim() && self.newBranchName().indexOf(' ') == -1;
  });
  this.branchOrder = ko.observable();
  this.aboveNode = undefined;
  this.belowNode = undefined;
  this.refSearchFormVisible = ko.observable(false);
  this.commitComponent = components.create('commit', this);
  this.r = ko.observable();
  this.cx = ko.observable();
  this.cy = ko.observable();

  this.dropareaGraphActions = [
    new GraphActions.Move(this.graph, this),
    new GraphActions.Rebase(this.graph, this),
    new GraphActions.Merge(this.graph, this),
    new GraphActions.Push(this.graph, this),
    new GraphActions.Reset(this.graph, this),
    new GraphActions.Checkout(this.graph, this),
    new GraphActions.Delete(this.graph, this),
    new GraphActions.CherryPick(this.graph, this),
    new GraphActions.Uncommit(this.graph, this),
    new GraphActions.Revert(this.graph, this),
    new GraphActions.Squash(this.graph, this)
  ];
}
module.exports = GitNodeViewModel;

GitNodeViewModel.prototype.getGraphAttr = function() {
  return [this.cx(), this.cy()];
}
GitNodeViewModel.prototype.setGraphAttr = function(val) {
  this.element().setAttribute('x', val[0] - 30);
  this.element().setAttribute('y', val[1] - 30);
}
GitNodeViewModel.prototype.render = function() {
  this.refSearchFormVisible(false);
  if (!this.isInited) return;
  if (this.ancestorOfHEAD()) {
    this.r(30);
    this.cx(610);

    if (!this.aboveNode) {
      this.cy(120);
    } else if (this.aboveNode.ancestorOfHEAD()) {
      this.cy(this.aboveNode.cy() + 120);
    } else {
      this.cy(this.aboveNode.cy() + 60);
    }
  } else {
    this.r(15);
    this.cx(610 + (90 * this.branchOrder()));
    this.cy(this.aboveNode ? this.aboveNode.cy() + 60 : 120);
  }

  if (this.aboveNode && this.aboveNode.selected()) {
    this.cy(this.aboveNode.cy() + this.aboveNode.commitComponent.element().offsetHeight + 30);
  }

  this.color(this.ideologicalBranch() ? this.ideologicalBranch().color : '#666');
  this.animate();
}
GitNodeViewModel.prototype.setData = function(logEntry) {
  var self = this;
  this.title = logEntry.message.split('\n')[0];
  this.parents(logEntry.parents || []);
  this.commitTime = logEntry.commitDate;
  this.date = Date.parse(this.commitTime);
  this.commitComponent.setData(logEntry);
  this.signatureMade(logEntry.signatureMade);
  this.signatureDate(logEntry.signatureDate);

  (logEntry.refs || []).forEach(function(ref) {
    self.graph.getRef(ref).node(self);
  });
  this.isInited = true;
}
GitNodeViewModel.prototype.showBranchingForm = function() {
  this.branchingFormVisible(true);
  this.newBranchNameHasFocus(true);
}
GitNodeViewModel.prototype.showRefSearchForm = function(obj, event) {
  const self = this;
  this.refSearchFormVisible(true);

  const textBox = event.target.nextElementSibling.firstElementChild; // this may not be the best idea...
  $(textBox).autocomplete({
    source: this.refs().filter(ref => !ref.isHEAD),
    minLength: 0,
    select: function(event, ui) {
      const ref = ui.item;
      const ray = ref.isTag ? self.tagsToDisplay : self.branchesToDisplay;

      // if ref is in display, remove it, else remove last in array.
      ray.splice(ray.indexOf(ref), 1);
      ray.unshift(ref);
      self.refSearchFormVisible(false);
    },
    messages: {
      noResults: '',
      results: () => {}
    }
  }).focus(function() {
    $(this).autocomplete('search', $(this).val());
  }).data("ui-autocomplete")._renderItem = function (ul, item) {
    return $("<li></li>")
      .append(`<a>${item.dom}</a>`)
      .appendTo(ul);
  }
  $(textBox).autocomplete('search', '');
}
GitNodeViewModel.prototype.createBranch = function() {
  if (!this.canCreateRef()) return;
  this.graph.server.postPromise("/branches", { path: this.graph.repoPath(), name: this.newBranchName(), sha1: this.sha1 })
    .then(() => {
      this.graph.getRef('refs/heads/' + this.newBranchName()).node(this)
      if (ungit.config.autoCheckoutOnBranchCreate) {
        return this.graph.server.postPromise("/checkout", { path: this.graph.repoPath(), name: this.newBranchName() })
      }
    }).catch((e) => this.graph.server.unhandledRejection(e))
    .finally(() => {
      this.branchingFormVisible(false);
      this.newBranchName('');
      programEvents.dispatch({ event: 'branch-updated' });
    });
}
GitNodeViewModel.prototype.createTag = function() {
  if (!this.canCreateRef()) return;
  this.graph.server.postPromise('/tags', { path: this.graph.repoPath(), name: this.newBranchName(), sha1: this.sha1 })
    .then(() => this.graph.getRef('refs/tags/' + this.newBranchName()).node(this) )
    .catch((e) => this.graph.server.unhandledRejection(e))
    .finally(() => {
      this.branchingFormVisible(false);
      this.newBranchName('');
    });
}
GitNodeViewModel.prototype.toggleSelected = function() {
  var self = this;
  var beforeThisCR = this.commitComponent.element().getBoundingClientRect();
  var beforeBelowCR = null;
  if (this.belowNode) {
    beforeBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
  }

  var prevSelected  = this.graph.currentActionContext();
  if (!(prevSelected instanceof GitNodeViewModel)) prevSelected = null;
  var prevSelectedCR = prevSelected ? prevSelected.commitComponent.element().getBoundingClientRect() : null;
  this.selected(!this.selected());

  // If we are deselecting
  if (!this.selected()) {
    if (beforeThisCR.top < 0 && beforeBelowCR) {
      var afterBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
      // If the next node is showing, try to keep it in the screen (no jumping)
      if (beforeBelowCR.top < window.innerHeight) {
        window.scrollBy(0, afterBelowCR.top - beforeBelowCR.top);
      // Otherwise just try to bring them to the middle of the screen
      } else {
        window.scrollBy(0, afterBelowCR.top - window.innerHeight / 2);
      }
    }
  // If we are selecting
  } else {
    var afterThisCR = this.commitComponent.element().getBoundingClientRect();
    if ((prevSelectedCR && (prevSelectedCR.top < 0 || prevSelectedCR.top > window.innerHeight)) &&
      afterThisCR.top != beforeThisCR.top) {
      window.scrollBy(0, -(beforeThisCR.top - afterThisCR.top));
      console.log('Fix');
    }
  }
  return false;
}
GitNodeViewModel.prototype.removeRef = function(ref) {
  if (ref.isRemoteTag) {
    this.remoteTags.remove(ref);
  } else {
    this.branchesAndLocalTags.remove(ref);
  }
}
GitNodeViewModel.prototype.pushRef = function(ref) {
  if (ref.isRemoteTag && this.remoteTags.indexOf(ref) < 0) {
    this.remoteTags.push(ref);
  } else if(this.branchesAndLocalTags.indexOf(ref) < 0) {
    this.branchesAndLocalTags.push(ref);
  }
}
GitNodeViewModel.prototype.getPathToCommonAncestor = function(node) {
  var path = [];
  var thisNode = this;
  while (thisNode && !node.isAncestor(thisNode)) {
    path.push(thisNode);
    thisNode = this.graph.nodesById[thisNode.parents()[0]];
  }
  if (thisNode) path.push(thisNode);
  return path;
}
GitNodeViewModel.prototype.isAncestor = function(node) {
  if (node == this) return true;
  for (var v in this.parents()) {
    var n = this.graph.nodesById[this.parents()[v]];
    if (n && n.isAncestor(node)) return true;
  }
  return false;
}
GitNodeViewModel.prototype.getRightToLeftStrike = function() {
  return 'M ' + (this.cx() - 30) + ' ' + (this.cy() - 30) + ' L ' + (this.cx() + 30) + ' ' + (this.cy() + 30);
}
GitNodeViewModel.prototype.getLeftToRightStrike = function() {
  return 'M ' + (this.cx() + 30) + ' ' + (this.cy() - 30) + ' L ' + (this.cx() - 30) + ' ' + (this.cy() + 30);
}
GitNodeViewModel.prototype.nodeMouseover = function() {
  this.nodeIsMousehover(true);
}
GitNodeViewModel.prototype.nodeMouseout = function() {
  this.nodeIsMousehover(false);
}
GitNodeViewModel.prototype.isViewable = function() {
  return this.graph.nodes().indexOf(this) > -1;
}

},{"./animateable":1,"./git-graph-actions":3,"./selectable":8,"jquery":undefined,"knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],5:[function(require,module,exports){
var ko = require('knockout');
var md5 = require('blueimp-md5');
var Selectable = require('./selectable');
var programEvents = require('ungit-program-events');
var components = require('ungit-components');
var Promise = require('bluebird');

var RefViewModel = function(fullRefName, graph) {
  var self = this;
  Selectable.call(this, graph);
  this.graph = graph;
  this.name = fullRefName;
  this.node = ko.observable();
  this.localRefName = this.name; // origin/master or master
  this.refName = this.name; // master
  this.isRemoteTag = this.name.indexOf('remote-tag: ') == 0;
  this.isLocalTag = this.name.indexOf('tag: ') == 0;
  this.isTag = this.isLocalTag || this.isRemoteTag;
  var isRemoteBranchOrHEAD = this.name.indexOf('refs/remotes/') == 0;
  this.isLocalHEAD = this.name == 'HEAD';
  this.isRemoteHEAD = this.name.indexOf('/HEAD') != -1;
  this.isLocalBranch = this.name.indexOf('refs/heads/') == 0;
  this.isRemoteBranch = isRemoteBranchOrHEAD && !this.isRemoteHEAD;
  this.isStash = this.name.indexOf('refs/stash') == 0;
  this.isHEAD = this.isLocalHEAD || this.isRemoteHEAD;
  this.isBranch = this.isLocalBranch || this.isRemoteBranch;
  this.isRemote = isRemoteBranchOrHEAD || this.isRemoteTag;
  this.isLocal = this.isLocalBranch || this.isLocalTag;
  if (this.isLocalBranch) {
    this.localRefName = this.name.slice('refs/heads/'.length);
    this.refName = this.localRefName;
  }
  if (this.isRemoteBranch) {
    this.localRefName = this.name.slice('refs/remotes/'.length);
  }
  if (this.isLocalTag) {
    this.localRefName = this.name.slice('tag: refs/tags/'.length);
    this.refName = this.localRefName;
  }
  if (this.isRemoteTag) {
    this.localRefName = this.name.slice('remote-tag: '.length);
  }
  const splitedName = this.localRefName.split('/')
  if (this.isRemote) {
    // get rid of the origin/ part of origin/branchname
    this.remote = splitedName[0];
    this.refName = splitedName.slice(1).join('/');
  }
  this.show = true;
  this.server = this.graph.server;
  this.isDragging = ko.observable(false);
  this.current = ko.computed(function() {
    return self.isLocalBranch && self.graph.checkedOutBranch() == self.refName;
  });
  this.color = this._colorFromHashOfString(this.name);

  this.node.subscribe(function(oldNode) {
    if (oldNode) oldNode.removeRef(self);
  }, null, "beforeChange");
  this.node.subscribe(function(newNode) {
    if (newNode) newNode.pushRef(self);
  });

  // This optimization is for autocomplete display
  this.value = splitedName[splitedName.length - 1]
  this.label = this.localRefName
  this.dom = `${this.localRefName}<span class='octicon ${this.isTag ? 'octicon-tag' : 'octicon-git-branch'}'></span>`
  this.displayName = ko.computed(function() {
    var prefix = ''
    if (self.isRemote) {
      prefix = '<span class="octicon octicon-broadcast"></span> ';
    }
    if (self.isBranch) {
      prefix += '<span class="octicon octicon-git-branch"></span> ';
    } else if (self.current()) {
      prefix += '<span class="octicon octicon-chevron-right"></span> ';
    } else if (self.isTag) {
      prefix += '<span class="octicon octicon-tag"></span> ';
    }
    return prefix + self.localRefName;
  });
};
module.exports = RefViewModel;

RefViewModel.prototype._colorFromHashOfString = function(string) {
  return '#' + md5(string).toString().slice(0, 6);
}
RefViewModel.prototype.dragStart = function() {
  this.graph.currentActionContext(this);
  this.isDragging(true);
  if (document.activeElement) document.activeElement.blur();
}
RefViewModel.prototype.dragEnd = function() {
  this.graph.currentActionContext(null);
  this.isDragging(false);
}
RefViewModel.prototype.moveTo = function(target, rewindWarnOverride) {
  var self = this;
  var promise;
  if (this.isLocal) {
    var toNode = this.graph.nodesById[target];
    var args = { path: self.graph.repoPath(), name: self.refName, sha1: target, force: true, to: target, mode: 'hard' };
    var operation;
    if (this.current()) {
      operation = '/reset';
    } else if (this.isTag) {
      operation = '/tags';
    } else {
      operation = '/branches';
    }

    if (!rewindWarnOverride && this.node().date > toNode.date) {
      promise = components.create('yesnodialog', { title: 'Are you sure?', details: 'This operation potentially going back in history.'})
        .show()
        .closeThen(function(diag) {
          if (diag.result()) {
            return self.server.postPromise(operation, args);
          }
        }).closePromise;
    } else {
      promise = self.server.postPromise(operation, args);
    }
  } else {
    var pushReq = { path: this.graph.repoPath(), remote: this.remote, refSpec: target, remoteBranch: this.refName };
    promise = this.server.postPromise('/push', pushReq)
      .catch(function(err) {
        if (err.errorCode === 'non-fast-forward') {
          return components.create('yesnodialog', { title: 'Force push?', details: 'The remote branch can\'t be fast-forwarded.' })
            .show()
            .closeThen(function(diag) {
              if (!diag.result()) return false;
              pushReq.force = true;
              return self.server.postPromise('/push', pushReq);
            }).closePromise;
        } else {
          self.server.unhandledRejection(err);
        }
      });
  }

  return promise
    .then(function(res) {
      if (!res) return;
      var targetNode = self.graph.getNode(target);
      if (self.graph.checkedOutBranch() == self.refName) {
        self.graph.HEADref().node(targetNode);
      }
      self.node(targetNode);
    }).catch((e) => this.server.unhandledRejection(e));
}

RefViewModel.prototype.remove = function(isClientOnly) {
  var self = this;
  var url = this.isTag ? '/tags' : '/branches';
  if (this.isRemote) url = '/remote' + url;

  return (isClientOnly ? Promise.resolve() : this.server.delPromise(url, { path: this.graph.repoPath(), remote: this.isRemote ? this.remote : null, name: this.refName }))
    .then(() => {
      if (this.node()) this.node().removeRef(self);
      this.graph.refs.remove(self);
      delete this.graph.refsByRefName[self.name];
    }).catch((e) => this.server.unhandledRejection(e))
    .finally(() => {
      if (!isClientOnly) {
        if (url == '/remote/tags') {
          programEvents.dispatch({ event: 'request-fetch-tags' });
        } else {
          programEvents.dispatch({ event: 'branch-updated' });
        }
      }
    });
}

RefViewModel.prototype.getLocalRef = function() {
  return this.graph.getRef(this.getLocalRefFullName(), false);
}
RefViewModel.prototype.getLocalRefFullName = function() {
  if (this.isRemoteBranch) return 'refs/heads/' + this.refName;
  if (this.isRemoteTag) return 'tag: ' + this.refName;
  return null;
}

RefViewModel.prototype.getRemoteRef = function(remote) {
  return this.graph.getRef(this.getRemoteRefFullName(remote), false);
}

RefViewModel.prototype.getRemoteRefFullName = function(remote) {
  if (this.isLocalBranch) return 'refs/remotes/' + remote + '/' + this.refName;
  if (this.isLocalTag) return 'remote-tag: ' + remote + '/' + this.refName;
  return null;
}

RefViewModel.prototype.canBePushed = function(remote) {
  if (!this.isLocal) return false;
  if (!remote) return false;
  var remoteRef = this.getRemoteRef(remote);
  if (!remoteRef) return true;
  return this.node() != remoteRef.node();
}

RefViewModel.prototype.createRemoteRef = function() {
  var self = this;
  return this.server.postPromise('/push', { path: this.graph.repoPath(), remote: this.graph.currentRemote(), refSpec: this.refName, remoteBranch: this.refName })
    .catch((e) => this.server.unhandledRejection(e));
}
RefViewModel.prototype.checkout = function() {
  const isRemote = this.isRemoteBranch;
  const isLocalCurrent = this.getLocalRef() && this.getLocalRef().current();

  return Promise.resolve().then(() => {
      if (isRemote && !isLocalCurrent) {
        return this.server.postPromise('/branches', {
          path: this.graph.repoPath(),
          name: this.refName,
          sha1: this.name,
          force: true
        });
      }
    }).then(() => this.server.postPromise('/checkout', { path: this.graph.repoPath(), name: this.refName }))
    .then(() => {
      if (isRemote && isLocalCurrent) {
        return this.server.postPromise('/reset', { path: this.graph.repoPath(), to: this.name, mode: 'hard' });
      }
    }).then(() => {
      this.graph.HEADref().node(this.node());
    }).catch((err) => {
      if (err.errorCode != 'merge-failed') this.server.unhandledRejection(err);
    });
}

},{"./selectable":8,"bluebird":undefined,"blueimp-md5":"blueimp-md5","knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],6:[function(require,module,exports){
var ko = require('knockout');
var components = require('ungit-components');
var GitNodeViewModel = require('./git-node');
var GitRefViewModel = require('./git-ref');
var _ = require('lodash');
var moment = require('moment');
var EdgeViewModel = require('./edge');
var numberOfNodesPerLoad = ungit.config.numberOfNodesPerLoad;

components.register('graph', function(args) {
  return new GraphViewModel(args.server, args.repoPath);
});

function GraphViewModel(server, repoPath) {
  var self = this;
  this.repoPath = repoPath;
  this.limit = ko.observable(numberOfNodesPerLoad);
  this.skip = ko.observable(0);
  this.server = server;
  this.currentRemote = ko.observable();
  this.nodes = ko.observableArray();
  this.edges = ko.observableArray();
  this.refs = ko.observableArray();
  this.nodesById = {};
  this.refsByRefName = {};
  this.checkedOutBranch = ko.observable();
  this.checkedOutRef = ko.computed(function() {
    return self.checkedOutBranch() ? self.getRef('refs/heads/' + self.checkedOutBranch()) : null;
  });
  this.HEADref = ko.observable();
  this.HEAD = ko.computed(function() {
    return self.HEADref() ? self.HEADref().node() : undefined;
  });
  this.commitNodeColor = ko.computed(function() {
    return self.HEAD() ? self.HEAD().color() : '#4A4A4A';
  });
  this.commitNodeEdge = ko.computed(function() {
    if (!self.HEAD() || !self.HEAD().cx() || !self.HEAD().cy()) return;
    return "M 610 68 L " + self.HEAD().cx() + " " + self.HEAD().cy();
  });
  this.showCommitNode = ko.observable(false);
  this.currentActionContext = ko.observable();
  this.edgesById = {};
  this.scrolledToEnd = _.debounce(function() {
    self.limit(numberOfNodesPerLoad + self.limit());
    self.loadNodesFromApi();
  }, 500, true);
  this.loadAhead = _.debounce(function() {
    if (self.skip() <= 0) return;
    self.skip(Math.max(self.skip() - numberOfNodesPerLoad, 0));
    self.loadNodesFromApi();
  }, 500, true);
  this.dimCommit = ko.observable(false);
  this.commitOpacity = ko.computed(function() { return self.dimCommit() ? 0.1 : 1; });
  this.heighstBranchOrder = 0;
  this.hoverGraphActionGraphic = ko.observable();
  this.hoverGraphActionGraphic.subscribe(function(value) {
    if (value && value.destroy)
      value.destroy();
  }, null, 'beforeChange');

  this.hoverGraphAction = ko.observable();
  this.hoverGraphAction.subscribe(function(value) {
    if (value && value.createHoverGraphic) {
      self.hoverGraphActionGraphic(value.createHoverGraphic());
    } else {
      self.hoverGraphActionGraphic(null);
    }
  });

  this.loadNodesFromApiThrottled = _.throttle(this.loadNodesFromApi.bind(this), 1000);
  this.updateBranchesThrottled = _.throttle(this.updateBranches.bind(this), 1000);
  this.loadNodesFromApi();
  this.updateBranches();
  this.graphWidth = ko.observable();
  this.graphHeight = ko.observable(800);
}

GraphViewModel.prototype.updateNode = function(parentElement) {
  ko.renderTemplate('graph', this, {}, parentElement);
}

GraphViewModel.prototype.getNode = function(sha1, logEntry) {
  var nodeViewModel = this.nodesById[sha1];
  if (!nodeViewModel) nodeViewModel = this.nodesById[sha1] = new GitNodeViewModel(this, sha1);
  if (logEntry) nodeViewModel.setData(logEntry);
  return nodeViewModel;
}
GraphViewModel.prototype.getRef = function(ref, constructIfUnavailable) {
  if (constructIfUnavailable === undefined) constructIfUnavailable = true;
  var refViewModel = this.refsByRefName[ref];
  if (!refViewModel && constructIfUnavailable) {
    refViewModel = this.refsByRefName[ref] = new GitRefViewModel(ref, this);
    this.refs.push(refViewModel);
    if (refViewModel.name === 'HEAD') {
      this.HEADref(refViewModel);
    }
  }
  return refViewModel;
}

GraphViewModel.prototype.loadNodesFromApi = function() {
  var self = this;
  var nodeSize = self.nodes().length;

  return this.server.getPromise('/gitlog', { path: this.repoPath(), limit: this.limit(), skip: this.skip() })
    .then(function(log) {
      // set new limit and skip
      self.limit(parseInt(log.limit));
      self.skip(parseInt(log.skip));
      return log.nodes || [];
    }).then(function(nodes) {
      // create and/or calculate nodes
      return self.computeNode(nodes.map((logEntry) => {
        return self.getNode(logEntry.sha1, logEntry);     // convert to node object
      }));
    }).then(function(nodes) {
      // create edges
      var edges = [];
      nodes.forEach(function(node) {
        node.parents().forEach(function(parentSha1) {
          edges.push(self.getEdge(node.sha1, parentSha1));
        });
        node.render();
      });

      self.edges(edges);
      self.nodes(nodes);
      if (nodes.length > 0) {
        self.graphHeight(nodes[nodes.length - 1].cy() + 80);
      }
      self.graphWidth(1000 + (self.heighstBranchOrder * 90));
    }).catch((e) => this.server.unhandledRejection(e))
    .finally(function() {
      if (window.innerHeight - self.graphHeight() > 0 && nodeSize != self.nodes().length) {
        self.scrolledToEnd();
      }
    });
}

GraphViewModel.prototype.traverseNodeLeftParents = function(node, callback) {
  callback(node);
  var parent = this.nodesById[node.parents()[0]];
  if (parent) {
    this.traverseNodeLeftParents(parent, callback);
  }
}

GraphViewModel.prototype.computeNode = function(nodes) {
  var self = this;

  nodes = nodes || this.nodes();

  this.markNodesIdeologicalBranches(this.refs(), nodes, this.nodesById);

  var updateTimeStamp = moment().valueOf();
  if (this.HEAD()) {
    this.traverseNodeLeftParents(this.HEAD(), function(node) {
      node.ancestorOfHEADTimeStamp = updateTimeStamp;
    });
  }

  // Filter out nodes which doesn't have a branch (staging and orphaned nodes)
  nodes = nodes.filter(function(node) {
    return (node.ideologicalBranch() && !node.ideologicalBranch().isStash) || node.ancestorOfHEADTimeStamp == updateTimeStamp;
  });

  var branchSlotCounter = this.HEAD() ? 1 : 0;

  // Then iterate from the bottom to fix the orders of the branches
  for (var i = nodes.length - 1; i >= 0; i--) {
    var node = nodes[i];
    if (node.ancestorOfHEADTimeStamp == updateTimeStamp) continue;
    var ideologicalBranch = node.ideologicalBranch();

    // First occurrence of the branch, find an empty slot for the branch
    if (ideologicalBranch.lastSlottedTimeStamp != updateTimeStamp) {
      ideologicalBranch.lastSlottedTimeStamp = updateTimeStamp;
      ideologicalBranch.branchOrder = branchSlotCounter++
    }

    node.branchOrder(ideologicalBranch.branchOrder);
  }

  self.heighstBranchOrder = branchSlotCounter - 1;
  var prevNode;
  nodes.forEach(function(node) {
    node.ancestorOfHEAD(node.ancestorOfHEADTimeStamp == updateTimeStamp);
    if (node.ancestorOfHEAD()) node.branchOrder(0);
    node.aboveNode = prevNode;
    if (prevNode) prevNode.belowNode = node;
    prevNode = node;
  });

  return nodes;
}

GraphViewModel.prototype.getEdge = function(nodeAsha1, nodeBsha1) {
  var id = nodeAsha1 + '-' + nodeBsha1;
  var edge = this.edgesById[id];
  if (!edge) {
    edge = this.edgesById[id] = new EdgeViewModel(this, nodeAsha1, nodeBsha1);
  }
  return edge;
}

GraphViewModel._markIdeologicalStamp = 0;
GraphViewModel.prototype.markNodesIdeologicalBranches = function(refs, nodes, nodesById) {
  var self = this;
  refs = refs.filter(function(r) { return !!r.node(); });
  refs = refs.sort(function(a, b) {
    if (a.isLocal && !b.isLocal) return -1;
    if (b.isLocal && !a.isLocal) return 1;
    if (a.isBranch && !b.isBranch) return -1;
    if (b.isBranch && !a.isBranch) return 1;
    if (a.isHEAD && !b.isHEAD) return 1;
    if (!a.isHEAD && b.isHEAD) return -1;
    if (a.isStash && !b.isStash) return 1;
    if (b.isStash && !a.isStash) return -1;
    if (a.node() && a.node().date && b.node() && b.node().date)
      return a.node().date - b.node().date;
    return a.refName < b.refName ? -1 : 1;
  });
  var stamp = GraphViewModel._markIdeologicalStamp++;
  refs.forEach(function(ref) {
    self.traverseNodeParents(ref.node(), function(node) {
      if (node.stamp == stamp) return false;
      node.stamp = stamp;
      node.ideologicalBranch(ref);
      return true;
    });
  });
}

GraphViewModel.prototype.traverseNodeParents = function(node, callback) {
  if (!callback(node)) return false;
  for (var i = 0; i < node.parents().length; i++) {
    // if parent, travers parent
    var parent = this.nodesById[node.parents()[i]];
    if (parent) {
      this.traverseNodeParents(parent, callback);
    }
  }
}

GraphViewModel.prototype.handleBubbledClick = function(elem, event) {
  // If the clicked element is bound to the current action context,
  // then let's not deselect it.
  if (ko.dataFor(event.target) === this.currentActionContext()) return;
  if (this.currentActionContext() && this.currentActionContext() instanceof GitNodeViewModel) {
    this.currentActionContext().toggleSelected();
  } else {
    this.currentActionContext(null);
  }
  // If the click was on an input element, then let's allow the default action to proceed.
  // This is especially needed since for some strange reason any submit (ie. enter in a textbox)
  // will trigger a click event on the submit input of the form, which will end up here,
  // and if we don't return true, then the submit event is never fired, breaking stuff.
  if (event.target.nodeName === 'INPUT') return true;
}

GraphViewModel.prototype.onProgramEvent = function(event) {
  if (event.event == 'git-directory-changed') {
    this.loadNodesFromApiThrottled();
    this.updateBranchesThrottled();
  } else if (event.event == 'request-app-content-refresh') {
    this.loadNodesFromApiThrottled();
  } else if (event.event == 'remote-tags-update') {
    this.setRemoteTags(event.tags);
  } else if (event.event == 'current-remote-changed') {
    this.currentRemote(event.newRemote);
  } else if (event.event == 'graph-render') {
    this.nodes().forEach(function(node) {
      node.render();
    });
  }
}
GraphViewModel.prototype.updateBranches = function() {
  var self = this;

  this.server.getPromise('/checkout', { path: this.repoPath() })
    .then(function(res) { self.checkedOutBranch(res); })
    .catch(function(err) {
      if (err.errorCode != 'not-a-repository') self.server.unhandledRejection(err);
    })
}
GraphViewModel.prototype.setRemoteTags = function(remoteTags) {
  const version = Date.now();
  remoteTags.forEach((ref) => {
    if (ref.name.indexOf('^{}') !== -1) {
      const tagRef = ref.name.slice(0, ref.name.length - '^{}'.length);
      const name = `remote-tag: ${ref.remote}/${tagRef.split('/')[2]}`;
      this.getRef(name).node(this.getNode(ref.sha1));
      this.getRef(name).version = version;
    }
  });
  this.refs().forEach((ref) => {
    // tag is removed from another source
    if (ref.isRemoteTag && (!ref.version || ref.version < version)) {
      ref.remove(true);
    }
  });
}
GraphViewModel.prototype.checkHeadMove = function(toNode) {
  if (this.HEAD() === toNode) {
    this.HEADref.node(toNode);
  }
}

},{"./edge":2,"./git-node":4,"./git-ref":5,"knockout":"knockout","lodash":"lodash","moment":"moment","ungit-components":"ungit-components"}],7:[function(require,module,exports){
var getEdgeModelWithD = function(d, stroke, strokeWidth, strokeDasharray, markerEnd) {
  return { d: d,
          stroke: stroke ? stroke : '#4A4A4A',
          strokeWidth: strokeWidth ? strokeWidth : '8',
          strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5',
          markerEnd: markerEnd ? markerEnd : '' };
}

var getEdgeModel = function(scx, scy, tcx, tcy, stroke, strokeWidth, strokeDasharray, markerEnd) {
  return getEdgeModelWithD("M " + scx + " " + scy + " L " + tcx + " " + tcy, stroke, strokeWidth, strokeDasharray, markerEnd);
}

var getNodeModel = function(cx, cy, r, fill, stroke, strokeWidth, strokeDasharray) {
  return { cx: cx,
          cy: cy,
          r: r,
          fill: fill,
          stroke: stroke ? stroke : '#41DE3C',
          strokeWidth: strokeWidth ? strokeWidth : '8',
          strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5' };
}

function HoverViewModel() {
  this.bgEdges = [];
  this.nodes = [];
  this.fgEdges = [];
}

function MergeViewModel(graph, headNode, node) {
  var self = this;
  HoverViewModel.call(this);
  this.graph = graph;
  this.bgEdges = [ getEdgeModel(headNode.cx(), (headNode.cy() - 110), headNode.cx(), headNode.cy()),
                getEdgeModel(headNode.cx(), (headNode.cy() - 110), node.cx(), node.cy()) ];
  this.nodes = [ getNodeModel(headNode.cx(), headNode.cy() - 110, Math.max(headNode.r(), node.r()), '#252833', '#41DE3C', '8', '10, 5') ];

  graph.dimCommit(true);
}
exports.MergeViewModel = MergeViewModel;
MergeViewModel.prototype.destroy = function() {
  this.graph.dimCommit(false);
}

function RebaseViewModel(onto, nodesThatWillMove) {
  var self = this;
  HoverViewModel.call(this);
  nodesThatWillMove = nodesThatWillMove.slice(0, -1);

  if (nodesThatWillMove.length == 0) return;

  this.bgEdges.push(getEdgeModel(onto.cx(), onto.cy(), onto.cx(), onto.cy() - 60));
  nodesThatWillMove.forEach(function(node, i) {
    var cy = onto.cy() + (-90 * (i + 1));
    self.nodes.push(getNodeModel(onto.cx(), cy, 28, 'transparent'));
    if (i + 1 < nodesThatWillMove.length) {
      self.bgEdges.push(getEdgeModel(onto.cx(), (cy - 25), onto.cx(), (cy - 65)));
    }
  });
}
exports.RebaseViewModel = RebaseViewModel;

function ResetViewModel(nodes) {
  var self = this;
  HoverViewModel.call(this);

  nodes.forEach(function(node) {
    self.fgEdges.push(getEdgeModelWithD(node.getLeftToRightStrike(), 'rgb(255, 129, 31)', '8', '0, 0'))
    self.fgEdges.push(getEdgeModelWithD(node.getRightToLeftStrike(), 'rgb(255, 129, 31)', '8', '0, 0'));
  });
}
exports.ResetViewModel = ResetViewModel;

function PushViewModel(fromNode, toNode) {
  HoverViewModel.call(this);
  this.fgEdges = [getEdgeModel(fromNode.cx(), fromNode.cy(), toNode.cx(), (toNode.cy() + 40), 'rgb(61, 139, 255)', '15', '10, 5', 'url(#pushArrowEnd)' )];
}
exports.PushViewModel = PushViewModel;

function SquashViewModel(from, onto) {
  HoverViewModel.call(this);

  let path = from.getPathToCommonAncestor(onto);

  if (path.length == 0) {
    return;
  } else if (path.length == 1) {
    path = onto.getPathToCommonAncestor(from)
  } else {
    this.nodes.push(getNodeModel(onto.cx(), onto.cy() - 120, 28, 'transparent'));
  }

  path.slice(0, -1).forEach((node) => {
    this.nodes.push(getNodeModel(node.cx(), node.cy(), node.r() + 2, 'rgba(100, 60, 222, 0.8)'));
  });
}
exports.SquashViewModel = SquashViewModel;

},{}],8:[function(require,module,exports){
var ko = require('knockout');

var Selectable = function(graph) {
  this.selected = ko.computed({
    read: function() {
      return graph.currentActionContext() == this;
    },
    write: function(val) {
      // val is this if we're called from a click ko binding
      if (val === this || val === true) {
        graph.currentActionContext(this);
      } else if (graph.currentActionContext() == this) {
        graph.currentActionContext(null);
      }
    },
    owner: this
  });
};
module.exports = Selectable;

},{"knockout":"knockout"}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2FuaW1hdGVhYmxlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9lZGdlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9naXQtZ3JhcGgtYWN0aW9ucy5qcyIsImNvbXBvbmVudHMvZ3JhcGgvZ2l0LW5vZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2dpdC1yZWYuanMiLCJjb21wb25lbnRzL2dyYXBoL2dyYXBoLmpzIiwiY29tcG9uZW50cy9ncmFwaC9ob3Zlci1hY3Rpb25zLmpzIiwiY29tcG9uZW50cy9ncmFwaC9zZWxlY3RhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xucmVxdWlyZSgnbWluYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5lbGVtZW50ID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLnByZXZpb3VzR3JhcGggPSB1bmRlZmluZWQ7XG4gIHRoaXMuZWxlbWVudC5zdWJzY3JpYmUoZnVuY3Rpb24odmFsKSB7XG4gICAgaWYgKHZhbCkgc2VsZi5hbmltYXRlKHRydWUpO1xuICB9KTtcbiAgdGhpcy5hbmltYXRlID0gZnVuY3Rpb24oZm9yY2VSZWZyZXNoKSB7XG4gICAgdmFyIGN1cnJlbnRHcmFwaCA9IHRoaXMuZ2V0R3JhcGhBdHRyKCk7XG4gICAgLy8gYW5pbWF0ZSBvbmx5IHdoZW4gZG9tIGlzIHZhbGlkIGFuZCAoYXR0cmlidXRlIGNoYW5nZWQgb3IgZm9yY2UgcmVmcmVzaCBkdWUgdG8gZG9tIGNoYW5nZSlcbiAgICBpZiAodGhpcy5lbGVtZW50KCkgJiYgKGZvcmNlUmVmcmVzaCB8fCBKU09OLnN0cmluZ2lmeShjdXJyZW50R3JhcGgpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLnByZXZpb3VzR3JhcGgpKSkge1xuICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICB3aW5kb3cubWluYSh0aGlzLnByZXZpb3VzR3JhcGggfHwgY3VycmVudEdyYXBoLCBjdXJyZW50R3JhcGgsIG5vdywgbm93ICsgNzUwLCB3aW5kb3cubWluYS50aW1lLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHNlbGYuc2V0R3JhcGhBdHRyKHZhbCk7XG4gICAgICB9LCB3aW5kb3cubWluYS5lbGFzdGljKTtcbiAgICAgIHRoaXMucHJldmlvdXNHcmFwaCA9IGN1cnJlbnRHcmFwaDtcbiAgICB9XG4gIH1cbn07XG4iLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIEFuaW1hdGVhYmxlID0gcmVxdWlyZSgnLi9hbmltYXRlYWJsZScpO1xuXG52YXIgRWRnZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlQXNoYTEsIG5vZGVCc2hhMSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEFuaW1hdGVhYmxlLmNhbGwodGhpcyk7XG4gIHRoaXMubm9kZUEgPSBncmFwaC5nZXROb2RlKG5vZGVBc2hhMSk7XG4gIHRoaXMubm9kZUIgPSBncmFwaC5nZXROb2RlKG5vZGVCc2hhMSk7XG4gIHRoaXMuZ2V0R3JhcGhBdHRyID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYubm9kZUEuaXNWaWV3YWJsZSgpICYmICghc2VsZi5ub2RlQi5pc1ZpZXdhYmxlKCkgfHwgIXNlbGYubm9kZUIuaXNJbml0ZWQpKSB7XG4gICAgICByZXR1cm4gW3NlbGYubm9kZUEuY3goKSwgc2VsZi5ub2RlQS5jeSgpLCBzZWxmLm5vZGVBLmN4KCksIHNlbGYubm9kZUEuY3koKSxcbiAgICAgICAgICAgICAgc2VsZi5ub2RlQS5jeCgpLCBncmFwaC5ncmFwaEhlaWdodCgpLCBzZWxmLm5vZGVBLmN4KCksIGdyYXBoLmdyYXBoSGVpZ2h0KCldO1xuICAgIH0gZWxzZSBpZiAoc2VsZi5ub2RlQi5pc0luaXRlZCAmJiBzZWxmLm5vZGVCLmN4KCkgJiYgc2VsZi5ub2RlQi5jeSgpKSB7XG4gICAgICByZXR1cm4gW3NlbGYubm9kZUEuY3goKSwgc2VsZi5ub2RlQS5jeSgpLCBzZWxmLm5vZGVBLmN4KCksIHNlbGYubm9kZUEuY3koKSxcbiAgICAgICAgICAgICAgc2VsZi5ub2RlQi5jeCgpLCBzZWxmLm5vZGVCLmN5KCksIHNlbGYubm9kZUIuY3goKSwgc2VsZi5ub2RlQi5jeSgpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLmdldEdyYXBoQXR0ci5zdWJzY3JpYmUodGhpcy5hbmltYXRlLmJpbmQodGhpcykpO1xufVxuRWRnZVZpZXdNb2RlbC5wcm90b3R5cGUuc2V0R3JhcGhBdHRyID0gZnVuY3Rpb24odmFsKSB7XG4gIHRoaXMuZWxlbWVudCgpLnNldEF0dHJpYnV0ZSgnZCcsICdNJyArIHZhbC5zbGljZSgwLDQpLmpvaW4oJywnKSArICdMJyArIHZhbC5zbGljZSg0LDgpLmpvaW4oJywnKSk7XG59XG5FZGdlVmlld01vZGVsLnByb3RvdHlwZS5lZGdlTW91c2VPdmVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm5vZGVBKSB7XG4gICAgdGhpcy5ub2RlQS5pc0VkZ2VIaWdobGlnaHRlZCh0cnVlKTtcbiAgfVxuICBpZiAodGhpcy5ub2RlQikge1xuICAgIHRoaXMubm9kZUIuaXNFZGdlSGlnaGxpZ2h0ZWQodHJ1ZSk7XG4gIH1cbn1cbkVkZ2VWaWV3TW9kZWwucHJvdG90eXBlLmVkZ2VNb3VzZU91dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5ub2RlQSkge1xuICAgIHRoaXMubm9kZUEuaXNFZGdlSGlnaGxpZ2h0ZWQoZmFsc2UpO1xuICB9XG4gIGlmICh0aGlzLm5vZGVCKSB7XG4gICAgdGhpcy5ub2RlQi5pc0VkZ2VIaWdobGlnaHRlZChmYWxzZSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gRWRnZVZpZXdNb2RlbDtcbiIsIlxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBjb21wb25lbnRzID0gcmVxdWlyZSgndW5naXQtY29tcG9uZW50cycpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xudmFyIFJlZlZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vZ2l0LXJlZi5qcycpO1xudmFyIEhvdmVyQWN0aW9ucyA9IHJlcXVpcmUoJy4vaG92ZXItYWN0aW9ucycpO1xudmFyIHByb2dyYW1FdmVudHMgPSByZXF1aXJlKCd1bmdpdC1wcm9ncmFtLWV2ZW50cycpO1xudmFyIFJlYmFzZVZpZXdNb2RlbCA9IEhvdmVyQWN0aW9ucy5SZWJhc2VWaWV3TW9kZWw7XG52YXIgTWVyZ2VWaWV3TW9kZWwgPSBIb3ZlckFjdGlvbnMuTWVyZ2VWaWV3TW9kZWw7XG52YXIgUmVzZXRWaWV3TW9kZWwgPSBIb3ZlckFjdGlvbnMuUmVzZXRWaWV3TW9kZWw7XG52YXIgUHVzaFZpZXdNb2RlbCA9IEhvdmVyQWN0aW9ucy5QdXNoVmlld01vZGVsO1xudmFyIFNxdWFzaFZpZXdNb2RlbCA9IEhvdmVyQWN0aW9ucy5TcXVhc2hWaWV3TW9kZWw7XG5cbnZhciBHcmFwaEFjdGlvbnMgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gR3JhcGhBY3Rpb25zO1xuXG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5zZXJ2ZXIgPSBncmFwaC5zZXJ2ZXI7XG4gIHRoaXMuaXNSdW5uaW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMuaXNIaWdobGlnaHRlZCA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4gIWdyYXBoLmhvdmVyR3JhcGhBY3Rpb24oKSB8fCBncmFwaC5ob3ZlckdyYXBoQWN0aW9uKCkgPT0gdGhpcztcbiAgfSk7XG4gIHRoaXMuY3NzQ2xhc3NlcyA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoIXRoaXMuaXNIaWdobGlnaHRlZCgpIHx8IHRoaXMuaXNSdW5uaW5nKCkpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLnN0eWxlfSBkaW1tZWRgXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnN0eWxlXG4gICAgfVxuICB9KVxufVxuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UucHJvdG90eXBlLmljb24gPSBudWxsO1xuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UucHJvdG90eXBlLmRvUGVyZm9ybSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pc1J1bm5pbmcoKSkgcmV0dXJuO1xuICB0aGlzLmdyYXBoLmhvdmVyR3JhcGhBY3Rpb24obnVsbCk7XG4gIHRoaXMuaXNSdW5uaW5nKHRydWUpO1xuICByZXR1cm4gdGhpcy5wZXJmb3JtKClcbiAgICAuY2F0Y2goKGUpID0+IHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSlcbiAgICAuZmluYWxseSgoKSA9PiB7IHRoaXMuaXNSdW5uaW5nKGZhbHNlKTsgfSk7XG59XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUuZHJhZ0VudGVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy52aXNpYmxlKCkpIHJldHVybjtcbiAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKHRoaXMpO1xufVxuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UucHJvdG90eXBlLmRyYWdMZWF2ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudmlzaWJsZSgpKSByZXR1cm47XG4gIHRoaXMuZ3JhcGguaG92ZXJHcmFwaEFjdGlvbihudWxsKTtcbn1cbkdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLnByb3RvdHlwZS5tb3VzZW92ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKHRoaXMpO1xufVxuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UucHJvdG90eXBlLm1vdXNlb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ3JhcGguaG92ZXJHcmFwaEFjdGlvbihudWxsKTtcbn1cblxuR3JhcGhBY3Rpb25zLk1vdmUgPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5pc1J1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLm5vZGUoKSAhPSBzZWxmLm5vZGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLk1vdmUsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5Nb3ZlLnByb3RvdHlwZS50ZXh0ID0gJ01vdmUnO1xuR3JhcGhBY3Rpb25zLk1vdmUucHJvdG90eXBlLnN0eWxlID0gJ21vdmUnO1xuR3JhcGhBY3Rpb25zLk1vdmUucHJvdG90eXBlLmljb24gPSAnZ2x5cGhpY29uIGdseXBoaWNvbi1tb3ZlJztcbkdyYXBoQWN0aW9ucy5Nb3ZlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubW92ZVRvKHRoaXMubm9kZS5zaGExKTtcbn1cblxuR3JhcGhBY3Rpb25zLlJlc2V0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuaXNSdW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIGlmICghKHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCkpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgY29udGV4dCA9IHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgICBpZiAoY29udGV4dC5ub2RlKCkgIT0gc2VsZi5ub2RlKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHJlbW90ZVJlZiA9IGNvbnRleHQuZ2V0UmVtb3RlUmVmKHNlbGYuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcbiAgICByZXR1cm4gcmVtb3RlUmVmICYmIHJlbW90ZVJlZi5ub2RlKCkgJiZcbiAgICAgIGNvbnRleHQgJiYgY29udGV4dC5ub2RlKCkgJiZcbiAgICAgIHJlbW90ZVJlZi5ub2RlKCkgIT0gY29udGV4dC5ub2RlKCkgJiZcbiAgICAgIHJlbW90ZVJlZi5ub2RlKCkuZGF0ZSA8IGNvbnRleHQubm9kZSgpLmRhdGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLlJlc2V0LCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuUmVzZXQucHJvdG90eXBlLnRleHQgPSAnUmVzZXQnO1xuR3JhcGhBY3Rpb25zLlJlc2V0LnByb3RvdHlwZS5zdHlsZSA9ICdyZXNldCc7XG5HcmFwaEFjdGlvbnMuUmVzZXQucHJvdG90eXBlLmljb24gPSAnZ2x5cGhpY29uIGdseXBoaWNvbi10cmFzaCc7XG5HcmFwaEFjdGlvbnMuUmVzZXQucHJvdG90eXBlLmNyZWF0ZUhvdmVyR3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCFjb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgdmFyIHJlbW90ZVJlZiA9IGNvbnRleHQuZ2V0UmVtb3RlUmVmKHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcbiAgdmFyIG5vZGVzID0gY29udGV4dC5ub2RlKCkuZ2V0UGF0aFRvQ29tbW9uQW5jZXN0b3IocmVtb3RlUmVmLm5vZGUoKSkuc2xpY2UoMCwgLTEpO1xuICByZXR1cm4gbmV3IFJlc2V0Vmlld01vZGVsKG5vZGVzKTtcbn1cbkdyYXBoQWN0aW9ucy5SZXNldC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICB2YXIgcmVtb3RlUmVmID0gY29udGV4dC5nZXRSZW1vdGVSZWYoc2VsZi5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICByZXR1cm4gY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0FyZSB5b3Ugc3VyZT8nLCBkZXRhaWxzOiAnUmVzZXR0aW5nIHRvIHJlZjogJyArIHJlbW90ZVJlZi5uYW1lICsgJyBjYW5ub3QgYmUgdW5kb25lIHdpdGggdW5naXQuJ30pXG4gICAgLnNob3coKVxuICAgIC5jbG9zZVRoZW4oZnVuY3Rpb24oZGlhZykge1xuICAgICAgaWYgKCFkaWFnLnJlc3VsdCgpKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5zZXJ2ZXIucG9zdFByb21pc2UoJy9yZXNldCcsIHsgcGF0aDogc2VsZi5ncmFwaC5yZXBvUGF0aCgpLCB0bzogcmVtb3RlUmVmLm5hbWUsIG1vZGU6ICdoYXJkJyB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHsgY29udGV4dC5ub2RlKHJlbW90ZVJlZi5ub2RlKCkpOyB9KTtcbiAgICB9KS5jbG9zZVByb21pc2U7XG59XG5cbkdyYXBoQWN0aW9ucy5SZWJhc2UgPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5pc1J1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgKCF1bmdpdC5jb25maWcuc2hvd1JlYmFzZUFuZE1lcmdlT25seU9uUmVmcyB8fCBzZWxmLm5vZGUucmVmcygpLmxlbmd0aCA+IDApICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY3VycmVudCgpICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubm9kZSgpICE9IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuUmViYXNlLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuUmViYXNlLnByb3RvdHlwZS50ZXh0ID0gJ1JlYmFzZSc7XG5HcmFwaEFjdGlvbnMuUmViYXNlLnByb3RvdHlwZS5zdHlsZSA9ICdyZWJhc2UnO1xuR3JhcGhBY3Rpb25zLlJlYmFzZS5wcm90b3R5cGUuaWNvbiA9ICdvY3RpY29uIG9jdGljb24tcmVwby1mb3JrZWQgZmxpcCc7XG5HcmFwaEFjdGlvbnMuUmViYXNlLnByb3RvdHlwZS5jcmVhdGVIb3ZlckdyYXBoaWMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9udG8gPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIGlmICghb250bykgcmV0dXJuO1xuICBpZiAob250byBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCkgb250byA9IG9udG8ubm9kZSgpO1xuICB2YXIgcGF0aCA9IG9udG8uZ2V0UGF0aFRvQ29tbW9uQW5jZXN0b3IodGhpcy5ub2RlKTtcbiAgcmV0dXJuIG5ldyBSZWJhc2VWaWV3TW9kZWwodGhpcy5ub2RlLCBwYXRoKTtcbn1cbkdyYXBoQWN0aW9ucy5SZWJhc2UucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvcmViYXNlJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIG9udG86IHRoaXMubm9kZS5zaGExIH0pXG4gICAgLmNhdGNoKChlcnIpID0+IHsgaWYgKGVyci5lcnJvckNvZGUgIT0gJ21lcmdlLWZhaWxlZCcpIHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlcnIpOyB9KVxufVxuXG5HcmFwaEFjdGlvbnMuTWVyZ2UgPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5pc1J1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFzZWxmLmdyYXBoLmNoZWNrZWRPdXRSZWYoKSB8fCAhc2VsZi5ncmFwaC5jaGVja2VkT3V0UmVmKCkubm9kZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgIXNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jdXJyZW50KCkgJiZcbiAgICAgIHNlbGYuZ3JhcGguY2hlY2tlZE91dFJlZigpLm5vZGUoKSA9PSBzZWxmLm5vZGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLk1lcmdlLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLnRleHQgPSAnTWVyZ2UnO1xuR3JhcGhBY3Rpb25zLk1lcmdlLnByb3RvdHlwZS5zdHlsZSA9ICdtZXJnZSc7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLmljb24gPSAnb2N0aWNvbiBvY3RpY29uLWdpdC1tZXJnZSc7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLmNyZWF0ZUhvdmVyR3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpIG5vZGUgPSBub2RlLm5vZGUoKTtcbiAgcmV0dXJuIG5ldyBNZXJnZVZpZXdNb2RlbCh0aGlzLmdyYXBoLCB0aGlzLm5vZGUsIG5vZGUpO1xufVxuR3JhcGhBY3Rpb25zLk1lcmdlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL21lcmdlJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIHdpdGg6IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5sb2NhbFJlZk5hbWUgfSlcbiAgICAuY2F0Y2goKGVycikgPT4geyBpZiAoZXJyLmVycm9yQ29kZSAhPSAnbWVyZ2UtZmFpbGVkJykgdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGVycik7IH0pXG59XG5cbkdyYXBoQWN0aW9ucy5QdXNoID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuaXNSdW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgJiZcbiAgICAgIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgPT0gc2VsZi5ub2RlICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY2FuQmVQdXNoZWQoc2VsZi5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5QdXNoLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuUHVzaC5wcm90b3R5cGUudGV4dCA9ICdQdXNoJztcbkdyYXBoQWN0aW9ucy5QdXNoLnByb3RvdHlwZS5zdHlsZSA9ICdwdXNoJztcbkdyYXBoQWN0aW9ucy5QdXNoLnByb3RvdHlwZS5pY29uID0gJ29jdGljb24gb2N0aWNvbi1jbG91ZC11cGxvYWQnO1xuR3JhcGhBY3Rpb25zLlB1c2gucHJvdG90eXBlLmNyZWF0ZUhvdmVyR3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCFjb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgdmFyIHJlbW90ZVJlZiA9IGNvbnRleHQuZ2V0UmVtb3RlUmVmKHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcbiAgaWYgKCFyZW1vdGVSZWYpIHJldHVybiBudWxsO1xuICByZXR1cm4gbmV3IFB1c2hWaWV3TW9kZWwocmVtb3RlUmVmLm5vZGUoKSwgY29udGV4dC5ub2RlKCkpO1xufVxuR3JhcGhBY3Rpb25zLlB1c2gucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlZiA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgdmFyIHJlbW90ZVJlZiA9IHJlZi5nZXRSZW1vdGVSZWYodGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuXG4gIGlmIChyZW1vdGVSZWYpIHtcbiAgICByZXR1cm4gcmVtb3RlUmVmLm1vdmVUbyhyZWYubm9kZSgpLnNoYTEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWYuY3JlYXRlUmVtb3RlUmVmKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGguSEVBRCgpLm5hbWUgPT0gcmVmLm5hbWUpIHtcbiAgICAgICAgICB0aGlzLmdyYWguSEVBRHJlZigpLm5vZGUocmVmLm5vZGUoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4gcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAncmVxdWVzdC1mZXRjaC10YWdzJyB9KSk7XG4gIH1cbn1cblxuR3JhcGhBY3Rpb25zLkNoZWNrb3V0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuaXNSdW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIGlmIChzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpXG4gICAgICByZXR1cm4gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLm5vZGUoKSA9PSBzZWxmLm5vZGUgJiZcbiAgICAgICAgIXNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jdXJyZW50KCk7XG4gICAgcmV0dXJuIHVuZ2l0LmNvbmZpZy5hbGxvd0NoZWNrb3V0Tm9kZXMgJiZcbiAgICAgIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSBzZWxmLm5vZGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLkNoZWNrb3V0LCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuQ2hlY2tvdXQucHJvdG90eXBlLnRleHQgPSAnQ2hlY2tvdXQnO1xuR3JhcGhBY3Rpb25zLkNoZWNrb3V0LnByb3RvdHlwZS5zdHlsZSA9ICdjaGVja291dCc7XG5HcmFwaEFjdGlvbnMuQ2hlY2tvdXQucHJvdG90eXBlLmljb24gPSAnb2N0aWNvbiBvY3RpY29uLWRlc2t0b3AtZG93bmxvYWQnO1xuR3JhcGhBY3Rpb25zLkNoZWNrb3V0LnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY2hlY2tvdXQoKTtcbn1cblxuR3JhcGhBY3Rpb25zLkRlbGV0ZSA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLmlzUnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubm9kZSgpID09IHNlbGYubm9kZSAmJlxuICAgICAgIXNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jdXJyZW50KCk7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLkRlbGV0ZSwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLkRlbGV0ZS5wcm90b3R5cGUudGV4dCA9ICdEZWxldGUnO1xuR3JhcGhBY3Rpb25zLkRlbGV0ZS5wcm90b3R5cGUuc3R5bGUgPSAnZGVsZXRlJztcbkdyYXBoQWN0aW9ucy5EZWxldGUucHJvdG90eXBlLmljb24gPSAnZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmUnO1xuR3JhcGhBY3Rpb25zLkRlbGV0ZS5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBjb250ZXh0ID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBsZXQgZGV0YWlscyA9IGBcIiR7Y29udGV4dC5yZWZOYW1lfVwiYDtcbiAgaWYgKGNvbnRleHQuaXNSZW1vdGVCcmFuY2gpIHtcbiAgICBkZXRhaWxzID0gYDxjb2RlIHN0eWxlPSdmb250LXNpemU6IDEwMCUnPlJFTU9URTwvY29kZT4gJHtkZXRhaWxzfWA7XG4gIH1cbiAgZGV0YWlscyA9IGBEZWxldGluZyAke2RldGFpbHN9IGJyYW5jaCBvciB0YWcgY2Fubm90IGJlIHVuZG9uZSB3aXRoIHVuZ2l0LmA7XG5cbiAgcmV0dXJuIGNvbXBvbmVudHMuY3JlYXRlKCd5ZXNub2RpYWxvZycsIHsgdGl0bGU6ICdBcmUgeW91IHN1cmU/JywgZGV0YWlsczogZGV0YWlscyB9KVxuICAgIC5zaG93KClcbiAgICAuY2xvc2VUaGVuKChkaWFnKSA9PiB7XG4gICAgICBpZiAoZGlhZy5yZXN1bHQoKSkgcmV0dXJuIGNvbnRleHQucmVtb3ZlKCk7XG4gICAgfSkuY2xvc2VQcm9taXNlO1xufVxuXG5HcmFwaEFjdGlvbnMuQ2hlcnJ5UGljayA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLmlzUnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgY29udGV4dCA9IHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgICByZXR1cm4gY29udGV4dCA9PT0gc2VsZi5ub2RlICYmIHNlbGYuZ3JhcGguSEVBRCgpICYmIGNvbnRleHQuc2hhMSAhPT0gc2VsZi5ncmFwaC5IRUFEKCkuc2hhMVxuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5DaGVycnlQaWNrLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuQ2hlcnJ5UGljay5wcm90b3R5cGUudGV4dCA9ICdDaGVycnkgcGljayc7XG5HcmFwaEFjdGlvbnMuQ2hlcnJ5UGljay5wcm90b3R5cGUuc3R5bGUgPSAnY2hlcnJ5LXBpY2snO1xuR3JhcGhBY3Rpb25zLkNoZXJyeVBpY2sucHJvdG90eXBlLmljb24gPSAnb2N0aWNvbiBvY3RpY29uLWNpcmN1aXQtYm9hcmQnO1xuR3JhcGhBY3Rpb25zLkNoZXJyeVBpY2sucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9jaGVycnlwaWNrJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIG5hbWU6IHRoaXMubm9kZS5zaGExIH0pXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyLmVycm9yQ29kZSAhPSAnbWVyZ2UtZmFpbGVkJykgc2VsZi5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGVycik7IH0pXG59XG5cbkdyYXBoQWN0aW9ucy5VbmNvbW1pdCA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLmlzUnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpID09IHNlbGYubm9kZSAmJlxuICAgICAgc2VsZi5ncmFwaC5IRUFEKCkgPT0gc2VsZi5ub2RlO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5VbmNvbW1pdCwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLlVuY29tbWl0LnByb3RvdHlwZS50ZXh0ID0gJ1VuY29tbWl0JztcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUuc3R5bGUgPSAndW5jb21taXQnO1xuR3JhcGhBY3Rpb25zLlVuY29tbWl0LnByb3RvdHlwZS5pY29uID0gJ29jdGljb24gb2N0aWNvbi16YXAnO1xuR3JhcGhBY3Rpb25zLlVuY29tbWl0LnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvcmVzZXQnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgdG86ICdIRUFEXicsIG1vZGU6ICdtaXhlZCcgfSlcbiAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0YXJnZXROb2RlID0gc2VsZi5ub2RlLmJlbG93Tm9kZTtcbiAgICAgIHdoaWxlICh0YXJnZXROb2RlICYmICF0YXJnZXROb2RlLmFuY2VzdG9yT2ZIRUFEKCkpIHtcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IHRhcmdldE5vZGUuYmVsb3dOb2RlO1xuICAgICAgfVxuICAgICAgc2VsZi5ncmFwaC5IRUFEcmVmKCkubm9kZSh0YXJnZXROb2RlID8gdGFyZ2V0Tm9kZSA6IG51bGwpO1xuICAgICAgc2VsZi5ncmFwaC5jaGVja2VkT3V0UmVmKCkubm9kZSh0YXJnZXROb2RlID8gdGFyZ2V0Tm9kZSA6IG51bGwpO1xuICAgIH0pO1xufVxuXG5HcmFwaEFjdGlvbnMuUmV2ZXJ0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuaXNSdW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgPT0gc2VsZi5ub2RlO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5SZXZlcnQsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5SZXZlcnQucHJvdG90eXBlLnRleHQgPSAnUmV2ZXJ0JztcbkdyYXBoQWN0aW9ucy5SZXZlcnQucHJvdG90eXBlLnN0eWxlID0gJ3JldmVydCc7XG5HcmFwaEFjdGlvbnMuUmV2ZXJ0LnByb3RvdHlwZS5pY29uID0gJ29jdGljb24gb2N0aWNvbi1oaXN0b3J5JztcbkdyYXBoQWN0aW9ucy5SZXZlcnQucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9yZXZlcnQnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgY29tbWl0OiB0aGlzLm5vZGUuc2hhMSB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLlNxdWFzaCA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLmlzUnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY3VycmVudCgpICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubm9kZSgpICE9IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuU3F1YXNoLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuU3F1YXNoLnByb3RvdHlwZS50ZXh0ID0gJ1NxdWFzaCc7XG5HcmFwaEFjdGlvbnMuU3F1YXNoLnByb3RvdHlwZS5zdHlsZSA9ICdzcXVhc2gnO1xuR3JhcGhBY3Rpb25zLlNxdWFzaC5wcm90b3R5cGUuaWNvbiA9ICdvY3RpY29uIG9jdGljb24tZm9sZCc7XG5HcmFwaEFjdGlvbnMuU3F1YXNoLnByb3RvdHlwZS5jcmVhdGVIb3ZlckdyYXBoaWMgPSBmdW5jdGlvbigpIHtcbiAgbGV0IG9udG8gPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIGlmICghb250bykgcmV0dXJuO1xuICBpZiAob250byBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCkgb250byA9IG9udG8ubm9kZSgpO1xuXG4gIHJldHVybiBuZXcgU3F1YXNoVmlld01vZGVsKHRoaXMubm9kZSwgb250byk7XG59XG5HcmFwaEFjdGlvbnMuU3F1YXNoLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIGxldCBvbnRvID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBpZiAoIW9udG8pIHJldHVybjtcbiAgaWYgKG9udG8gaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpIG9udG8gPSBvbnRvLm5vZGUoKTtcbiAgLy8gcmVtb3ZlIGxhc3QgZWxlbWVudCBhcyBpdCB3b3VsZCBiZSBhIGNvbW1vbiBhbmNlc3Rvci5cbiAgY29uc3QgcGF0aCA9IHRoaXMubm9kZS5nZXRQYXRoVG9Db21tb25BbmNlc3RvcihvbnRvKS5zbGljZSgwLCAtMSk7XG5cbiAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgIC8vIHNxdWFzaGluZyBicmFuY2hlZCBvdXQgbGluZWFnZVxuICAgIC8vIGMgaXMgY2hlY2tvdXQgd2l0aCBzcXVhc2ggdGFyZ2V0IG9mIGUsIHJlc3VsdHMgaW4gc3RhZ2luZyBjaGFuZ2VzXG4gICAgLy8gZnJvbSBkIGFuZCBlIG9uIHRvcCBvZiBjXG4gICAgLy9cbiAgICAvLyBhIC0gYiAtIChjKSAgICAgICAgYSAtIGIgLSAoYykgLSBbZGVdXG4gICAgLy8gIFxcICAgICAgICAgICAtPiAgICAgXFxcbiAgICAvLyAgIGQgIC0gPGU+ICAgICAgICAgICBkIC0gPGU+XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvc3F1YXNoJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIHRhcmdldDogdGhpcy5ub2RlLnNoYTEgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gc3F1YXNoaW5nIGJhY2t3YXJkIGZyb20gc2FtZSBsaW5lYWdlXG4gICAgLy8gYyBpcyBjaGVja291dCB3aXRoIHNxdWFzaCB0YXJnZXQgb2YgYSwgcmVzdWx0cyBpbiBjdXJyZW50IHJlZiBtb3ZlZFxuICAgIC8vIHRvIGEgYW5kIHN0YWdpbmcgY2hhbmdlcyB3aXRoaW4gYiBhbmQgYyBvbiB0b3Agb2YgYVxuICAgIC8vXG4gICAgLy8gPGE+IC0gYiAtIChjKSAgICAgICAoYSkgLSBiIC0gY1xuICAgIC8vICAgICAgICAgICAgICAgIC0+ICAgICBcXFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgW2JjXVxuICAgIHJldHVybiB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubW92ZVRvKHRoaXMubm9kZS5zaGExLCB0cnVlKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9zcXVhc2gnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgdGFyZ2V0OiBvbnRvLnNoYTEgfSkpXG4gIH1cbn1cbiIsImNvbnN0ICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbmNvbnN0IGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbmNvbnN0IGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG5jb25zdCBTZWxlY3RhYmxlID0gcmVxdWlyZSgnLi9zZWxlY3RhYmxlJyk7XG5jb25zdCBBbmltYXRlYWJsZSA9IHJlcXVpcmUoJy4vYW5pbWF0ZWFibGUnKTtcbmNvbnN0IHByb2dyYW1FdmVudHMgPSByZXF1aXJlKCd1bmdpdC1wcm9ncmFtLWV2ZW50cycpO1xuY29uc3QgR3JhcGhBY3Rpb25zID0gcmVxdWlyZSgnLi9naXQtZ3JhcGgtYWN0aW9ucycpO1xuXG5jb25zdCBtYXhCcmFuY2hlc1RvRGlzcGxheSA9IHBhcnNlSW50KHVuZ2l0LmNvbmZpZy5udW1SZWZzVG9TaG93IC8gNSAqIDMpOyAgLy8gMy81IG9mIHJlZnMgdG8gc2hvdyB0byBicmFuY2hlc1xuY29uc3QgbWF4VGFnc1RvRGlzcGxheSA9IHVuZ2l0LmNvbmZpZy5udW1SZWZzVG9TaG93IC0gbWF4QnJhbmNoZXNUb0Rpc3BsYXk7IC8vIDIvNSBvZiByZWZzIHRvIHNob3cgdG8gdGFnc1xuXG52YXIgR2l0Tm9kZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKGdyYXBoLCBzaGExKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgU2VsZWN0YWJsZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgQW5pbWF0ZWFibGUuY2FsbCh0aGlzKTtcbiAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICB0aGlzLnNoYTEgPSBzaGExO1xuICB0aGlzLmlzSW5pdGVkID0gZmFsc2U7XG4gIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50cyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLmNvbW1pdFRpbWUgPSB1bmRlZmluZWQ7IC8vIGNvbW1pdCB0aW1lIGluIHN0cmluZ1xuICB0aGlzLmRhdGUgPSB1bmRlZmluZWQ7ICAgICAgIC8vIGNvbW1pdCB0aW1lIGluIG51bWVyaWMgZm9ybWF0IGZvciBzb3J0XG4gIHRoaXMuY29sb3IgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuaWRlb2xvZ2ljYWxCcmFuY2ggPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMucmVtb3RlVGFncyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLmJyYW5jaGVzQW5kTG9jYWxUYWdzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMuc2lnbmF0dXJlRGF0ZSA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5zaWduYXR1cmVNYWRlID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLnBncFZlcmlmaWVkU3RyaW5nID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuc2lnbmF0dXJlTWFkZSgpKSB7XG4gICAgICByZXR1cm4gYFBHUCBieTogJHtzZWxmLnNpZ25hdHVyZU1hZGUoKX0gYXQgJHtzZWxmLnNpZ25hdHVyZURhdGUoKX1gXG4gICAgfVxuICB9KTtcblxuICB0aGlzLnJlZnMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICB2YXIgcnMgPSBzZWxmLmJyYW5jaGVzQW5kTG9jYWxUYWdzKCkuY29uY2F0KHNlbGYucmVtb3RlVGFncygpKTtcbiAgICBycy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChiLmN1cnJlbnQoKSkgcmV0dXJuIDE7XG4gICAgICBpZiAoYS5jdXJyZW50KCkpIHJldHVybiAtMTtcbiAgICAgIGlmIChhLmlzTG9jYWwgJiYgIWIuaXNMb2NhbCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKCFhLmlzTG9jYWwgJiYgYi5pc0xvY2FsKSByZXR1cm4gMTtcbiAgICAgIHJldHVybiBhLnJlZk5hbWUgPCBiLnJlZk5hbWUgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJzO1xuICB9KTtcbiAgLy8gVGhlc2UgYXJlIHNwbGl0IHVwIGxpa2UgdGhpcyBiZWNhdXNlIGJyYW5jaGVzIGFuZCBsb2NhbCB0YWdzIGNhbiBiZSBmb3VuZCBpbiB0aGUgZ2l0IGxvZyxcbiAgLy8gd2hlcmVhcyByZW1vdGUgdGFncyBuZWVkcyB0byBiZSBmZXRjaGVkIHdpdGggYW5vdGhlciBjb21tYW5kICh3aGljaCBpcyBtdWNoIHNsb3dlcilcbiAgdGhpcy5icmFuY2hlcyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLmJyYW5jaGVzVG9EaXNwbGF5ID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMudGFncyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLnRhZ3NUb0Rpc3BsYXkgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgdGhpcy5yZWZzLnN1YnNjcmliZSgobmV3VmFsdWUpID0+IHtcbiAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuYnJhbmNoZXMobmV3VmFsdWUuZmlsdGVyKChyKSA9PiByLmlzQnJhbmNoKSk7XG4gICAgICB0aGlzLnRhZ3MobmV3VmFsdWUuZmlsdGVyKChyKSA9PiByLmlzVGFnKSk7XG4gICAgICB0aGlzLnRhZ3NUb0Rpc3BsYXkodGhpcy50YWdzLnNsaWNlKDAsIG1heFRhZ3NUb0Rpc3BsYXkpKTtcbiAgICAgIHRoaXMuYnJhbmNoZXNUb0Rpc3BsYXkodGhpcy5icmFuY2hlcy5zbGljZSgwLCB1bmdpdC5jb25maWcubnVtUmVmc1RvU2hvdyAtIHRoaXMudGFnc1RvRGlzcGxheSgpLmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJyYW5jaGVzLnJlbW92ZUFsbCgpO1xuICAgICAgdGhpcy50YWdzLnJlbW92ZUFsbCgpO1xuICAgICAgdGhpcy5icmFuY2hlc1RvRGlzcGxheS5yZW1vdmVBbGwoKTtcbiAgICAgIHRoaXMudGFnc1RvRGlzcGxheS5yZW1vdmVBbGwoKTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLmFuY2VzdG9yT2ZIRUFEID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMubm9kZUlzTW91c2Vob3ZlciA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNvbW1pdENvbnRhaW5lclZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5hbmNlc3Rvck9mSEVBRCgpIHx8IHNlbGYubm9kZUlzTW91c2Vob3ZlcigpIHx8IHNlbGYuc2VsZWN0ZWQoKTtcbiAgfSk7XG4gIHRoaXMuaXNFZGdlSGlnaGxpZ2h0ZWQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgLy8gZm9yIHNtYWxsIGVtcHR5IGJsYWNrIGNpcmNsZSB0byBoaWdobGlnaHQgYSBub2RlXG4gIHRoaXMuaXNOb2RlQWNjZW50ZWQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5zZWxlY3RlZCgpIHx8IHNlbGYuaXNFZGdlSGlnaGxpZ2h0ZWQoKTtcbiAgfSk7XG4gIC8vIHRvIHNob3cgY2hhbmdlZCBmaWxlcyBhbmQgZGlmZiBib3hlcyBvbiB0aGUgbGVmdCBvZiBub2RlXG4gIHRoaXMuaGlnaGxpZ2h0ZWQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5ub2RlSXNNb3VzZWhvdmVyKCkgfHwgc2VsZi5zZWxlY3RlZCgpO1xuICB9KTtcbiAgdGhpcy5zZWxlY3RlZC5zdWJzY3JpYmUoZnVuY3Rpb24oKSB7XG4gICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAnZ3JhcGgtcmVuZGVyJyB9KTtcbiAgfSk7XG4gIHRoaXMuc2hvd05ld1JlZkFjdGlvbiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgfSk7XG4gIHRoaXMubmV3QnJhbmNoTmFtZSA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5uZXdCcmFuY2hOYW1lSGFzRm9jdXMgPSBrby5vYnNlcnZhYmxlKHRydWUpO1xuICB0aGlzLmJyYW5jaGluZ0Zvcm1WaXNpYmxlID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMubmV3QnJhbmNoTmFtZUhhc0ZvY3VzLnN1YnNjcmliZShmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgIGlmICghbmV3VmFsdWUpIHtcbiAgICAgIC8vIFNtYWxsIHRpbWVvdXQgYmVjYXVzZSBpbiBmZiB0aGUgZm9ybSBpcyBoaWRkZW4gYmVmb3JlIHRoZSBzdWJtaXQgY2xpY2sgZXZlbnQgaXMgcmVnaXN0ZXJlZCBvdGhlcndpc2VcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuYnJhbmNoaW5nRm9ybVZpc2libGUoZmFsc2UpO1xuICAgICAgfSwgMjAwKTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLmNhbkNyZWF0ZVJlZiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLm5ld0JyYW5jaE5hbWUoKSAmJiBzZWxmLm5ld0JyYW5jaE5hbWUoKS50cmltKCkgJiYgc2VsZi5uZXdCcmFuY2hOYW1lKCkuaW5kZXhPZignICcpID09IC0xO1xuICB9KTtcbiAgdGhpcy5icmFuY2hPcmRlciA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5hYm92ZU5vZGUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuYmVsb3dOb2RlID0gdW5kZWZpbmVkO1xuICB0aGlzLnJlZlNlYXJjaEZvcm1WaXNpYmxlID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMuY29tbWl0Q29tcG9uZW50ID0gY29tcG9uZW50cy5jcmVhdGUoJ2NvbW1pdCcsIHRoaXMpO1xuICB0aGlzLnIgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY3ggPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY3kgPSBrby5vYnNlcnZhYmxlKCk7XG5cbiAgdGhpcy5kcm9wYXJlYUdyYXBoQWN0aW9ucyA9IFtcbiAgICBuZXcgR3JhcGhBY3Rpb25zLk1vdmUodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5SZWJhc2UodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5NZXJnZSh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLlB1c2godGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5SZXNldCh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLkNoZWNrb3V0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuRGVsZXRlKHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuQ2hlcnJ5UGljayh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLlVuY29tbWl0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuUmV2ZXJ0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuU3F1YXNoKHRoaXMuZ3JhcGgsIHRoaXMpXG4gIF07XG59XG5tb2R1bGUuZXhwb3J0cyA9IEdpdE5vZGVWaWV3TW9kZWw7XG5cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLmdldEdyYXBoQXR0ciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW3RoaXMuY3goKSwgdGhpcy5jeSgpXTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnNldEdyYXBoQXR0ciA9IGZ1bmN0aW9uKHZhbCkge1xuICB0aGlzLmVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ3gnLCB2YWxbMF0gLSAzMCk7XG4gIHRoaXMuZWxlbWVudCgpLnNldEF0dHJpYnV0ZSgneScsIHZhbFsxXSAtIDMwKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlZlNlYXJjaEZvcm1WaXNpYmxlKGZhbHNlKTtcbiAgaWYgKCF0aGlzLmlzSW5pdGVkKSByZXR1cm47XG4gIGlmICh0aGlzLmFuY2VzdG9yT2ZIRUFEKCkpIHtcbiAgICB0aGlzLnIoMzApO1xuICAgIHRoaXMuY3goNjEwKTtcblxuICAgIGlmICghdGhpcy5hYm92ZU5vZGUpIHtcbiAgICAgIHRoaXMuY3koMTIwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWJvdmVOb2RlLmFuY2VzdG9yT2ZIRUFEKCkpIHtcbiAgICAgIHRoaXMuY3kodGhpcy5hYm92ZU5vZGUuY3koKSArIDEyMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3kodGhpcy5hYm92ZU5vZGUuY3koKSArIDYwKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yKDE1KTtcbiAgICB0aGlzLmN4KDYxMCArICg5MCAqIHRoaXMuYnJhbmNoT3JkZXIoKSkpO1xuICAgIHRoaXMuY3kodGhpcy5hYm92ZU5vZGUgPyB0aGlzLmFib3ZlTm9kZS5jeSgpICsgNjAgOiAxMjApO1xuICB9XG5cbiAgaWYgKHRoaXMuYWJvdmVOb2RlICYmIHRoaXMuYWJvdmVOb2RlLnNlbGVjdGVkKCkpIHtcbiAgICB0aGlzLmN5KHRoaXMuYWJvdmVOb2RlLmN5KCkgKyB0aGlzLmFib3ZlTm9kZS5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLm9mZnNldEhlaWdodCArIDMwKTtcbiAgfVxuXG4gIHRoaXMuY29sb3IodGhpcy5pZGVvbG9naWNhbEJyYW5jaCgpID8gdGhpcy5pZGVvbG9naWNhbEJyYW5jaCgpLmNvbG9yIDogJyM2NjYnKTtcbiAgdGhpcy5hbmltYXRlKCk7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24obG9nRW50cnkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnRpdGxlID0gbG9nRW50cnkubWVzc2FnZS5zcGxpdCgnXFxuJylbMF07XG4gIHRoaXMucGFyZW50cyhsb2dFbnRyeS5wYXJlbnRzIHx8IFtdKTtcbiAgdGhpcy5jb21taXRUaW1lID0gbG9nRW50cnkuY29tbWl0RGF0ZTtcbiAgdGhpcy5kYXRlID0gRGF0ZS5wYXJzZSh0aGlzLmNvbW1pdFRpbWUpO1xuICB0aGlzLmNvbW1pdENvbXBvbmVudC5zZXREYXRhKGxvZ0VudHJ5KTtcbiAgdGhpcy5zaWduYXR1cmVNYWRlKGxvZ0VudHJ5LnNpZ25hdHVyZU1hZGUpO1xuICB0aGlzLnNpZ25hdHVyZURhdGUobG9nRW50cnkuc2lnbmF0dXJlRGF0ZSk7XG5cbiAgKGxvZ0VudHJ5LnJlZnMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocmVmKSB7XG4gICAgc2VsZi5ncmFwaC5nZXRSZWYocmVmKS5ub2RlKHNlbGYpO1xuICB9KTtcbiAgdGhpcy5pc0luaXRlZCA9IHRydWU7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5zaG93QnJhbmNoaW5nRm9ybSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJyYW5jaGluZ0Zvcm1WaXNpYmxlKHRydWUpO1xuICB0aGlzLm5ld0JyYW5jaE5hbWVIYXNGb2N1cyh0cnVlKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnNob3dSZWZTZWFyY2hGb3JtID0gZnVuY3Rpb24ob2JqLCBldmVudCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWZTZWFyY2hGb3JtVmlzaWJsZSh0cnVlKTtcblxuICBjb25zdCB0ZXh0Qm94ID0gZXZlbnQudGFyZ2V0Lm5leHRFbGVtZW50U2libGluZy5maXJzdEVsZW1lbnRDaGlsZDsgLy8gdGhpcyBtYXkgbm90IGJlIHRoZSBiZXN0IGlkZWEuLi5cbiAgJCh0ZXh0Qm94KS5hdXRvY29tcGxldGUoe1xuICAgIHNvdXJjZTogdGhpcy5yZWZzKCkuZmlsdGVyKHJlZiA9PiAhcmVmLmlzSEVBRCksXG4gICAgbWluTGVuZ3RoOiAwLFxuICAgIHNlbGVjdDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG4gICAgICBjb25zdCByZWYgPSB1aS5pdGVtO1xuICAgICAgY29uc3QgcmF5ID0gcmVmLmlzVGFnID8gc2VsZi50YWdzVG9EaXNwbGF5IDogc2VsZi5icmFuY2hlc1RvRGlzcGxheTtcblxuICAgICAgLy8gaWYgcmVmIGlzIGluIGRpc3BsYXksIHJlbW92ZSBpdCwgZWxzZSByZW1vdmUgbGFzdCBpbiBhcnJheS5cbiAgICAgIHJheS5zcGxpY2UocmF5LmluZGV4T2YocmVmKSwgMSk7XG4gICAgICByYXkudW5zaGlmdChyZWYpO1xuICAgICAgc2VsZi5yZWZTZWFyY2hGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgfSxcbiAgICBtZXNzYWdlczoge1xuICAgICAgbm9SZXN1bHRzOiAnJyxcbiAgICAgIHJlc3VsdHM6ICgpID0+IHt9XG4gICAgfVxuICB9KS5mb2N1cyhmdW5jdGlvbigpIHtcbiAgICAkKHRoaXMpLmF1dG9jb21wbGV0ZSgnc2VhcmNoJywgJCh0aGlzKS52YWwoKSk7XG4gIH0pLmRhdGEoXCJ1aS1hdXRvY29tcGxldGVcIikuX3JlbmRlckl0ZW0gPSBmdW5jdGlvbiAodWwsIGl0ZW0pIHtcbiAgICByZXR1cm4gJChcIjxsaT48L2xpPlwiKVxuICAgICAgLmFwcGVuZChgPGE+JHtpdGVtLmRvbX08L2E+YClcbiAgICAgIC5hcHBlbmRUbyh1bCk7XG4gIH1cbiAgJCh0ZXh0Qm94KS5hdXRvY29tcGxldGUoJ3NlYXJjaCcsICcnKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLmNyZWF0ZUJyYW5jaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY2FuQ3JlYXRlUmVmKCkpIHJldHVybjtcbiAgdGhpcy5ncmFwaC5zZXJ2ZXIucG9zdFByb21pc2UoXCIvYnJhbmNoZXNcIiwgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIG5hbWU6IHRoaXMubmV3QnJhbmNoTmFtZSgpLCBzaGExOiB0aGlzLnNoYTEgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmdyYXBoLmdldFJlZigncmVmcy9oZWFkcy8nICsgdGhpcy5uZXdCcmFuY2hOYW1lKCkpLm5vZGUodGhpcylcbiAgICAgIGlmICh1bmdpdC5jb25maWcuYXV0b0NoZWNrb3V0T25CcmFuY2hDcmVhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGguc2VydmVyLnBvc3RQcm9taXNlKFwiL2NoZWNrb3V0XCIsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBuYW1lOiB0aGlzLm5ld0JyYW5jaE5hbWUoKSB9KVxuICAgICAgfVxuICAgIH0pLmNhdGNoKChlKSA9PiB0aGlzLmdyYXBoLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpXG4gICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5icmFuY2hpbmdGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgICB0aGlzLm5ld0JyYW5jaE5hbWUoJycpO1xuICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAnYnJhbmNoLXVwZGF0ZWQnIH0pO1xuICAgIH0pO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuY3JlYXRlVGFnID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jYW5DcmVhdGVSZWYoKSkgcmV0dXJuO1xuICB0aGlzLmdyYXBoLnNlcnZlci5wb3N0UHJvbWlzZSgnL3RhZ3MnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgbmFtZTogdGhpcy5uZXdCcmFuY2hOYW1lKCksIHNoYTE6IHRoaXMuc2hhMSB9KVxuICAgIC50aGVuKCgpID0+IHRoaXMuZ3JhcGguZ2V0UmVmKCdyZWZzL3RhZ3MvJyArIHRoaXMubmV3QnJhbmNoTmFtZSgpKS5ub2RlKHRoaXMpIClcbiAgICAuY2F0Y2goKGUpID0+IHRoaXMuZ3JhcGguc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSlcbiAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmJyYW5jaGluZ0Zvcm1WaXNpYmxlKGZhbHNlKTtcbiAgICAgIHRoaXMubmV3QnJhbmNoTmFtZSgnJyk7XG4gICAgfSk7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS50b2dnbGVTZWxlY3RlZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBiZWZvcmVUaGlzQ1IgPSB0aGlzLmNvbW1pdENvbXBvbmVudC5lbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBiZWZvcmVCZWxvd0NSID0gbnVsbDtcbiAgaWYgKHRoaXMuYmVsb3dOb2RlKSB7XG4gICAgYmVmb3JlQmVsb3dDUiA9IHRoaXMuYmVsb3dOb2RlLmNvbW1pdENvbXBvbmVudC5lbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICB2YXIgcHJldlNlbGVjdGVkICA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCEocHJldlNlbGVjdGVkIGluc3RhbmNlb2YgR2l0Tm9kZVZpZXdNb2RlbCkpIHByZXZTZWxlY3RlZCA9IG51bGw7XG4gIHZhciBwcmV2U2VsZWN0ZWRDUiA9IHByZXZTZWxlY3RlZCA/IHByZXZTZWxlY3RlZC5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbDtcbiAgdGhpcy5zZWxlY3RlZCghdGhpcy5zZWxlY3RlZCgpKTtcblxuICAvLyBJZiB3ZSBhcmUgZGVzZWxlY3RpbmdcbiAgaWYgKCF0aGlzLnNlbGVjdGVkKCkpIHtcbiAgICBpZiAoYmVmb3JlVGhpc0NSLnRvcCA8IDAgJiYgYmVmb3JlQmVsb3dDUikge1xuICAgICAgdmFyIGFmdGVyQmVsb3dDUiA9IHRoaXMuYmVsb3dOb2RlLmNvbW1pdENvbXBvbmVudC5lbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIHNob3dpbmcsIHRyeSB0byBrZWVwIGl0IGluIHRoZSBzY3JlZW4gKG5vIGp1bXBpbmcpXG4gICAgICBpZiAoYmVmb3JlQmVsb3dDUi50b3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIGFmdGVyQmVsb3dDUi50b3AgLSBiZWZvcmVCZWxvd0NSLnRvcCk7XG4gICAgICAvLyBPdGhlcndpc2UganVzdCB0cnkgdG8gYnJpbmcgdGhlbSB0byB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxCeSgwLCBhZnRlckJlbG93Q1IudG9wIC0gd2luZG93LmlubmVySGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfVxuICAvLyBJZiB3ZSBhcmUgc2VsZWN0aW5nXG4gIH0gZWxzZSB7XG4gICAgdmFyIGFmdGVyVGhpc0NSID0gdGhpcy5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICgocHJldlNlbGVjdGVkQ1IgJiYgKHByZXZTZWxlY3RlZENSLnRvcCA8IDAgfHwgcHJldlNlbGVjdGVkQ1IudG9wID4gd2luZG93LmlubmVySGVpZ2h0KSkgJiZcbiAgICAgIGFmdGVyVGhpc0NSLnRvcCAhPSBiZWZvcmVUaGlzQ1IudG9wKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgLShiZWZvcmVUaGlzQ1IudG9wIC0gYWZ0ZXJUaGlzQ1IudG9wKSk7XG4gICAgICBjb25zb2xlLmxvZygnRml4Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnJlbW92ZVJlZiA9IGZ1bmN0aW9uKHJlZikge1xuICBpZiAocmVmLmlzUmVtb3RlVGFnKSB7XG4gICAgdGhpcy5yZW1vdGVUYWdzLnJlbW92ZShyZWYpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYnJhbmNoZXNBbmRMb2NhbFRhZ3MucmVtb3ZlKHJlZik7XG4gIH1cbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnB1c2hSZWYgPSBmdW5jdGlvbihyZWYpIHtcbiAgaWYgKHJlZi5pc1JlbW90ZVRhZyAmJiB0aGlzLnJlbW90ZVRhZ3MuaW5kZXhPZihyZWYpIDwgMCkge1xuICAgIHRoaXMucmVtb3RlVGFncy5wdXNoKHJlZik7XG4gIH0gZWxzZSBpZih0aGlzLmJyYW5jaGVzQW5kTG9jYWxUYWdzLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICB0aGlzLmJyYW5jaGVzQW5kTG9jYWxUYWdzLnB1c2gocmVmKTtcbiAgfVxufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UGF0aFRvQ29tbW9uQW5jZXN0b3IgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHZhciB0aGlzTm9kZSA9IHRoaXM7XG4gIHdoaWxlICh0aGlzTm9kZSAmJiAhbm9kZS5pc0FuY2VzdG9yKHRoaXNOb2RlKSkge1xuICAgIHBhdGgucHVzaCh0aGlzTm9kZSk7XG4gICAgdGhpc05vZGUgPSB0aGlzLmdyYXBoLm5vZGVzQnlJZFt0aGlzTm9kZS5wYXJlbnRzKClbMF1dO1xuICB9XG4gIGlmICh0aGlzTm9kZSkgcGF0aC5wdXNoKHRoaXNOb2RlKTtcbiAgcmV0dXJuIHBhdGg7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5pc0FuY2VzdG9yID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAobm9kZSA9PSB0aGlzKSByZXR1cm4gdHJ1ZTtcbiAgZm9yICh2YXIgdiBpbiB0aGlzLnBhcmVudHMoKSkge1xuICAgIHZhciBuID0gdGhpcy5ncmFwaC5ub2Rlc0J5SWRbdGhpcy5wYXJlbnRzKClbdl1dO1xuICAgIGlmIChuICYmIG4uaXNBbmNlc3Rvcihub2RlKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UmlnaHRUb0xlZnRTdHJpa2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdNICcgKyAodGhpcy5jeCgpIC0gMzApICsgJyAnICsgKHRoaXMuY3koKSAtIDMwKSArICcgTCAnICsgKHRoaXMuY3goKSArIDMwKSArICcgJyArICh0aGlzLmN5KCkgKyAzMCk7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5nZXRMZWZ0VG9SaWdodFN0cmlrZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ00gJyArICh0aGlzLmN4KCkgKyAzMCkgKyAnICcgKyAodGhpcy5jeSgpIC0gMzApICsgJyBMICcgKyAodGhpcy5jeCgpIC0gMzApICsgJyAnICsgKHRoaXMuY3koKSArIDMwKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLm5vZGVNb3VzZW92ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ub2RlSXNNb3VzZWhvdmVyKHRydWUpO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUubm9kZU1vdXNlb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubm9kZUlzTW91c2Vob3ZlcihmYWxzZSk7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5pc1ZpZXdhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoLm5vZGVzKCkuaW5kZXhPZih0aGlzKSA+IC0xO1xufVxuIiwidmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbnZhciBtZDUgPSByZXF1aXJlKCdibHVlaW1wLW1kNScpO1xudmFyIFNlbGVjdGFibGUgPSByZXF1aXJlKCcuL3NlbGVjdGFibGUnKTtcbnZhciBwcm9ncmFtRXZlbnRzID0gcmVxdWlyZSgndW5naXQtcHJvZ3JhbS1ldmVudHMnKTtcbnZhciBjb21wb25lbnRzID0gcmVxdWlyZSgndW5naXQtY29tcG9uZW50cycpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xuXG52YXIgUmVmVmlld01vZGVsID0gZnVuY3Rpb24oZnVsbFJlZk5hbWUsIGdyYXBoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgU2VsZWN0YWJsZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICB0aGlzLm5hbWUgPSBmdWxsUmVmTmFtZTtcbiAgdGhpcy5ub2RlID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmxvY2FsUmVmTmFtZSA9IHRoaXMubmFtZTsgLy8gb3JpZ2luL21hc3RlciBvciBtYXN0ZXJcbiAgdGhpcy5yZWZOYW1lID0gdGhpcy5uYW1lOyAvLyBtYXN0ZXJcbiAgdGhpcy5pc1JlbW90ZVRhZyA9IHRoaXMubmFtZS5pbmRleE9mKCdyZW1vdGUtdGFnOiAnKSA9PSAwO1xuICB0aGlzLmlzTG9jYWxUYWcgPSB0aGlzLm5hbWUuaW5kZXhPZigndGFnOiAnKSA9PSAwO1xuICB0aGlzLmlzVGFnID0gdGhpcy5pc0xvY2FsVGFnIHx8IHRoaXMuaXNSZW1vdGVUYWc7XG4gIHZhciBpc1JlbW90ZUJyYW5jaE9ySEVBRCA9IHRoaXMubmFtZS5pbmRleE9mKCdyZWZzL3JlbW90ZXMvJykgPT0gMDtcbiAgdGhpcy5pc0xvY2FsSEVBRCA9IHRoaXMubmFtZSA9PSAnSEVBRCc7XG4gIHRoaXMuaXNSZW1vdGVIRUFEID0gdGhpcy5uYW1lLmluZGV4T2YoJy9IRUFEJykgIT0gLTE7XG4gIHRoaXMuaXNMb2NhbEJyYW5jaCA9IHRoaXMubmFtZS5pbmRleE9mKCdyZWZzL2hlYWRzLycpID09IDA7XG4gIHRoaXMuaXNSZW1vdGVCcmFuY2ggPSBpc1JlbW90ZUJyYW5jaE9ySEVBRCAmJiAhdGhpcy5pc1JlbW90ZUhFQUQ7XG4gIHRoaXMuaXNTdGFzaCA9IHRoaXMubmFtZS5pbmRleE9mKCdyZWZzL3N0YXNoJykgPT0gMDtcbiAgdGhpcy5pc0hFQUQgPSB0aGlzLmlzTG9jYWxIRUFEIHx8IHRoaXMuaXNSZW1vdGVIRUFEO1xuICB0aGlzLmlzQnJhbmNoID0gdGhpcy5pc0xvY2FsQnJhbmNoIHx8IHRoaXMuaXNSZW1vdGVCcmFuY2g7XG4gIHRoaXMuaXNSZW1vdGUgPSBpc1JlbW90ZUJyYW5jaE9ySEVBRCB8fCB0aGlzLmlzUmVtb3RlVGFnO1xuICB0aGlzLmlzTG9jYWwgPSB0aGlzLmlzTG9jYWxCcmFuY2ggfHwgdGhpcy5pc0xvY2FsVGFnO1xuICBpZiAodGhpcy5pc0xvY2FsQnJhbmNoKSB7XG4gICAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWUuc2xpY2UoJ3JlZnMvaGVhZHMvJy5sZW5ndGgpO1xuICAgIHRoaXMucmVmTmFtZSA9IHRoaXMubG9jYWxSZWZOYW1lO1xuICB9XG4gIGlmICh0aGlzLmlzUmVtb3RlQnJhbmNoKSB7XG4gICAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWUuc2xpY2UoJ3JlZnMvcmVtb3Rlcy8nLmxlbmd0aCk7XG4gIH1cbiAgaWYgKHRoaXMuaXNMb2NhbFRhZykge1xuICAgIHRoaXMubG9jYWxSZWZOYW1lID0gdGhpcy5uYW1lLnNsaWNlKCd0YWc6IHJlZnMvdGFncy8nLmxlbmd0aCk7XG4gICAgdGhpcy5yZWZOYW1lID0gdGhpcy5sb2NhbFJlZk5hbWU7XG4gIH1cbiAgaWYgKHRoaXMuaXNSZW1vdGVUYWcpIHtcbiAgICB0aGlzLmxvY2FsUmVmTmFtZSA9IHRoaXMubmFtZS5zbGljZSgncmVtb3RlLXRhZzogJy5sZW5ndGgpO1xuICB9XG4gIGNvbnN0IHNwbGl0ZWROYW1lID0gdGhpcy5sb2NhbFJlZk5hbWUuc3BsaXQoJy8nKVxuICBpZiAodGhpcy5pc1JlbW90ZSkge1xuICAgIC8vIGdldCByaWQgb2YgdGhlIG9yaWdpbi8gcGFydCBvZiBvcmlnaW4vYnJhbmNobmFtZVxuICAgIHRoaXMucmVtb3RlID0gc3BsaXRlZE5hbWVbMF07XG4gICAgdGhpcy5yZWZOYW1lID0gc3BsaXRlZE5hbWUuc2xpY2UoMSkuam9pbignLycpO1xuICB9XG4gIHRoaXMuc2hvdyA9IHRydWU7XG4gIHRoaXMuc2VydmVyID0gdGhpcy5ncmFwaC5zZXJ2ZXI7XG4gIHRoaXMuaXNEcmFnZ2luZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmN1cnJlbnQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5pc0xvY2FsQnJhbmNoICYmIHNlbGYuZ3JhcGguY2hlY2tlZE91dEJyYW5jaCgpID09IHNlbGYucmVmTmFtZTtcbiAgfSk7XG4gIHRoaXMuY29sb3IgPSB0aGlzLl9jb2xvckZyb21IYXNoT2ZTdHJpbmcodGhpcy5uYW1lKTtcblxuICB0aGlzLm5vZGUuc3Vic2NyaWJlKGZ1bmN0aW9uKG9sZE5vZGUpIHtcbiAgICBpZiAob2xkTm9kZSkgb2xkTm9kZS5yZW1vdmVSZWYoc2VsZik7XG4gIH0sIG51bGwsIFwiYmVmb3JlQ2hhbmdlXCIpO1xuICB0aGlzLm5vZGUuc3Vic2NyaWJlKGZ1bmN0aW9uKG5ld05vZGUpIHtcbiAgICBpZiAobmV3Tm9kZSkgbmV3Tm9kZS5wdXNoUmVmKHNlbGYpO1xuICB9KTtcblxuICAvLyBUaGlzIG9wdGltaXphdGlvbiBpcyBmb3IgYXV0b2NvbXBsZXRlIGRpc3BsYXlcbiAgdGhpcy52YWx1ZSA9IHNwbGl0ZWROYW1lW3NwbGl0ZWROYW1lLmxlbmd0aCAtIDFdXG4gIHRoaXMubGFiZWwgPSB0aGlzLmxvY2FsUmVmTmFtZVxuICB0aGlzLmRvbSA9IGAke3RoaXMubG9jYWxSZWZOYW1lfTxzcGFuIGNsYXNzPSdvY3RpY29uICR7dGhpcy5pc1RhZyA/ICdvY3RpY29uLXRhZycgOiAnb2N0aWNvbi1naXQtYnJhbmNoJ30nPjwvc3Bhbj5gXG4gIHRoaXMuZGlzcGxheU5hbWUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJlZml4ID0gJydcbiAgICBpZiAoc2VsZi5pc1JlbW90ZSkge1xuICAgICAgcHJlZml4ID0gJzxzcGFuIGNsYXNzPVwib2N0aWNvbiBvY3RpY29uLWJyb2FkY2FzdFwiPjwvc3Bhbj4gJztcbiAgICB9XG4gICAgaWYgKHNlbGYuaXNCcmFuY2gpIHtcbiAgICAgIHByZWZpeCArPSAnPHNwYW4gY2xhc3M9XCJvY3RpY29uIG9jdGljb24tZ2l0LWJyYW5jaFwiPjwvc3Bhbj4gJztcbiAgICB9IGVsc2UgaWYgKHNlbGYuY3VycmVudCgpKSB7XG4gICAgICBwcmVmaXggKz0gJzxzcGFuIGNsYXNzPVwib2N0aWNvbiBvY3RpY29uLWNoZXZyb24tcmlnaHRcIj48L3NwYW4+ICc7XG4gICAgfSBlbHNlIGlmIChzZWxmLmlzVGFnKSB7XG4gICAgICBwcmVmaXggKz0gJzxzcGFuIGNsYXNzPVwib2N0aWNvbiBvY3RpY29uLXRhZ1wiPjwvc3Bhbj4gJztcbiAgICB9XG4gICAgcmV0dXJuIHByZWZpeCArIHNlbGYubG9jYWxSZWZOYW1lO1xuICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFJlZlZpZXdNb2RlbDtcblxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5fY29sb3JGcm9tSGFzaE9mU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHJldHVybiAnIycgKyBtZDUoc3RyaW5nKS50b1N0cmluZygpLnNsaWNlKDAsIDYpO1xufVxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5kcmFnU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCh0aGlzKTtcbiAgdGhpcy5pc0RyYWdnaW5nKHRydWUpO1xuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG59XG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmRyYWdFbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dChudWxsKTtcbiAgdGhpcy5pc0RyYWdnaW5nKGZhbHNlKTtcbn1cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24odGFyZ2V0LCByZXdpbmRXYXJuT3ZlcnJpZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvbWlzZTtcbiAgaWYgKHRoaXMuaXNMb2NhbCkge1xuICAgIHZhciB0b05vZGUgPSB0aGlzLmdyYXBoLm5vZGVzQnlJZFt0YXJnZXRdO1xuICAgIHZhciBhcmdzID0geyBwYXRoOiBzZWxmLmdyYXBoLnJlcG9QYXRoKCksIG5hbWU6IHNlbGYucmVmTmFtZSwgc2hhMTogdGFyZ2V0LCBmb3JjZTogdHJ1ZSwgdG86IHRhcmdldCwgbW9kZTogJ2hhcmQnIH07XG4gICAgdmFyIG9wZXJhdGlvbjtcbiAgICBpZiAodGhpcy5jdXJyZW50KCkpIHtcbiAgICAgIG9wZXJhdGlvbiA9ICcvcmVzZXQnO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1RhZykge1xuICAgICAgb3BlcmF0aW9uID0gJy90YWdzJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlcmF0aW9uID0gJy9icmFuY2hlcyc7XG4gICAgfVxuXG4gICAgaWYgKCFyZXdpbmRXYXJuT3ZlcnJpZGUgJiYgdGhpcy5ub2RlKCkuZGF0ZSA+IHRvTm9kZS5kYXRlKSB7XG4gICAgICBwcm9taXNlID0gY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0FyZSB5b3Ugc3VyZT8nLCBkZXRhaWxzOiAnVGhpcyBvcGVyYXRpb24gcG90ZW50aWFsbHkgZ29pbmcgYmFjayBpbiBoaXN0b3J5Lid9KVxuICAgICAgICAuc2hvdygpXG4gICAgICAgIC5jbG9zZVRoZW4oZnVuY3Rpb24oZGlhZykge1xuICAgICAgICAgIGlmIChkaWFnLnJlc3VsdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zZXJ2ZXIucG9zdFByb21pc2Uob3BlcmF0aW9uLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNsb3NlUHJvbWlzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IHNlbGYuc2VydmVyLnBvc3RQcm9taXNlKG9wZXJhdGlvbiwgYXJncyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwdXNoUmVxID0geyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIHJlbW90ZTogdGhpcy5yZW1vdGUsIHJlZlNwZWM6IHRhcmdldCwgcmVtb3RlQnJhbmNoOiB0aGlzLnJlZk5hbWUgfTtcbiAgICBwcm9taXNlID0gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9wdXNoJywgcHVzaFJlcSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVyci5lcnJvckNvZGUgPT09ICdub24tZmFzdC1mb3J3YXJkJykge1xuICAgICAgICAgIHJldHVybiBjb21wb25lbnRzLmNyZWF0ZSgneWVzbm9kaWFsb2cnLCB7IHRpdGxlOiAnRm9yY2UgcHVzaD8nLCBkZXRhaWxzOiAnVGhlIHJlbW90ZSBicmFuY2ggY2FuXFwndCBiZSBmYXN0LWZvcndhcmRlZC4nIH0pXG4gICAgICAgICAgICAuc2hvdygpXG4gICAgICAgICAgICAuY2xvc2VUaGVuKGZ1bmN0aW9uKGRpYWcpIHtcbiAgICAgICAgICAgICAgaWYgKCFkaWFnLnJlc3VsdCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIHB1c2hSZXEuZm9yY2UgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zZXJ2ZXIucG9zdFByb21pc2UoJy9wdXNoJywgcHVzaFJlcSk7XG4gICAgICAgICAgICB9KS5jbG9zZVByb21pc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2VcbiAgICAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgIGlmICghcmVzKSByZXR1cm47XG4gICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHNlbGYuZ3JhcGguZ2V0Tm9kZSh0YXJnZXQpO1xuICAgICAgaWYgKHNlbGYuZ3JhcGguY2hlY2tlZE91dEJyYW5jaCgpID09IHNlbGYucmVmTmFtZSkge1xuICAgICAgICBzZWxmLmdyYXBoLkhFQURyZWYoKS5ub2RlKHRhcmdldE5vZGUpO1xuICAgICAgfVxuICAgICAgc2VsZi5ub2RlKHRhcmdldE5vZGUpO1xuICAgIH0pLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpO1xufVxuXG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGlzQ2xpZW50T25seSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmwgPSB0aGlzLmlzVGFnID8gJy90YWdzJyA6ICcvYnJhbmNoZXMnO1xuICBpZiAodGhpcy5pc1JlbW90ZSkgdXJsID0gJy9yZW1vdGUnICsgdXJsO1xuXG4gIHJldHVybiAoaXNDbGllbnRPbmx5ID8gUHJvbWlzZS5yZXNvbHZlKCkgOiB0aGlzLnNlcnZlci5kZWxQcm9taXNlKHVybCwgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIHJlbW90ZTogdGhpcy5pc1JlbW90ZSA/IHRoaXMucmVtb3RlIDogbnVsbCwgbmFtZTogdGhpcy5yZWZOYW1lIH0pKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLm5vZGUoKSkgdGhpcy5ub2RlKCkucmVtb3ZlUmVmKHNlbGYpO1xuICAgICAgdGhpcy5ncmFwaC5yZWZzLnJlbW92ZShzZWxmKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyYXBoLnJlZnNCeVJlZk5hbWVbc2VsZi5uYW1lXTtcbiAgICB9KS5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKVxuICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgIGlmICghaXNDbGllbnRPbmx5KSB7XG4gICAgICAgIGlmICh1cmwgPT0gJy9yZW1vdGUvdGFncycpIHtcbiAgICAgICAgICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdyZXF1ZXN0LWZldGNoLXRhZ3MnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ2JyYW5jaC11cGRhdGVkJyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xufVxuXG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmdldExvY2FsUmVmID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoLmdldFJlZih0aGlzLmdldExvY2FsUmVmRnVsbE5hbWUoKSwgZmFsc2UpO1xufVxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5nZXRMb2NhbFJlZkZ1bGxOYW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzUmVtb3RlQnJhbmNoKSByZXR1cm4gJ3JlZnMvaGVhZHMvJyArIHRoaXMucmVmTmFtZTtcbiAgaWYgKHRoaXMuaXNSZW1vdGVUYWcpIHJldHVybiAndGFnOiAnICsgdGhpcy5yZWZOYW1lO1xuICByZXR1cm4gbnVsbDtcbn1cblxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5nZXRSZW1vdGVSZWYgPSBmdW5jdGlvbihyZW1vdGUpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGguZ2V0UmVmKHRoaXMuZ2V0UmVtb3RlUmVmRnVsbE5hbWUocmVtb3RlKSwgZmFsc2UpO1xufVxuXG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmdldFJlbW90ZVJlZkZ1bGxOYW1lID0gZnVuY3Rpb24ocmVtb3RlKSB7XG4gIGlmICh0aGlzLmlzTG9jYWxCcmFuY2gpIHJldHVybiAncmVmcy9yZW1vdGVzLycgKyByZW1vdGUgKyAnLycgKyB0aGlzLnJlZk5hbWU7XG4gIGlmICh0aGlzLmlzTG9jYWxUYWcpIHJldHVybiAncmVtb3RlLXRhZzogJyArIHJlbW90ZSArICcvJyArIHRoaXMucmVmTmFtZTtcbiAgcmV0dXJuIG51bGw7XG59XG5cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuY2FuQmVQdXNoZWQgPSBmdW5jdGlvbihyZW1vdGUpIHtcbiAgaWYgKCF0aGlzLmlzTG9jYWwpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFyZW1vdGUpIHJldHVybiBmYWxzZTtcbiAgdmFyIHJlbW90ZVJlZiA9IHRoaXMuZ2V0UmVtb3RlUmVmKHJlbW90ZSk7XG4gIGlmICghcmVtb3RlUmVmKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHRoaXMubm9kZSgpICE9IHJlbW90ZVJlZi5ub2RlKCk7XG59XG5cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuY3JlYXRlUmVtb3RlUmVmID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvcHVzaCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCByZW1vdGU6IHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpLCByZWZTcGVjOiB0aGlzLnJlZk5hbWUsIHJlbW90ZUJyYW5jaDogdGhpcy5yZWZOYW1lIH0pXG4gICAgLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpO1xufVxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5jaGVja291dCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBpc1JlbW90ZSA9IHRoaXMuaXNSZW1vdGVCcmFuY2g7XG4gIGNvbnN0IGlzTG9jYWxDdXJyZW50ID0gdGhpcy5nZXRMb2NhbFJlZigpICYmIHRoaXMuZ2V0TG9jYWxSZWYoKS5jdXJyZW50KCk7XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKGlzUmVtb3RlICYmICFpc0xvY2FsQ3VycmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9icmFuY2hlcycsIHtcbiAgICAgICAgICBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksXG4gICAgICAgICAgbmFtZTogdGhpcy5yZWZOYW1lLFxuICAgICAgICAgIHNoYTE6IHRoaXMubmFtZSxcbiAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS50aGVuKCgpID0+IHRoaXMuc2VydmVyLnBvc3RQcm9taXNlKCcvY2hlY2tvdXQnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgbmFtZTogdGhpcy5yZWZOYW1lIH0pKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGlmIChpc1JlbW90ZSAmJiBpc0xvY2FsQ3VycmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9yZXNldCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCB0bzogdGhpcy5uYW1lLCBtb2RlOiAnaGFyZCcgfSk7XG4gICAgICB9XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmdyYXBoLkhFQURyZWYoKS5ub2RlKHRoaXMubm9kZSgpKTtcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyLmVycm9yQ29kZSAhPSAnbWVyZ2UtZmFpbGVkJykgdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGVycik7XG4gICAgfSk7XG59XG4iLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG52YXIgR2l0Tm9kZVZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vZ2l0LW5vZGUnKTtcbnZhciBHaXRSZWZWaWV3TW9kZWwgPSByZXF1aXJlKCcuL2dpdC1yZWYnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG52YXIgRWRnZVZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vZWRnZScpO1xudmFyIG51bWJlck9mTm9kZXNQZXJMb2FkID0gdW5naXQuY29uZmlnLm51bWJlck9mTm9kZXNQZXJMb2FkO1xuXG5jb21wb25lbnRzLnJlZ2lzdGVyKCdncmFwaCcsIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgcmV0dXJuIG5ldyBHcmFwaFZpZXdNb2RlbChhcmdzLnNlcnZlciwgYXJncy5yZXBvUGF0aCk7XG59KTtcblxuZnVuY3Rpb24gR3JhcGhWaWV3TW9kZWwoc2VydmVyLCByZXBvUGF0aCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucmVwb1BhdGggPSByZXBvUGF0aDtcbiAgdGhpcy5saW1pdCA9IGtvLm9ic2VydmFibGUobnVtYmVyT2ZOb2Rlc1BlckxvYWQpO1xuICB0aGlzLnNraXAgPSBrby5vYnNlcnZhYmxlKDApO1xuICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgdGhpcy5jdXJyZW50UmVtb3RlID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLm5vZGVzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMuZWRnZXMgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgdGhpcy5yZWZzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMubm9kZXNCeUlkID0ge307XG4gIHRoaXMucmVmc0J5UmVmTmFtZSA9IHt9O1xuICB0aGlzLmNoZWNrZWRPdXRCcmFuY2ggPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY2hlY2tlZE91dFJlZiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLmNoZWNrZWRPdXRCcmFuY2goKSA/IHNlbGYuZ2V0UmVmKCdyZWZzL2hlYWRzLycgKyBzZWxmLmNoZWNrZWRPdXRCcmFuY2goKSkgOiBudWxsO1xuICB9KTtcbiAgdGhpcy5IRUFEcmVmID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLkhFQUQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5IRUFEcmVmKCkgPyBzZWxmLkhFQURyZWYoKS5ub2RlKCkgOiB1bmRlZmluZWQ7XG4gIH0pO1xuICB0aGlzLmNvbW1pdE5vZGVDb2xvciA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLkhFQUQoKSA/IHNlbGYuSEVBRCgpLmNvbG9yKCkgOiAnIzRBNEE0QSc7XG4gIH0pO1xuICB0aGlzLmNvbW1pdE5vZGVFZGdlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFzZWxmLkhFQUQoKSB8fCAhc2VsZi5IRUFEKCkuY3goKSB8fCAhc2VsZi5IRUFEKCkuY3koKSkgcmV0dXJuO1xuICAgIHJldHVybiBcIk0gNjEwIDY4IEwgXCIgKyBzZWxmLkhFQUQoKS5jeCgpICsgXCIgXCIgKyBzZWxmLkhFQUQoKS5jeSgpO1xuICB9KTtcbiAgdGhpcy5zaG93Q29tbWl0Tm9kZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0ID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmVkZ2VzQnlJZCA9IHt9O1xuICB0aGlzLnNjcm9sbGVkVG9FbmQgPSBfLmRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYubGltaXQobnVtYmVyT2ZOb2Rlc1BlckxvYWQgKyBzZWxmLmxpbWl0KCkpO1xuICAgIHNlbGYubG9hZE5vZGVzRnJvbUFwaSgpO1xuICB9LCA1MDAsIHRydWUpO1xuICB0aGlzLmxvYWRBaGVhZCA9IF8uZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuc2tpcCgpIDw9IDApIHJldHVybjtcbiAgICBzZWxmLnNraXAoTWF0aC5tYXgoc2VsZi5za2lwKCkgLSBudW1iZXJPZk5vZGVzUGVyTG9hZCwgMCkpO1xuICAgIHNlbGYubG9hZE5vZGVzRnJvbUFwaSgpO1xuICB9LCA1MDAsIHRydWUpO1xuICB0aGlzLmRpbUNvbW1pdCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNvbW1pdE9wYWNpdHkgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuZGltQ29tbWl0KCkgPyAwLjEgOiAxOyB9KTtcbiAgdGhpcy5oZWlnaHN0QnJhbmNoT3JkZXIgPSAwO1xuICB0aGlzLmhvdmVyR3JhcGhBY3Rpb25HcmFwaGljID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmhvdmVyR3JhcGhBY3Rpb25HcmFwaGljLnN1YnNjcmliZShmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5kZXN0cm95KVxuICAgICAgdmFsdWUuZGVzdHJveSgpO1xuICB9LCBudWxsLCAnYmVmb3JlQ2hhbmdlJyk7XG5cbiAgdGhpcy5ob3ZlckdyYXBoQWN0aW9uID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmhvdmVyR3JhcGhBY3Rpb24uc3Vic2NyaWJlKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmNyZWF0ZUhvdmVyR3JhcGhpYykge1xuICAgICAgc2VsZi5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpYyh2YWx1ZS5jcmVhdGVIb3ZlckdyYXBoaWMoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuaG92ZXJHcmFwaEFjdGlvbkdyYXBoaWMobnVsbCk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmxvYWROb2Rlc0Zyb21BcGlUaHJvdHRsZWQgPSBfLnRocm90dGxlKHRoaXMubG9hZE5vZGVzRnJvbUFwaS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgdGhpcy51cGRhdGVCcmFuY2hlc1Rocm90dGxlZCA9IF8udGhyb3R0bGUodGhpcy51cGRhdGVCcmFuY2hlcy5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgdGhpcy5sb2FkTm9kZXNGcm9tQXBpKCk7XG4gIHRoaXMudXBkYXRlQnJhbmNoZXMoKTtcbiAgdGhpcy5ncmFwaFdpZHRoID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmdyYXBoSGVpZ2h0ID0ga28ub2JzZXJ2YWJsZSg4MDApO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUudXBkYXRlTm9kZSA9IGZ1bmN0aW9uKHBhcmVudEVsZW1lbnQpIHtcbiAga28ucmVuZGVyVGVtcGxhdGUoJ2dyYXBoJywgdGhpcywge30sIHBhcmVudEVsZW1lbnQpO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uKHNoYTEsIGxvZ0VudHJ5KSB7XG4gIHZhciBub2RlVmlld01vZGVsID0gdGhpcy5ub2Rlc0J5SWRbc2hhMV07XG4gIGlmICghbm9kZVZpZXdNb2RlbCkgbm9kZVZpZXdNb2RlbCA9IHRoaXMubm9kZXNCeUlkW3NoYTFdID0gbmV3IEdpdE5vZGVWaWV3TW9kZWwodGhpcywgc2hhMSk7XG4gIGlmIChsb2dFbnRyeSkgbm9kZVZpZXdNb2RlbC5zZXREYXRhKGxvZ0VudHJ5KTtcbiAgcmV0dXJuIG5vZGVWaWV3TW9kZWw7XG59XG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UmVmID0gZnVuY3Rpb24ocmVmLCBjb25zdHJ1Y3RJZlVuYXZhaWxhYmxlKSB7XG4gIGlmIChjb25zdHJ1Y3RJZlVuYXZhaWxhYmxlID09PSB1bmRlZmluZWQpIGNvbnN0cnVjdElmVW5hdmFpbGFibGUgPSB0cnVlO1xuICB2YXIgcmVmVmlld01vZGVsID0gdGhpcy5yZWZzQnlSZWZOYW1lW3JlZl07XG4gIGlmICghcmVmVmlld01vZGVsICYmIGNvbnN0cnVjdElmVW5hdmFpbGFibGUpIHtcbiAgICByZWZWaWV3TW9kZWwgPSB0aGlzLnJlZnNCeVJlZk5hbWVbcmVmXSA9IG5ldyBHaXRSZWZWaWV3TW9kZWwocmVmLCB0aGlzKTtcbiAgICB0aGlzLnJlZnMucHVzaChyZWZWaWV3TW9kZWwpO1xuICAgIGlmIChyZWZWaWV3TW9kZWwubmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLkhFQURyZWYocmVmVmlld01vZGVsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZlZpZXdNb2RlbDtcbn1cblxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLmxvYWROb2Rlc0Zyb21BcGkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbm9kZVNpemUgPSBzZWxmLm5vZGVzKCkubGVuZ3RoO1xuXG4gIHJldHVybiB0aGlzLnNlcnZlci5nZXRQcm9taXNlKCcvZ2l0bG9nJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIGxpbWl0OiB0aGlzLmxpbWl0KCksIHNraXA6IHRoaXMuc2tpcCgpIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24obG9nKSB7XG4gICAgICAvLyBzZXQgbmV3IGxpbWl0IGFuZCBza2lwXG4gICAgICBzZWxmLmxpbWl0KHBhcnNlSW50KGxvZy5saW1pdCkpO1xuICAgICAgc2VsZi5za2lwKHBhcnNlSW50KGxvZy5za2lwKSk7XG4gICAgICByZXR1cm4gbG9nLm5vZGVzIHx8IFtdO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbmQvb3IgY2FsY3VsYXRlIG5vZGVzXG4gICAgICByZXR1cm4gc2VsZi5jb21wdXRlTm9kZShub2Rlcy5tYXAoKGxvZ0VudHJ5KSA9PiB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldE5vZGUobG9nRW50cnkuc2hhMSwgbG9nRW50cnkpOyAgICAgLy8gY29udmVydCB0byBub2RlIG9iamVjdFxuICAgICAgfSkpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgIC8vIGNyZWF0ZSBlZGdlc1xuICAgICAgdmFyIGVkZ2VzID0gW107XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnRzKCkuZm9yRWFjaChmdW5jdGlvbihwYXJlbnRTaGExKSB7XG4gICAgICAgICAgZWRnZXMucHVzaChzZWxmLmdldEVkZ2Uobm9kZS5zaGExLCBwYXJlbnRTaGExKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2RlLnJlbmRlcigpO1xuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuZWRnZXMoZWRnZXMpO1xuICAgICAgc2VsZi5ub2Rlcyhub2Rlcyk7XG4gICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLmdyYXBoSGVpZ2h0KG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLmN5KCkgKyA4MCk7XG4gICAgICB9XG4gICAgICBzZWxmLmdyYXBoV2lkdGgoMTAwMCArIChzZWxmLmhlaWdoc3RCcmFuY2hPcmRlciAqIDkwKSk7XG4gICAgfSkuY2F0Y2goKGUpID0+IHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSlcbiAgICAuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgIGlmICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBzZWxmLmdyYXBoSGVpZ2h0KCkgPiAwICYmIG5vZGVTaXplICE9IHNlbGYubm9kZXMoKS5sZW5ndGgpIHtcbiAgICAgICAgc2VsZi5zY3JvbGxlZFRvRW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS50cmF2ZXJzZU5vZGVMZWZ0UGFyZW50cyA9IGZ1bmN0aW9uKG5vZGUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKG5vZGUpO1xuICB2YXIgcGFyZW50ID0gdGhpcy5ub2Rlc0J5SWRbbm9kZS5wYXJlbnRzKClbMF1dO1xuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy50cmF2ZXJzZU5vZGVMZWZ0UGFyZW50cyhwYXJlbnQsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuY29tcHV0ZU5vZGUgPSBmdW5jdGlvbihub2Rlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgbm9kZXMgPSBub2RlcyB8fCB0aGlzLm5vZGVzKCk7XG5cbiAgdGhpcy5tYXJrTm9kZXNJZGVvbG9naWNhbEJyYW5jaGVzKHRoaXMucmVmcygpLCBub2RlcywgdGhpcy5ub2Rlc0J5SWQpO1xuXG4gIHZhciB1cGRhdGVUaW1lU3RhbXAgPSBtb21lbnQoKS52YWx1ZU9mKCk7XG4gIGlmICh0aGlzLkhFQUQoKSkge1xuICAgIHRoaXMudHJhdmVyc2VOb2RlTGVmdFBhcmVudHModGhpcy5IRUFEKCksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUuYW5jZXN0b3JPZkhFQURUaW1lU3RhbXAgPSB1cGRhdGVUaW1lU3RhbXA7XG4gICAgfSk7XG4gIH1cblxuICAvLyBGaWx0ZXIgb3V0IG5vZGVzIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIGJyYW5jaCAoc3RhZ2luZyBhbmQgb3JwaGFuZWQgbm9kZXMpXG4gIG5vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUuaWRlb2xvZ2ljYWxCcmFuY2goKSAmJiAhbm9kZS5pZGVvbG9naWNhbEJyYW5jaCgpLmlzU3Rhc2gpIHx8IG5vZGUuYW5jZXN0b3JPZkhFQURUaW1lU3RhbXAgPT0gdXBkYXRlVGltZVN0YW1wO1xuICB9KTtcblxuICB2YXIgYnJhbmNoU2xvdENvdW50ZXIgPSB0aGlzLkhFQUQoKSA/IDEgOiAwO1xuXG4gIC8vIFRoZW4gaXRlcmF0ZSBmcm9tIHRoZSBib3R0b20gdG8gZml4IHRoZSBvcmRlcnMgb2YgdGhlIGJyYW5jaGVzXG4gIGZvciAodmFyIGkgPSBub2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKG5vZGUuYW5jZXN0b3JPZkhFQURUaW1lU3RhbXAgPT0gdXBkYXRlVGltZVN0YW1wKSBjb250aW51ZTtcbiAgICB2YXIgaWRlb2xvZ2ljYWxCcmFuY2ggPSBub2RlLmlkZW9sb2dpY2FsQnJhbmNoKCk7XG5cbiAgICAvLyBGaXJzdCBvY2N1cnJlbmNlIG9mIHRoZSBicmFuY2gsIGZpbmQgYW4gZW1wdHkgc2xvdCBmb3IgdGhlIGJyYW5jaFxuICAgIGlmIChpZGVvbG9naWNhbEJyYW5jaC5sYXN0U2xvdHRlZFRpbWVTdGFtcCAhPSB1cGRhdGVUaW1lU3RhbXApIHtcbiAgICAgIGlkZW9sb2dpY2FsQnJhbmNoLmxhc3RTbG90dGVkVGltZVN0YW1wID0gdXBkYXRlVGltZVN0YW1wO1xuICAgICAgaWRlb2xvZ2ljYWxCcmFuY2guYnJhbmNoT3JkZXIgPSBicmFuY2hTbG90Q291bnRlcisrXG4gICAgfVxuXG4gICAgbm9kZS5icmFuY2hPcmRlcihpZGVvbG9naWNhbEJyYW5jaC5icmFuY2hPcmRlcik7XG4gIH1cblxuICBzZWxmLmhlaWdoc3RCcmFuY2hPcmRlciA9IGJyYW5jaFNsb3RDb3VudGVyIC0gMTtcbiAgdmFyIHByZXZOb2RlO1xuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmFuY2VzdG9yT2ZIRUFEKG5vZGUuYW5jZXN0b3JPZkhFQURUaW1lU3RhbXAgPT0gdXBkYXRlVGltZVN0YW1wKTtcbiAgICBpZiAobm9kZS5hbmNlc3Rvck9mSEVBRCgpKSBub2RlLmJyYW5jaE9yZGVyKDApO1xuICAgIG5vZGUuYWJvdmVOb2RlID0gcHJldk5vZGU7XG4gICAgaWYgKHByZXZOb2RlKSBwcmV2Tm9kZS5iZWxvd05vZGUgPSBub2RlO1xuICAgIHByZXZOb2RlID0gbm9kZTtcbiAgfSk7XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0RWRnZSA9IGZ1bmN0aW9uKG5vZGVBc2hhMSwgbm9kZUJzaGExKSB7XG4gIHZhciBpZCA9IG5vZGVBc2hhMSArICctJyArIG5vZGVCc2hhMTtcbiAgdmFyIGVkZ2UgPSB0aGlzLmVkZ2VzQnlJZFtpZF07XG4gIGlmICghZWRnZSkge1xuICAgIGVkZ2UgPSB0aGlzLmVkZ2VzQnlJZFtpZF0gPSBuZXcgRWRnZVZpZXdNb2RlbCh0aGlzLCBub2RlQXNoYTEsIG5vZGVCc2hhMSk7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbkdyYXBoVmlld01vZGVsLl9tYXJrSWRlb2xvZ2ljYWxTdGFtcCA9IDA7XG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUubWFya05vZGVzSWRlb2xvZ2ljYWxCcmFuY2hlcyA9IGZ1bmN0aW9uKHJlZnMsIG5vZGVzLCBub2Rlc0J5SWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZWZzID0gcmVmcy5maWx0ZXIoZnVuY3Rpb24ocikgeyByZXR1cm4gISFyLm5vZGUoKTsgfSk7XG4gIHJlZnMgPSByZWZzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIGlmIChhLmlzTG9jYWwgJiYgIWIuaXNMb2NhbCkgcmV0dXJuIC0xO1xuICAgIGlmIChiLmlzTG9jYWwgJiYgIWEuaXNMb2NhbCkgcmV0dXJuIDE7XG4gICAgaWYgKGEuaXNCcmFuY2ggJiYgIWIuaXNCcmFuY2gpIHJldHVybiAtMTtcbiAgICBpZiAoYi5pc0JyYW5jaCAmJiAhYS5pc0JyYW5jaCkgcmV0dXJuIDE7XG4gICAgaWYgKGEuaXNIRUFEICYmICFiLmlzSEVBRCkgcmV0dXJuIDE7XG4gICAgaWYgKCFhLmlzSEVBRCAmJiBiLmlzSEVBRCkgcmV0dXJuIC0xO1xuICAgIGlmIChhLmlzU3Rhc2ggJiYgIWIuaXNTdGFzaCkgcmV0dXJuIDE7XG4gICAgaWYgKGIuaXNTdGFzaCAmJiAhYS5pc1N0YXNoKSByZXR1cm4gLTE7XG4gICAgaWYgKGEubm9kZSgpICYmIGEubm9kZSgpLmRhdGUgJiYgYi5ub2RlKCkgJiYgYi5ub2RlKCkuZGF0ZSlcbiAgICAgIHJldHVybiBhLm5vZGUoKS5kYXRlIC0gYi5ub2RlKCkuZGF0ZTtcbiAgICByZXR1cm4gYS5yZWZOYW1lIDwgYi5yZWZOYW1lID8gLTEgOiAxO1xuICB9KTtcbiAgdmFyIHN0YW1wID0gR3JhcGhWaWV3TW9kZWwuX21hcmtJZGVvbG9naWNhbFN0YW1wKys7XG4gIHJlZnMuZm9yRWFjaChmdW5jdGlvbihyZWYpIHtcbiAgICBzZWxmLnRyYXZlcnNlTm9kZVBhcmVudHMocmVmLm5vZGUoKSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUuc3RhbXAgPT0gc3RhbXApIHJldHVybiBmYWxzZTtcbiAgICAgIG5vZGUuc3RhbXAgPSBzdGFtcDtcbiAgICAgIG5vZGUuaWRlb2xvZ2ljYWxCcmFuY2gocmVmKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLnRyYXZlcnNlTm9kZVBhcmVudHMgPSBmdW5jdGlvbihub2RlLCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrKG5vZGUpKSByZXR1cm4gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wYXJlbnRzKCkubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBpZiBwYXJlbnQsIHRyYXZlcnMgcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHRoaXMubm9kZXNCeUlkW25vZGUucGFyZW50cygpW2ldXTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLnRyYXZlcnNlTm9kZVBhcmVudHMocGFyZW50LCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59XG5cbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS5oYW5kbGVCdWJibGVkQ2xpY2sgPSBmdW5jdGlvbihlbGVtLCBldmVudCkge1xuICAvLyBJZiB0aGUgY2xpY2tlZCBlbGVtZW50IGlzIGJvdW5kIHRvIHRoZSBjdXJyZW50IGFjdGlvbiBjb250ZXh0LFxuICAvLyB0aGVuIGxldCdzIG5vdCBkZXNlbGVjdCBpdC5cbiAgaWYgKGtvLmRhdGFGb3IoZXZlbnQudGFyZ2V0KSA9PT0gdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCgpKSByZXR1cm47XG4gIGlmICh0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgJiYgdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgR2l0Tm9kZVZpZXdNb2RlbCkge1xuICAgIHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQoKS50b2dnbGVTZWxlY3RlZCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQobnVsbCk7XG4gIH1cbiAgLy8gSWYgdGhlIGNsaWNrIHdhcyBvbiBhbiBpbnB1dCBlbGVtZW50LCB0aGVuIGxldCdzIGFsbG93IHRoZSBkZWZhdWx0IGFjdGlvbiB0byBwcm9jZWVkLlxuICAvLyBUaGlzIGlzIGVzcGVjaWFsbHkgbmVlZGVkIHNpbmNlIGZvciBzb21lIHN0cmFuZ2UgcmVhc29uIGFueSBzdWJtaXQgKGllLiBlbnRlciBpbiBhIHRleHRib3gpXG4gIC8vIHdpbGwgdHJpZ2dlciBhIGNsaWNrIGV2ZW50IG9uIHRoZSBzdWJtaXQgaW5wdXQgb2YgdGhlIGZvcm0sIHdoaWNoIHdpbGwgZW5kIHVwIGhlcmUsXG4gIC8vIGFuZCBpZiB3ZSBkb24ndCByZXR1cm4gdHJ1ZSwgdGhlbiB0aGUgc3VibWl0IGV2ZW50IGlzIG5ldmVyIGZpcmVkLCBicmVha2luZyBzdHVmZi5cbiAgaWYgKGV2ZW50LnRhcmdldC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykgcmV0dXJuIHRydWU7XG59XG5cbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS5vblByb2dyYW1FdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGlmIChldmVudC5ldmVudCA9PSAnZ2l0LWRpcmVjdG9yeS1jaGFuZ2VkJykge1xuICAgIHRoaXMubG9hZE5vZGVzRnJvbUFwaVRocm90dGxlZCgpO1xuICAgIHRoaXMudXBkYXRlQnJhbmNoZXNUaHJvdHRsZWQoKTtcbiAgfSBlbHNlIGlmIChldmVudC5ldmVudCA9PSAncmVxdWVzdC1hcHAtY29udGVudC1yZWZyZXNoJykge1xuICAgIHRoaXMubG9hZE5vZGVzRnJvbUFwaVRocm90dGxlZCgpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09ICdyZW1vdGUtdGFncy11cGRhdGUnKSB7XG4gICAgdGhpcy5zZXRSZW1vdGVUYWdzKGV2ZW50LnRhZ3MpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09ICdjdXJyZW50LXJlbW90ZS1jaGFuZ2VkJykge1xuICAgIHRoaXMuY3VycmVudFJlbW90ZShldmVudC5uZXdSZW1vdGUpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09ICdncmFwaC1yZW5kZXInKSB7XG4gICAgdGhpcy5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS5yZW5kZXIoKTtcbiAgICB9KTtcbiAgfVxufVxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLnVwZGF0ZUJyYW5jaGVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnNlcnZlci5nZXRQcm9taXNlKCcvY2hlY2tvdXQnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKHJlcykgeyBzZWxmLmNoZWNrZWRPdXRCcmFuY2gocmVzKTsgfSlcbiAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyLmVycm9yQ29kZSAhPSAnbm90LWEtcmVwb3NpdG9yeScpIHNlbGYuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlcnIpO1xuICAgIH0pXG59XG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuc2V0UmVtb3RlVGFncyA9IGZ1bmN0aW9uKHJlbW90ZVRhZ3MpIHtcbiAgY29uc3QgdmVyc2lvbiA9IERhdGUubm93KCk7XG4gIHJlbW90ZVRhZ3MuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgaWYgKHJlZi5uYW1lLmluZGV4T2YoJ157fScpICE9PSAtMSkge1xuICAgICAgY29uc3QgdGFnUmVmID0gcmVmLm5hbWUuc2xpY2UoMCwgcmVmLm5hbWUubGVuZ3RoIC0gJ157fScubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5hbWUgPSBgcmVtb3RlLXRhZzogJHtyZWYucmVtb3RlfS8ke3RhZ1JlZi5zcGxpdCgnLycpWzJdfWA7XG4gICAgICB0aGlzLmdldFJlZihuYW1lKS5ub2RlKHRoaXMuZ2V0Tm9kZShyZWYuc2hhMSkpO1xuICAgICAgdGhpcy5nZXRSZWYobmFtZSkudmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICB9KTtcbiAgdGhpcy5yZWZzKCkuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgLy8gdGFnIGlzIHJlbW92ZWQgZnJvbSBhbm90aGVyIHNvdXJjZVxuICAgIGlmIChyZWYuaXNSZW1vdGVUYWcgJiYgKCFyZWYudmVyc2lvbiB8fCByZWYudmVyc2lvbiA8IHZlcnNpb24pKSB7XG4gICAgICByZWYucmVtb3ZlKHRydWUpO1xuICAgIH1cbiAgfSk7XG59XG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuY2hlY2tIZWFkTW92ZSA9IGZ1bmN0aW9uKHRvTm9kZSkge1xuICBpZiAodGhpcy5IRUFEKCkgPT09IHRvTm9kZSkge1xuICAgIHRoaXMuSEVBRHJlZi5ub2RlKHRvTm9kZSk7XG4gIH1cbn1cbiIsInZhciBnZXRFZGdlTW9kZWxXaXRoRCA9IGZ1bmN0aW9uKGQsIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZURhc2hhcnJheSwgbWFya2VyRW5kKSB7XG4gIHJldHVybiB7IGQ6IGQsXG4gICAgICAgICAgc3Ryb2tlOiBzdHJva2UgPyBzdHJva2UgOiAnIzRBNEE0QScsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoID8gc3Ryb2tlV2lkdGggOiAnOCcsXG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXkgPyBzdHJva2VEYXNoYXJyYXkgOiAnMTAsIDUnLFxuICAgICAgICAgIG1hcmtlckVuZDogbWFya2VyRW5kID8gbWFya2VyRW5kIDogJycgfTtcbn1cblxudmFyIGdldEVkZ2VNb2RlbCA9IGZ1bmN0aW9uKHNjeCwgc2N5LCB0Y3gsIHRjeSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlRGFzaGFycmF5LCBtYXJrZXJFbmQpIHtcbiAgcmV0dXJuIGdldEVkZ2VNb2RlbFdpdGhEKFwiTSBcIiArIHNjeCArIFwiIFwiICsgc2N5ICsgXCIgTCBcIiArIHRjeCArIFwiIFwiICsgdGN5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VEYXNoYXJyYXksIG1hcmtlckVuZCk7XG59XG5cbnZhciBnZXROb2RlTW9kZWwgPSBmdW5jdGlvbihjeCwgY3ksIHIsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZURhc2hhcnJheSkge1xuICByZXR1cm4geyBjeDogY3gsXG4gICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgIHI6IHIsXG4gICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICBzdHJva2U6IHN0cm9rZSA/IHN0cm9rZSA6ICcjNDFERTNDJyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggPyBzdHJva2VXaWR0aCA6ICc4JyxcbiAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSA/IHN0cm9rZURhc2hhcnJheSA6ICcxMCwgNScgfTtcbn1cblxuZnVuY3Rpb24gSG92ZXJWaWV3TW9kZWwoKSB7XG4gIHRoaXMuYmdFZGdlcyA9IFtdO1xuICB0aGlzLm5vZGVzID0gW107XG4gIHRoaXMuZmdFZGdlcyA9IFtdO1xufVxuXG5mdW5jdGlvbiBNZXJnZVZpZXdNb2RlbChncmFwaCwgaGVhZE5vZGUsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBIb3ZlclZpZXdNb2RlbC5jYWxsKHRoaXMpO1xuICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gIHRoaXMuYmdFZGdlcyA9IFsgZ2V0RWRnZU1vZGVsKGhlYWROb2RlLmN4KCksIChoZWFkTm9kZS5jeSgpIC0gMTEwKSwgaGVhZE5vZGUuY3goKSwgaGVhZE5vZGUuY3koKSksXG4gICAgICAgICAgICAgICAgZ2V0RWRnZU1vZGVsKGhlYWROb2RlLmN4KCksIChoZWFkTm9kZS5jeSgpIC0gMTEwKSwgbm9kZS5jeCgpLCBub2RlLmN5KCkpIF07XG4gIHRoaXMubm9kZXMgPSBbIGdldE5vZGVNb2RlbChoZWFkTm9kZS5jeCgpLCBoZWFkTm9kZS5jeSgpIC0gMTEwLCBNYXRoLm1heChoZWFkTm9kZS5yKCksIG5vZGUucigpKSwgJyMyNTI4MzMnLCAnIzQxREUzQycsICc4JywgJzEwLCA1JykgXTtcblxuICBncmFwaC5kaW1Db21taXQodHJ1ZSk7XG59XG5leHBvcnRzLk1lcmdlVmlld01vZGVsID0gTWVyZ2VWaWV3TW9kZWw7XG5NZXJnZVZpZXdNb2RlbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdyYXBoLmRpbUNvbW1pdChmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIFJlYmFzZVZpZXdNb2RlbChvbnRvLCBub2Rlc1RoYXRXaWxsTW92ZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEhvdmVyVmlld01vZGVsLmNhbGwodGhpcyk7XG4gIG5vZGVzVGhhdFdpbGxNb3ZlID0gbm9kZXNUaGF0V2lsbE1vdmUuc2xpY2UoMCwgLTEpO1xuXG4gIGlmIChub2Rlc1RoYXRXaWxsTW92ZS5sZW5ndGggPT0gMCkgcmV0dXJuO1xuXG4gIHRoaXMuYmdFZGdlcy5wdXNoKGdldEVkZ2VNb2RlbChvbnRvLmN4KCksIG9udG8uY3koKSwgb250by5jeCgpLCBvbnRvLmN5KCkgLSA2MCkpO1xuICBub2Rlc1RoYXRXaWxsTW92ZS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUsIGkpIHtcbiAgICB2YXIgY3kgPSBvbnRvLmN5KCkgKyAoLTkwICogKGkgKyAxKSk7XG4gICAgc2VsZi5ub2Rlcy5wdXNoKGdldE5vZGVNb2RlbChvbnRvLmN4KCksIGN5LCAyOCwgJ3RyYW5zcGFyZW50JykpO1xuICAgIGlmIChpICsgMSA8IG5vZGVzVGhhdFdpbGxNb3ZlLmxlbmd0aCkge1xuICAgICAgc2VsZi5iZ0VkZ2VzLnB1c2goZ2V0RWRnZU1vZGVsKG9udG8uY3goKSwgKGN5IC0gMjUpLCBvbnRvLmN4KCksIChjeSAtIDY1KSkpO1xuICAgIH1cbiAgfSk7XG59XG5leHBvcnRzLlJlYmFzZVZpZXdNb2RlbCA9IFJlYmFzZVZpZXdNb2RlbDtcblxuZnVuY3Rpb24gUmVzZXRWaWV3TW9kZWwobm9kZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBIb3ZlclZpZXdNb2RlbC5jYWxsKHRoaXMpO1xuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgIHNlbGYuZmdFZGdlcy5wdXNoKGdldEVkZ2VNb2RlbFdpdGhEKG5vZGUuZ2V0TGVmdFRvUmlnaHRTdHJpa2UoKSwgJ3JnYigyNTUsIDEyOSwgMzEpJywgJzgnLCAnMCwgMCcpKVxuICAgIHNlbGYuZmdFZGdlcy5wdXNoKGdldEVkZ2VNb2RlbFdpdGhEKG5vZGUuZ2V0UmlnaHRUb0xlZnRTdHJpa2UoKSwgJ3JnYigyNTUsIDEyOSwgMzEpJywgJzgnLCAnMCwgMCcpKTtcbiAgfSk7XG59XG5leHBvcnRzLlJlc2V0Vmlld01vZGVsID0gUmVzZXRWaWV3TW9kZWw7XG5cbmZ1bmN0aW9uIFB1c2hWaWV3TW9kZWwoZnJvbU5vZGUsIHRvTm9kZSkge1xuICBIb3ZlclZpZXdNb2RlbC5jYWxsKHRoaXMpO1xuICB0aGlzLmZnRWRnZXMgPSBbZ2V0RWRnZU1vZGVsKGZyb21Ob2RlLmN4KCksIGZyb21Ob2RlLmN5KCksIHRvTm9kZS5jeCgpLCAodG9Ob2RlLmN5KCkgKyA0MCksICdyZ2IoNjEsIDEzOSwgMjU1KScsICcxNScsICcxMCwgNScsICd1cmwoI3B1c2hBcnJvd0VuZCknICldO1xufVxuZXhwb3J0cy5QdXNoVmlld01vZGVsID0gUHVzaFZpZXdNb2RlbDtcblxuZnVuY3Rpb24gU3F1YXNoVmlld01vZGVsKGZyb20sIG9udG8pIHtcbiAgSG92ZXJWaWV3TW9kZWwuY2FsbCh0aGlzKTtcblxuICBsZXQgcGF0aCA9IGZyb20uZ2V0UGF0aFRvQ29tbW9uQW5jZXN0b3Iob250byk7XG5cbiAgaWYgKHBhdGgubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAocGF0aC5sZW5ndGggPT0gMSkge1xuICAgIHBhdGggPSBvbnRvLmdldFBhdGhUb0NvbW1vbkFuY2VzdG9yKGZyb20pXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ub2Rlcy5wdXNoKGdldE5vZGVNb2RlbChvbnRvLmN4KCksIG9udG8uY3koKSAtIDEyMCwgMjgsICd0cmFuc3BhcmVudCcpKTtcbiAgfVxuXG4gIHBhdGguc2xpY2UoMCwgLTEpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICB0aGlzLm5vZGVzLnB1c2goZ2V0Tm9kZU1vZGVsKG5vZGUuY3goKSwgbm9kZS5jeSgpLCBub2RlLnIoKSArIDIsICdyZ2JhKDEwMCwgNjAsIDIyMiwgMC44KScpKTtcbiAgfSk7XG59XG5leHBvcnRzLlNxdWFzaFZpZXdNb2RlbCA9IFNxdWFzaFZpZXdNb2RlbDtcbiIsInZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG5cbnZhciBTZWxlY3RhYmxlID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdGhpcy5zZWxlY3RlZCA9IGtvLmNvbXB1dGVkKHtcbiAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpID09IHRoaXM7XG4gICAgfSxcbiAgICB3cml0ZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAvLyB2YWwgaXMgdGhpcyBpZiB3ZSdyZSBjYWxsZWQgZnJvbSBhIGNsaWNrIGtvIGJpbmRpbmdcbiAgICAgIGlmICh2YWwgPT09IHRoaXMgfHwgdmFsID09PSB0cnVlKSB7XG4gICAgICAgIGdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpID09IHRoaXMpIHtcbiAgICAgICAgZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQobnVsbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvd25lcjogdGhpc1xuICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdGFibGU7XG4iXX0=

(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

const ko = require('knockout');
const components = require('ungit-components');
const programEvents = require('ungit-program-events');
const navigation = require('ungit-navigation');
const storage = require('ungit-storage');

components.register('app', (args) => {
  return new AppViewModel(args.appContainer, args.server);
});

class AppViewModel {
  constructor(appContainer, server) {
    this.appContainer = appContainer;
    this.server = server;
    this.template = 'app';
    if (window.location.search.indexOf('noheader=true') < 0) {
      this.header = components.create('header', { app: this });
    }
    this.dialog = ko.observable(null);
    this.repoList = ko.observableArray(this.getRepoList()); // visitedRepositories is legacy, remove in the next version
    this.repoList.subscribe((newValue) => { storage.setItem('repositories', JSON.stringify(newValue)); });
    this.content = ko.observable(components.create('home', { app: this }));
    this.currentVersion = ko.observable();
    this.latestVersion = ko.observable();
    this.showNewVersionAvailable = ko.observable();
    this.newVersionInstallCommand = (ungit.platform == 'win32' ? '' : 'sudo -H ') + 'npm update -g ungit';
    this.bugtrackingEnabled = ko.observable(ungit.config.bugtracking);
    this.bugtrackingNagscreenDismissed = ko.observable(storage.getItem('bugtrackingNagscreenDismissed'));
    this.showBugtrackingNagscreen = ko.computed(() => {
      return !this.bugtrackingEnabled() && !this.bugtrackingNagscreenDismissed();
    });
    this.gitVersionErrorDismissed = ko.observable(storage.getItem('gitVersionErrorDismissed'));
    this.gitVersionError = ko.observable();
    this.gitVersionErrorVisible = ko.computed(() => {
      return !ungit.config.gitVersionCheckOverride && this.gitVersionError() && !this.gitVersionErrorDismissed();
    });

    const NPSSurveyLastDismissed = parseInt(storage.getItem('NPSSurveyLastDismissed') || '0');
    const monthsSinceNPSLastDismissed = (Date.now() - NPSSurveyLastDismissed) / (1000 * 60 * 60 * 24 * 30);
    this.showNPSSurvey = ko.observable(monthsSinceNPSLastDismissed >= 6 && Math.random() < 0.01);
  }
  getRepoList() {
    const localStorageRepo = JSON.parse(storage.getItem('repositories') || storage.getItem('visitedRepositories') || '[]');
    const newRepos = localStorageRepo.concat(ungit.config.defaultRepositories || [])
      .filter((v, i, a) => a.indexOf(v) === i)
      .sort();
    storage.setItem('repositories', JSON.stringify(newRepos));
    return newRepos;
  }
  sendNPS(value) {
    keen.addEvent('survey-nps', {
      version: ungit.version,
      userHash: ungit.userHash,
      rating: value,
      bugtrackingEnabled: ungit.config.bugtracking,
      sendUsageStatistics: ungit.config.sendUsageStatistics
    });
    this.dismissNPSSurvey();
  }
  updateNode(parentElement) {
    ko.renderTemplate('app', this, {}, parentElement);
  }
  shown() {
    // The ungit.config constiable collections configuration from all different paths and only updates when
    // ungit is restarted
    if(!ungit.config.bugtracking) {
      // Whereas the userconfig only reflects what's in the ~/.ungitrc and updates directly,
      // but is only used for changing around the configuration. We need to check this here
      // since ungit may have crashed without the server crashing since we enabled bugtracking,
      // and we don't want to show the nagscreen twice in that case.
      this.server.getPromise('/userconfig')
        .then((userConfig) => this.bugtrackingEnabled(userConfig.bugtracking))
        .catch((e) => this.server.unhandledRejection(e));
    }

    this.server.getPromise('/latestversion')
      .then((version) => {
        if (!version) return;
        this.currentVersion(version.currentVersion);
        this.latestVersion(version.latestVersion);
        this.showNewVersionAvailable(!ungit.config.ungitVersionCheckOverride && version.outdated);
      }).catch((e) => this.server.unhandledRejection(e));
    this.server.getPromise('/gitversion')
      .then((gitversion) => {
        if (gitversion && !gitversion.satisfied) {
          this.gitVersionError(gitversion.error);
        }
      }).catch((e) => this.server.unhandledRejection(e));
  }
  updateAnimationFrame(deltaT) {
    if (this.content() && this.content().updateAnimationFrame) this.content().updateAnimationFrame(deltaT);
  }
  onProgramEvent(event) {
    if (event.event == 'request-credentials') this._handleCredentialsRequested(event);
    else if (event.event == 'request-show-dialog') this.showDialog(event.dialog);
    else if (event.event == 'request-remember-repo') this._handleRequestRememberRepo(event);

    if (this.content() && this.content().onProgramEvent)
      this.content().onProgramEvent(event);
    if (this.header && this.header.onProgramEvent) this.header.onProgramEvent(event);
  }
  _handleRequestRememberRepo(event) {
    const repoPath = event.repoPath;
    if (this.repoList.indexOf(repoPath) != -1) return;
    this.repoList.push(repoPath);
  }
  _handleCredentialsRequested(event) {
    // Only show one credentials dialog if we're asked to show another one while the first one is open
    // This happens for instance when we fetch nodes and remote tags at the same time
    if (!this._isShowingCredentialsDialog) {
      this._isShowingCredentialsDialog = true;
      components.create('credentialsdialog', {remote: event.remote}).show().closeThen((diag) => {
        this._isShowingCredentialsDialog = false;
        programEvents.dispatch({ event: 'request-credentials-response', username: diag.username(), password: diag.password() });
      });
    }
  }
  showDialog(dialog) {
    this.dialog(dialog.closeThen(() => {
      this.dialog(null);
      return dialog;
    }));
  }
  gitSetUserConfig(bugTracking, sendUsageStatistics) {
    this.server.getPromise('/userconfig')
      .then((userConfig) => {
        userConfig.bugtracking = bugTracking;
        if (sendUsageStatistics != undefined) userConfig.sendUsageStatistics = sendUsageStatistics;
        return this.server.postPromise('/userconfig', userConfig)
          .then(() => { this.bugtrackingEnabled(bugTracking); });
      });
  }
  enableBugtrackingAndStatistics() {
    this.gitSetUserConfig(true, true);
  }
  enableBugtracking() {
    this.gitSetUserConfig(true);
  }
  dismissBugtrackingNagscreen() {
    storage.setItem('bugtrackingNagscreenDismissed', true);
    this.bugtrackingNagscreenDismissed(true);
  }
  dismissGitVersionError() {
    storage.setItem('gitVersionErrorDismissed', true);
    this.gitVersionErrorDismissed(true);
  }
  dismissNPSSurvey() {
    this.showNPSSurvey(false);
    storage.setItem('NPSSurveyLastDismissed', Date.now());
  }
  dismissNewVersion() {
    this.showNewVersionAvailable(false);
  }
  templateChooser(data) {
    if (!data) return '';
    return data.template;
  }
}

},{"knockout":"knockout","ungit-components":"ungit-components","ungit-navigation":"ungit-navigation","ungit-program-events":"ungit-program-events","ungit-storage":"ungit-storage"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL2FwcC9hcHAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIlxuY29uc3Qga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuY29uc3QgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbmNvbnN0IHByb2dyYW1FdmVudHMgPSByZXF1aXJlKCd1bmdpdC1wcm9ncmFtLWV2ZW50cycpO1xuY29uc3QgbmF2aWdhdGlvbiA9IHJlcXVpcmUoJ3VuZ2l0LW5hdmlnYXRpb24nKTtcbmNvbnN0IHN0b3JhZ2UgPSByZXF1aXJlKCd1bmdpdC1zdG9yYWdlJyk7XG5cbmNvbXBvbmVudHMucmVnaXN0ZXIoJ2FwcCcsIChhcmdzKSA9PiB7XG4gIHJldHVybiBuZXcgQXBwVmlld01vZGVsKGFyZ3MuYXBwQ29udGFpbmVyLCBhcmdzLnNlcnZlcik7XG59KTtcblxuY2xhc3MgQXBwVmlld01vZGVsIHtcbiAgY29uc3RydWN0b3IoYXBwQ29udGFpbmVyLCBzZXJ2ZXIpIHtcbiAgICB0aGlzLmFwcENvbnRhaW5lciA9IGFwcENvbnRhaW5lcjtcbiAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICB0aGlzLnRlbXBsYXRlID0gJ2FwcCc7XG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guaW5kZXhPZignbm9oZWFkZXI9dHJ1ZScpIDwgMCkge1xuICAgICAgdGhpcy5oZWFkZXIgPSBjb21wb25lbnRzLmNyZWF0ZSgnaGVhZGVyJywgeyBhcHA6IHRoaXMgfSk7XG4gICAgfVxuICAgIHRoaXMuZGlhbG9nID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgICB0aGlzLnJlcG9MaXN0ID0ga28ub2JzZXJ2YWJsZUFycmF5KHRoaXMuZ2V0UmVwb0xpc3QoKSk7IC8vIHZpc2l0ZWRSZXBvc2l0b3JpZXMgaXMgbGVnYWN5LCByZW1vdmUgaW4gdGhlIG5leHQgdmVyc2lvblxuICAgIHRoaXMucmVwb0xpc3Quc3Vic2NyaWJlKChuZXdWYWx1ZSkgPT4geyBzdG9yYWdlLnNldEl0ZW0oJ3JlcG9zaXRvcmllcycsIEpTT04uc3RyaW5naWZ5KG5ld1ZhbHVlKSk7IH0pO1xuICAgIHRoaXMuY29udGVudCA9IGtvLm9ic2VydmFibGUoY29tcG9uZW50cy5jcmVhdGUoJ2hvbWUnLCB7IGFwcDogdGhpcyB9KSk7XG4gICAgdGhpcy5jdXJyZW50VmVyc2lvbiA9IGtvLm9ic2VydmFibGUoKTtcbiAgICB0aGlzLmxhdGVzdFZlcnNpb24gPSBrby5vYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5zaG93TmV3VmVyc2lvbkF2YWlsYWJsZSA9IGtvLm9ic2VydmFibGUoKTtcbiAgICB0aGlzLm5ld1ZlcnNpb25JbnN0YWxsQ29tbWFuZCA9ICh1bmdpdC5wbGF0Zm9ybSA9PSAnd2luMzInID8gJycgOiAnc3VkbyAtSCAnKSArICducG0gdXBkYXRlIC1nIHVuZ2l0JztcbiAgICB0aGlzLmJ1Z3RyYWNraW5nRW5hYmxlZCA9IGtvLm9ic2VydmFibGUodW5naXQuY29uZmlnLmJ1Z3RyYWNraW5nKTtcbiAgICB0aGlzLmJ1Z3RyYWNraW5nTmFnc2NyZWVuRGlzbWlzc2VkID0ga28ub2JzZXJ2YWJsZShzdG9yYWdlLmdldEl0ZW0oJ2J1Z3RyYWNraW5nTmFnc2NyZWVuRGlzbWlzc2VkJykpO1xuICAgIHRoaXMuc2hvd0J1Z3RyYWNraW5nTmFnc2NyZWVuID0ga28uY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgcmV0dXJuICF0aGlzLmJ1Z3RyYWNraW5nRW5hYmxlZCgpICYmICF0aGlzLmJ1Z3RyYWNraW5nTmFnc2NyZWVuRGlzbWlzc2VkKCk7XG4gICAgfSk7XG4gICAgdGhpcy5naXRWZXJzaW9uRXJyb3JEaXNtaXNzZWQgPSBrby5vYnNlcnZhYmxlKHN0b3JhZ2UuZ2V0SXRlbSgnZ2l0VmVyc2lvbkVycm9yRGlzbWlzc2VkJykpO1xuICAgIHRoaXMuZ2l0VmVyc2lvbkVycm9yID0ga28ub2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuZ2l0VmVyc2lvbkVycm9yVmlzaWJsZSA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgIHJldHVybiAhdW5naXQuY29uZmlnLmdpdFZlcnNpb25DaGVja092ZXJyaWRlICYmIHRoaXMuZ2l0VmVyc2lvbkVycm9yKCkgJiYgIXRoaXMuZ2l0VmVyc2lvbkVycm9yRGlzbWlzc2VkKCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBOUFNTdXJ2ZXlMYXN0RGlzbWlzc2VkID0gcGFyc2VJbnQoc3RvcmFnZS5nZXRJdGVtKCdOUFNTdXJ2ZXlMYXN0RGlzbWlzc2VkJykgfHwgJzAnKTtcbiAgICBjb25zdCBtb250aHNTaW5jZU5QU0xhc3REaXNtaXNzZWQgPSAoRGF0ZS5ub3coKSAtIE5QU1N1cnZleUxhc3REaXNtaXNzZWQpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQgKiAzMCk7XG4gICAgdGhpcy5zaG93TlBTU3VydmV5ID0ga28ub2JzZXJ2YWJsZShtb250aHNTaW5jZU5QU0xhc3REaXNtaXNzZWQgPj0gNiAmJiBNYXRoLnJhbmRvbSgpIDwgMC4wMSk7XG4gIH1cbiAgZ2V0UmVwb0xpc3QoKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yYWdlUmVwbyA9IEpTT04ucGFyc2Uoc3RvcmFnZS5nZXRJdGVtKCdyZXBvc2l0b3JpZXMnKSB8fCBzdG9yYWdlLmdldEl0ZW0oJ3Zpc2l0ZWRSZXBvc2l0b3JpZXMnKSB8fCAnW10nKTtcbiAgICBjb25zdCBuZXdSZXBvcyA9IGxvY2FsU3RvcmFnZVJlcG8uY29uY2F0KHVuZ2l0LmNvbmZpZy5kZWZhdWx0UmVwb3NpdG9yaWVzIHx8IFtdKVxuICAgICAgLmZpbHRlcigodiwgaSwgYSkgPT4gYS5pbmRleE9mKHYpID09PSBpKVxuICAgICAgLnNvcnQoKTtcbiAgICBzdG9yYWdlLnNldEl0ZW0oJ3JlcG9zaXRvcmllcycsIEpTT04uc3RyaW5naWZ5KG5ld1JlcG9zKSk7XG4gICAgcmV0dXJuIG5ld1JlcG9zO1xuICB9XG4gIHNlbmROUFModmFsdWUpIHtcbiAgICBrZWVuLmFkZEV2ZW50KCdzdXJ2ZXktbnBzJywge1xuICAgICAgdmVyc2lvbjogdW5naXQudmVyc2lvbixcbiAgICAgIHVzZXJIYXNoOiB1bmdpdC51c2VySGFzaCxcbiAgICAgIHJhdGluZzogdmFsdWUsXG4gICAgICBidWd0cmFja2luZ0VuYWJsZWQ6IHVuZ2l0LmNvbmZpZy5idWd0cmFja2luZyxcbiAgICAgIHNlbmRVc2FnZVN0YXRpc3RpY3M6IHVuZ2l0LmNvbmZpZy5zZW5kVXNhZ2VTdGF0aXN0aWNzXG4gICAgfSk7XG4gICAgdGhpcy5kaXNtaXNzTlBTU3VydmV5KCk7XG4gIH1cbiAgdXBkYXRlTm9kZShwYXJlbnRFbGVtZW50KSB7XG4gICAga28ucmVuZGVyVGVtcGxhdGUoJ2FwcCcsIHRoaXMsIHt9LCBwYXJlbnRFbGVtZW50KTtcbiAgfVxuICBzaG93bigpIHtcbiAgICAvLyBUaGUgdW5naXQuY29uZmlnIGNvbnN0aWFibGUgY29sbGVjdGlvbnMgY29uZmlndXJhdGlvbiBmcm9tIGFsbCBkaWZmZXJlbnQgcGF0aHMgYW5kIG9ubHkgdXBkYXRlcyB3aGVuXG4gICAgLy8gdW5naXQgaXMgcmVzdGFydGVkXG4gICAgaWYoIXVuZ2l0LmNvbmZpZy5idWd0cmFja2luZykge1xuICAgICAgLy8gV2hlcmVhcyB0aGUgdXNlcmNvbmZpZyBvbmx5IHJlZmxlY3RzIHdoYXQncyBpbiB0aGUgfi8udW5naXRyYyBhbmQgdXBkYXRlcyBkaXJlY3RseSxcbiAgICAgIC8vIGJ1dCBpcyBvbmx5IHVzZWQgZm9yIGNoYW5naW5nIGFyb3VuZCB0aGUgY29uZmlndXJhdGlvbi4gV2UgbmVlZCB0byBjaGVjayB0aGlzIGhlcmVcbiAgICAgIC8vIHNpbmNlIHVuZ2l0IG1heSBoYXZlIGNyYXNoZWQgd2l0aG91dCB0aGUgc2VydmVyIGNyYXNoaW5nIHNpbmNlIHdlIGVuYWJsZWQgYnVndHJhY2tpbmcsXG4gICAgICAvLyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBzaG93IHRoZSBuYWdzY3JlZW4gdHdpY2UgaW4gdGhhdCBjYXNlLlxuICAgICAgdGhpcy5zZXJ2ZXIuZ2V0UHJvbWlzZSgnL3VzZXJjb25maWcnKVxuICAgICAgICAudGhlbigodXNlckNvbmZpZykgPT4gdGhpcy5idWd0cmFja2luZ0VuYWJsZWQodXNlckNvbmZpZy5idWd0cmFja2luZykpXG4gICAgICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlcnZlci5nZXRQcm9taXNlKCcvbGF0ZXN0dmVyc2lvbicpXG4gICAgICAudGhlbigodmVyc2lvbikgPT4ge1xuICAgICAgICBpZiAoIXZlcnNpb24pIHJldHVybjtcbiAgICAgICAgdGhpcy5jdXJyZW50VmVyc2lvbih2ZXJzaW9uLmN1cnJlbnRWZXJzaW9uKTtcbiAgICAgICAgdGhpcy5sYXRlc3RWZXJzaW9uKHZlcnNpb24ubGF0ZXN0VmVyc2lvbik7XG4gICAgICAgIHRoaXMuc2hvd05ld1ZlcnNpb25BdmFpbGFibGUoIXVuZ2l0LmNvbmZpZy51bmdpdFZlcnNpb25DaGVja092ZXJyaWRlICYmIHZlcnNpb24ub3V0ZGF0ZWQpO1xuICAgICAgfSkuY2F0Y2goKGUpID0+IHRoaXMuc2VydmVyLnVuaGFuZGxlZFJlamVjdGlvbihlKSk7XG4gICAgdGhpcy5zZXJ2ZXIuZ2V0UHJvbWlzZSgnL2dpdHZlcnNpb24nKVxuICAgICAgLnRoZW4oKGdpdHZlcnNpb24pID0+IHtcbiAgICAgICAgaWYgKGdpdHZlcnNpb24gJiYgIWdpdHZlcnNpb24uc2F0aXNmaWVkKSB7XG4gICAgICAgICAgdGhpcy5naXRWZXJzaW9uRXJyb3IoZ2l0dmVyc2lvbi5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpO1xuICB9XG4gIHVwZGF0ZUFuaW1hdGlvbkZyYW1lKGRlbHRhVCkge1xuICAgIGlmICh0aGlzLmNvbnRlbnQoKSAmJiB0aGlzLmNvbnRlbnQoKS51cGRhdGVBbmltYXRpb25GcmFtZSkgdGhpcy5jb250ZW50KCkudXBkYXRlQW5pbWF0aW9uRnJhbWUoZGVsdGFUKTtcbiAgfVxuICBvblByb2dyYW1FdmVudChldmVudCkge1xuICAgIGlmIChldmVudC5ldmVudCA9PSAncmVxdWVzdC1jcmVkZW50aWFscycpIHRoaXMuX2hhbmRsZUNyZWRlbnRpYWxzUmVxdWVzdGVkKGV2ZW50KTtcbiAgICBlbHNlIGlmIChldmVudC5ldmVudCA9PSAncmVxdWVzdC1zaG93LWRpYWxvZycpIHRoaXMuc2hvd0RpYWxvZyhldmVudC5kaWFsb2cpO1xuICAgIGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09ICdyZXF1ZXN0LXJlbWVtYmVyLXJlcG8nKSB0aGlzLl9oYW5kbGVSZXF1ZXN0UmVtZW1iZXJSZXBvKGV2ZW50KTtcblxuICAgIGlmICh0aGlzLmNvbnRlbnQoKSAmJiB0aGlzLmNvbnRlbnQoKS5vblByb2dyYW1FdmVudClcbiAgICAgIHRoaXMuY29udGVudCgpLm9uUHJvZ3JhbUV2ZW50KGV2ZW50KTtcbiAgICBpZiAodGhpcy5oZWFkZXIgJiYgdGhpcy5oZWFkZXIub25Qcm9ncmFtRXZlbnQpIHRoaXMuaGVhZGVyLm9uUHJvZ3JhbUV2ZW50KGV2ZW50KTtcbiAgfVxuICBfaGFuZGxlUmVxdWVzdFJlbWVtYmVyUmVwbyhldmVudCkge1xuICAgIGNvbnN0IHJlcG9QYXRoID0gZXZlbnQucmVwb1BhdGg7XG4gICAgaWYgKHRoaXMucmVwb0xpc3QuaW5kZXhPZihyZXBvUGF0aCkgIT0gLTEpIHJldHVybjtcbiAgICB0aGlzLnJlcG9MaXN0LnB1c2gocmVwb1BhdGgpO1xuICB9XG4gIF9oYW5kbGVDcmVkZW50aWFsc1JlcXVlc3RlZChldmVudCkge1xuICAgIC8vIE9ubHkgc2hvdyBvbmUgY3JlZGVudGlhbHMgZGlhbG9nIGlmIHdlJ3JlIGFza2VkIHRvIHNob3cgYW5vdGhlciBvbmUgd2hpbGUgdGhlIGZpcnN0IG9uZSBpcyBvcGVuXG4gICAgLy8gVGhpcyBoYXBwZW5zIGZvciBpbnN0YW5jZSB3aGVuIHdlIGZldGNoIG5vZGVzIGFuZCByZW1vdGUgdGFncyBhdCB0aGUgc2FtZSB0aW1lXG4gICAgaWYgKCF0aGlzLl9pc1Nob3dpbmdDcmVkZW50aWFsc0RpYWxvZykge1xuICAgICAgdGhpcy5faXNTaG93aW5nQ3JlZGVudGlhbHNEaWFsb2cgPSB0cnVlO1xuICAgICAgY29tcG9uZW50cy5jcmVhdGUoJ2NyZWRlbnRpYWxzZGlhbG9nJywge3JlbW90ZTogZXZlbnQucmVtb3RlfSkuc2hvdygpLmNsb3NlVGhlbigoZGlhZykgPT4ge1xuICAgICAgICB0aGlzLl9pc1Nob3dpbmdDcmVkZW50aWFsc0RpYWxvZyA9IGZhbHNlO1xuICAgICAgICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdyZXF1ZXN0LWNyZWRlbnRpYWxzLXJlc3BvbnNlJywgdXNlcm5hbWU6IGRpYWcudXNlcm5hbWUoKSwgcGFzc3dvcmQ6IGRpYWcucGFzc3dvcmQoKSB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzaG93RGlhbG9nKGRpYWxvZykge1xuICAgIHRoaXMuZGlhbG9nKGRpYWxvZy5jbG9zZVRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5kaWFsb2cobnVsbCk7XG4gICAgICByZXR1cm4gZGlhbG9nO1xuICAgIH0pKTtcbiAgfVxuICBnaXRTZXRVc2VyQ29uZmlnKGJ1Z1RyYWNraW5nLCBzZW5kVXNhZ2VTdGF0aXN0aWNzKSB7XG4gICAgdGhpcy5zZXJ2ZXIuZ2V0UHJvbWlzZSgnL3VzZXJjb25maWcnKVxuICAgICAgLnRoZW4oKHVzZXJDb25maWcpID0+IHtcbiAgICAgICAgdXNlckNvbmZpZy5idWd0cmFja2luZyA9IGJ1Z1RyYWNraW5nO1xuICAgICAgICBpZiAoc2VuZFVzYWdlU3RhdGlzdGljcyAhPSB1bmRlZmluZWQpIHVzZXJDb25maWcuc2VuZFVzYWdlU3RhdGlzdGljcyA9IHNlbmRVc2FnZVN0YXRpc3RpY3M7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL3VzZXJjb25maWcnLCB1c2VyQ29uZmlnKVxuICAgICAgICAgIC50aGVuKCgpID0+IHsgdGhpcy5idWd0cmFja2luZ0VuYWJsZWQoYnVnVHJhY2tpbmcpOyB9KTtcbiAgICAgIH0pO1xuICB9XG4gIGVuYWJsZUJ1Z3RyYWNraW5nQW5kU3RhdGlzdGljcygpIHtcbiAgICB0aGlzLmdpdFNldFVzZXJDb25maWcodHJ1ZSwgdHJ1ZSk7XG4gIH1cbiAgZW5hYmxlQnVndHJhY2tpbmcoKSB7XG4gICAgdGhpcy5naXRTZXRVc2VyQ29uZmlnKHRydWUpO1xuICB9XG4gIGRpc21pc3NCdWd0cmFja2luZ05hZ3NjcmVlbigpIHtcbiAgICBzdG9yYWdlLnNldEl0ZW0oJ2J1Z3RyYWNraW5nTmFnc2NyZWVuRGlzbWlzc2VkJywgdHJ1ZSk7XG4gICAgdGhpcy5idWd0cmFja2luZ05hZ3NjcmVlbkRpc21pc3NlZCh0cnVlKTtcbiAgfVxuICBkaXNtaXNzR2l0VmVyc2lvbkVycm9yKCkge1xuICAgIHN0b3JhZ2Uuc2V0SXRlbSgnZ2l0VmVyc2lvbkVycm9yRGlzbWlzc2VkJywgdHJ1ZSk7XG4gICAgdGhpcy5naXRWZXJzaW9uRXJyb3JEaXNtaXNzZWQodHJ1ZSk7XG4gIH1cbiAgZGlzbWlzc05QU1N1cnZleSgpIHtcbiAgICB0aGlzLnNob3dOUFNTdXJ2ZXkoZmFsc2UpO1xuICAgIHN0b3JhZ2Uuc2V0SXRlbSgnTlBTU3VydmV5TGFzdERpc21pc3NlZCcsIERhdGUubm93KCkpO1xuICB9XG4gIGRpc21pc3NOZXdWZXJzaW9uKCkge1xuICAgIHRoaXMuc2hvd05ld1ZlcnNpb25BdmFpbGFibGUoZmFsc2UpO1xuICB9XG4gIHRlbXBsYXRlQ2hvb3NlcihkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGRhdGEudGVtcGxhdGU7XG4gIH1cbn1cbiJdfQ==

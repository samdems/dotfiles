(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

var ko = require('knockout');
var _ = require('lodash');
var components = require('ungit-components');
var programEvents = require('ungit-program-events');
var Promise = require('bluebird');

components.register('remotes', function(args) {
  return new RemotesViewModel(args.server, args.repoPath);
});

function RemotesViewModel(server, repoPath) {
  var self = this;
  this.repoPath = repoPath;
  this.server = server;
  this.remotes = ko.observable([]);
  this.currentRemote = ko.observable(null);
  this.currentRemote.subscribe(function(value) {
    programEvents.dispatch({ event: 'current-remote-changed', newRemote: value });
  });
  this.fetchLabel = ko.computed(function() {
    if (self.currentRemote()) return 'Fetch from ' + self.currentRemote();
    else return 'No remotes specified';
  })

  this.fetchEnabled = ko.computed(function() {
    return self.remotes().length > 0;
  });

  this.shouldAutoFetch = ungit.config.autoFetch;
  this.updateRemotes();
  this.isFetching = false;
  this.fetchDebounced = _.debounce(() => this.fetch({ tags: true }), 500);
}
RemotesViewModel.prototype.updateNode = function(parentElement) {
  ko.renderTemplate('remotes', this, {}, parentElement);
}
RemotesViewModel.prototype.clickFetch = function() { this.fetch({ nodes: true, tags: true }); }
RemotesViewModel.prototype.onProgramEvent = function(event) {
  if (event.event === 'working-tree-changed' || event.event === 'request-app-content-refresh' ||
    event.event === 'request-fetch-tags' || event.event === 'git-directory-changed') {
    this.fetchDebounced();
  }
}
RemotesViewModel.prototype.fetch = function(options) {
  if (this.isFetching || !this.currentRemote()) return;
  var self = this;

  this.isFetching = true;
  var tagPromise = options.tags ? self.server.getPromise('/remote/tags', { path: self.repoPath(), remote: self.currentRemote() }) : null;
  var fetchPromise = options.nodes ? self.server.postPromise('/fetch', { path: self.repoPath(), remote: self.currentRemote() }) : null;
  return Promise.props({tag: tagPromise, fetch: fetchPromise})
    .then((result) => {
      if (options.tags) {
        programEvents.dispatch({ event: 'remote-tags-update', tags: result.tag });
      }
      if (!this.server.isInternetConnected) {
        this.server.isInternetConnected = true;
      }
    }).catch((err) => {
      let errorMessage, stdout, stderr;
      try {
        errorMessage = `Ungit has failed to fetch a remote.  ${err.res.body.error}`;
        stdout = err.res.body.stdout;
        stderr = err.res.body.stderr;
      } catch (e) { errorMessage = ''; }

      if (errorMessage.indexOf('Could not resolve host') > -1) {
        if (this.server.isInternetConnected) {
          this.server.isInternetConnected = false;
          errorMessage = `Could not resolve host.  This usually means you are disconnected from internet and no longer push or fetch from remote. However, Ungit will be functional for local git operations.`;
          stdout = '';
          stderr = '';
        } else {
          // Message is already seen, just return
          return;
        }
      }

      programEvents.dispatch({ event: 'git-error', data: {
        isWarning: true,
        command: err.res.body.command,
        error: err.res.body.error,
        stdout: stdout,
        stderr: stderr,
        repoPath: err.res.body.workingDirectory
      } });
    }).finally(() => { this.isFetching = false; });
}

RemotesViewModel.prototype.updateRemotes = function() {
  var self = this;

  return this.server.getPromise('/remotes', { path: this.repoPath() })
    .then(function(remotes) {
      remotes = remotes.map(function(remote) {
        return {
          name: remote,
          changeRemote: function() { self.currentRemote(remote) }
        }
      });
      self.remotes(remotes);
      if (!self.currentRemote() && remotes.length > 0) {
        if (_.find(remotes, { 'name': 'origin' })) {// default to origin if it exists
          self.currentRemote('origin');
        } else {// otherwise take the first one
          self.currentRemote(remotes[0].name);
        }

        if (self.shouldAutoFetch) {
          self.shouldAutoFetch = false;
          return self.fetch({ nodes: true, tags: true });
        }
      }
    }).catch(function(err) {
      if (err.errorCode != 'not-a-repository') self.server.unhandledRejection(err);
    });
}
RemotesViewModel.prototype.showAddRemoteDialog = function() {
  var self = this;
  components.create('addremotedialog')
    .show()
    .closeThen(function(diag) {
      if(diag.isSubmitted()) {
        return self.server.postPromise('/remotes/' + encodeURIComponent(diag.name()), { path: self.repoPath(), url: diag.url() })
          .then(function() { self.updateRemotes(); })
          .catch((e) => this.server.unhandledRejection(e));
      }
    });
}

RemotesViewModel.prototype.remoteRemove = function(remote) {
  var self = this;
  components.create('yesnodialog', { title: 'Are you sure?', details: 'Deleting ' + remote.name + ' remote cannot be undone with ungit.'})
    .show()
    .closeThen(function(diag) {
      if (diag.result()) {
        return self.server.delPromise('/remotes/' + remote.name, { path: self.repoPath() })
          .then(() => { self.updateRemotes(); })
          .catch((e) => this.server.unhandledRejection(e));
      }
    });
}

},{"bluebird":undefined,"knockout":"knockout","lodash":"lodash","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3JlbW90ZXMvcmVtb3Rlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIlxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbnZhciBwcm9ncmFtRXZlbnRzID0gcmVxdWlyZSgndW5naXQtcHJvZ3JhbS1ldmVudHMnKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcblxuY29tcG9uZW50cy5yZWdpc3RlcigncmVtb3RlcycsIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgcmV0dXJuIG5ldyBSZW1vdGVzVmlld01vZGVsKGFyZ3Muc2VydmVyLCBhcmdzLnJlcG9QYXRoKTtcbn0pO1xuXG5mdW5jdGlvbiBSZW1vdGVzVmlld01vZGVsKHNlcnZlciwgcmVwb1BhdGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJlcG9QYXRoID0gcmVwb1BhdGg7XG4gIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICB0aGlzLnJlbW90ZXMgPSBrby5vYnNlcnZhYmxlKFtdKTtcbiAgdGhpcy5jdXJyZW50UmVtb3RlID0ga28ub2JzZXJ2YWJsZShudWxsKTtcbiAgdGhpcy5jdXJyZW50UmVtb3RlLnN1YnNjcmliZShmdW5jdGlvbih2YWx1ZSkge1xuICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ2N1cnJlbnQtcmVtb3RlLWNoYW5nZWQnLCBuZXdSZW1vdGU6IHZhbHVlIH0pO1xuICB9KTtcbiAgdGhpcy5mZXRjaExhYmVsID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuY3VycmVudFJlbW90ZSgpKSByZXR1cm4gJ0ZldGNoIGZyb20gJyArIHNlbGYuY3VycmVudFJlbW90ZSgpO1xuICAgIGVsc2UgcmV0dXJuICdObyByZW1vdGVzIHNwZWNpZmllZCc7XG4gIH0pXG5cbiAgdGhpcy5mZXRjaEVuYWJsZWQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5yZW1vdGVzKCkubGVuZ3RoID4gMDtcbiAgfSk7XG5cbiAgdGhpcy5zaG91bGRBdXRvRmV0Y2ggPSB1bmdpdC5jb25maWcuYXV0b0ZldGNoO1xuICB0aGlzLnVwZGF0ZVJlbW90ZXMoKTtcbiAgdGhpcy5pc0ZldGNoaW5nID0gZmFsc2U7XG4gIHRoaXMuZmV0Y2hEZWJvdW5jZWQgPSBfLmRlYm91bmNlKCgpID0+IHRoaXMuZmV0Y2goeyB0YWdzOiB0cnVlIH0pLCA1MDApO1xufVxuUmVtb3Rlc1ZpZXdNb2RlbC5wcm90b3R5cGUudXBkYXRlTm9kZSA9IGZ1bmN0aW9uKHBhcmVudEVsZW1lbnQpIHtcbiAga28ucmVuZGVyVGVtcGxhdGUoJ3JlbW90ZXMnLCB0aGlzLCB7fSwgcGFyZW50RWxlbWVudCk7XG59XG5SZW1vdGVzVmlld01vZGVsLnByb3RvdHlwZS5jbGlja0ZldGNoID0gZnVuY3Rpb24oKSB7IHRoaXMuZmV0Y2goeyBub2RlczogdHJ1ZSwgdGFnczogdHJ1ZSB9KTsgfVxuUmVtb3Rlc1ZpZXdNb2RlbC5wcm90b3R5cGUub25Qcm9ncmFtRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICBpZiAoZXZlbnQuZXZlbnQgPT09ICd3b3JraW5nLXRyZWUtY2hhbmdlZCcgfHwgZXZlbnQuZXZlbnQgPT09ICdyZXF1ZXN0LWFwcC1jb250ZW50LXJlZnJlc2gnIHx8XG4gICAgZXZlbnQuZXZlbnQgPT09ICdyZXF1ZXN0LWZldGNoLXRhZ3MnIHx8IGV2ZW50LmV2ZW50ID09PSAnZ2l0LWRpcmVjdG9yeS1jaGFuZ2VkJykge1xuICAgIHRoaXMuZmV0Y2hEZWJvdW5jZWQoKTtcbiAgfVxufVxuUmVtb3Rlc1ZpZXdNb2RlbC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICh0aGlzLmlzRmV0Y2hpbmcgfHwgIXRoaXMuY3VycmVudFJlbW90ZSgpKSByZXR1cm47XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLmlzRmV0Y2hpbmcgPSB0cnVlO1xuICB2YXIgdGFnUHJvbWlzZSA9IG9wdGlvbnMudGFncyA/IHNlbGYuc2VydmVyLmdldFByb21pc2UoJy9yZW1vdGUvdGFncycsIHsgcGF0aDogc2VsZi5yZXBvUGF0aCgpLCByZW1vdGU6IHNlbGYuY3VycmVudFJlbW90ZSgpIH0pIDogbnVsbDtcbiAgdmFyIGZldGNoUHJvbWlzZSA9IG9wdGlvbnMubm9kZXMgPyBzZWxmLnNlcnZlci5wb3N0UHJvbWlzZSgnL2ZldGNoJywgeyBwYXRoOiBzZWxmLnJlcG9QYXRoKCksIHJlbW90ZTogc2VsZi5jdXJyZW50UmVtb3RlKCkgfSkgOiBudWxsO1xuICByZXR1cm4gUHJvbWlzZS5wcm9wcyh7dGFnOiB0YWdQcm9taXNlLCBmZXRjaDogZmV0Y2hQcm9taXNlfSlcbiAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy50YWdzKSB7XG4gICAgICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ3JlbW90ZS10YWdzLXVwZGF0ZScsIHRhZ3M6IHJlc3VsdC50YWcgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2VydmVyLmlzSW50ZXJuZXRDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXIuaXNJbnRlcm5ldENvbm5lY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgbGV0IGVycm9yTWVzc2FnZSwgc3Rkb3V0LCBzdGRlcnI7XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBgVW5naXQgaGFzIGZhaWxlZCB0byBmZXRjaCBhIHJlbW90ZS4gICR7ZXJyLnJlcy5ib2R5LmVycm9yfWA7XG4gICAgICAgIHN0ZG91dCA9IGVyci5yZXMuYm9keS5zdGRvdXQ7XG4gICAgICAgIHN0ZGVyciA9IGVyci5yZXMuYm9keS5zdGRlcnI7XG4gICAgICB9IGNhdGNoIChlKSB7IGVycm9yTWVzc2FnZSA9ICcnOyB9XG5cbiAgICAgIGlmIChlcnJvck1lc3NhZ2UuaW5kZXhPZignQ291bGQgbm90IHJlc29sdmUgaG9zdCcpID4gLTEpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyLmlzSW50ZXJuZXRDb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLnNlcnZlci5pc0ludGVybmV0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gYENvdWxkIG5vdCByZXNvbHZlIGhvc3QuICBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGFyZSBkaXNjb25uZWN0ZWQgZnJvbSBpbnRlcm5ldCBhbmQgbm8gbG9uZ2VyIHB1c2ggb3IgZmV0Y2ggZnJvbSByZW1vdGUuIEhvd2V2ZXIsIFVuZ2l0IHdpbGwgYmUgZnVuY3Rpb25hbCBmb3IgbG9jYWwgZ2l0IG9wZXJhdGlvbnMuYDtcbiAgICAgICAgICBzdGRvdXQgPSAnJztcbiAgICAgICAgICBzdGRlcnIgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNZXNzYWdlIGlzIGFscmVhZHkgc2VlbiwganVzdCByZXR1cm5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAnZ2l0LWVycm9yJywgZGF0YToge1xuICAgICAgICBpc1dhcm5pbmc6IHRydWUsXG4gICAgICAgIGNvbW1hbmQ6IGVyci5yZXMuYm9keS5jb21tYW5kLFxuICAgICAgICBlcnJvcjogZXJyLnJlcy5ib2R5LmVycm9yLFxuICAgICAgICBzdGRvdXQ6IHN0ZG91dCxcbiAgICAgICAgc3RkZXJyOiBzdGRlcnIsXG4gICAgICAgIHJlcG9QYXRoOiBlcnIucmVzLmJvZHkud29ya2luZ0RpcmVjdG9yeVxuICAgICAgfSB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHsgdGhpcy5pc0ZldGNoaW5nID0gZmFsc2U7IH0pO1xufVxuXG5SZW1vdGVzVmlld01vZGVsLnByb3RvdHlwZS51cGRhdGVSZW1vdGVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICByZXR1cm4gdGhpcy5zZXJ2ZXIuZ2V0UHJvbWlzZSgnL3JlbW90ZXMnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKHJlbW90ZXMpIHtcbiAgICAgIHJlbW90ZXMgPSByZW1vdGVzLm1hcChmdW5jdGlvbihyZW1vdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiByZW1vdGUsXG4gICAgICAgICAgY2hhbmdlUmVtb3RlOiBmdW5jdGlvbigpIHsgc2VsZi5jdXJyZW50UmVtb3RlKHJlbW90ZSkgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNlbGYucmVtb3RlcyhyZW1vdGVzKTtcbiAgICAgIGlmICghc2VsZi5jdXJyZW50UmVtb3RlKCkgJiYgcmVtb3Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChfLmZpbmQocmVtb3RlcywgeyAnbmFtZSc6ICdvcmlnaW4nIH0pKSB7Ly8gZGVmYXVsdCB0byBvcmlnaW4gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgc2VsZi5jdXJyZW50UmVtb3RlKCdvcmlnaW4nKTtcbiAgICAgICAgfSBlbHNlIHsvLyBvdGhlcndpc2UgdGFrZSB0aGUgZmlyc3Qgb25lXG4gICAgICAgICAgc2VsZi5jdXJyZW50UmVtb3RlKHJlbW90ZXNbMF0ubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5zaG91bGRBdXRvRmV0Y2gpIHtcbiAgICAgICAgICBzZWxmLnNob3VsZEF1dG9GZXRjaCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBzZWxmLmZldGNoKHsgbm9kZXM6IHRydWUsIHRhZ3M6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIuZXJyb3JDb2RlICE9ICdub3QtYS1yZXBvc2l0b3J5Jykgc2VsZi5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGVycik7XG4gICAgfSk7XG59XG5SZW1vdGVzVmlld01vZGVsLnByb3RvdHlwZS5zaG93QWRkUmVtb3RlRGlhbG9nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY29tcG9uZW50cy5jcmVhdGUoJ2FkZHJlbW90ZWRpYWxvZycpXG4gICAgLnNob3coKVxuICAgIC5jbG9zZVRoZW4oZnVuY3Rpb24oZGlhZykge1xuICAgICAgaWYoZGlhZy5pc1N1Ym1pdHRlZCgpKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNlcnZlci5wb3N0UHJvbWlzZSgnL3JlbW90ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChkaWFnLm5hbWUoKSksIHsgcGF0aDogc2VsZi5yZXBvUGF0aCgpLCB1cmw6IGRpYWcudXJsKCkgfSlcbiAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHsgc2VsZi51cGRhdGVSZW1vdGVzKCk7IH0pXG4gICAgICAgICAgLmNhdGNoKChlKSA9PiB0aGlzLnNlcnZlci51bmhhbmRsZWRSZWplY3Rpb24oZSkpO1xuICAgICAgfVxuICAgIH0pO1xufVxuXG5SZW1vdGVzVmlld01vZGVsLnByb3RvdHlwZS5yZW1vdGVSZW1vdmUgPSBmdW5jdGlvbihyZW1vdGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjb21wb25lbnRzLmNyZWF0ZSgneWVzbm9kaWFsb2cnLCB7IHRpdGxlOiAnQXJlIHlvdSBzdXJlPycsIGRldGFpbHM6ICdEZWxldGluZyAnICsgcmVtb3RlLm5hbWUgKyAnIHJlbW90ZSBjYW5ub3QgYmUgdW5kb25lIHdpdGggdW5naXQuJ30pXG4gICAgLnNob3coKVxuICAgIC5jbG9zZVRoZW4oZnVuY3Rpb24oZGlhZykge1xuICAgICAgaWYgKGRpYWcucmVzdWx0KCkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2VydmVyLmRlbFByb21pc2UoJy9yZW1vdGVzLycgKyByZW1vdGUubmFtZSwgeyBwYXRoOiBzZWxmLnJlcG9QYXRoKCkgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiB7IHNlbGYudXBkYXRlUmVtb3RlcygpOyB9KVxuICAgICAgICAgIC5jYXRjaCgoZSkgPT4gdGhpcy5zZXJ2ZXIudW5oYW5kbGVkUmVqZWN0aW9uKGUpKTtcbiAgICAgIH1cbiAgICB9KTtcbn1cbiJdfQ==

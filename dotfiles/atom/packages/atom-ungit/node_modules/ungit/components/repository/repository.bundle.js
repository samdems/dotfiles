(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

var ko = require('knockout');
var components = require('ungit-components');
var _ = require('lodash');
const programEvents = require('ungit-program-events');

components.register('repository', function(args) {
  return new RepositoryViewModel(args.server, args.path);
});

var RepositoryViewModel = function(server, path) {
  var self = this;

  this.server = server;
  this.isBareDir = path.status() === 'bare';
  this.repoPath = path.repoPath;
  this.gitErrors = components.create('gitErrors', { server: server, repoPath: this.repoPath });
  this.graph = components.create('graph', { server: server, repoPath: this.repoPath });
  this.remotes = components.create('remotes', { server: server, repoPath: this.repoPath });
  this.submodules = components.create('submodules', { server: server, repoPath: this.repoPath });
  this.stash = this.isBareDir ? {} : components.create('stash', { server: server, repoPath: this.repoPath });
  this.staging = this.isBareDir ? {} : components.create('staging', { server: server, repoPath: this.repoPath, graph: this.graph });
  this.branches = components.create('branches', { server: server, graph: this.graph, repoPath: this.repoPath });
  this.repoPath.subscribe(function(value) { self.sever.watchRepository(value); });
  this.server.watchRepository(this.repoPath());
  this.showLog = self.isBareDir ? ko.observable(true) : self.staging.isStageValid;
  this.parentModulePath = ko.observable();
  this.parentModuleLink = ko.observable();
  this.isSubmodule = ko.computed(function() {
    return self.parentModulePath() && self.parentModuleLink();
  });
  this.refreshSubmoduleStatus();
  if (window.location.search.indexOf('noheader=true') >= 0) {
    this.refreshButton = components.create('refreshbutton');
  } else {
    this.refreshButton = false;
  }
}
RepositoryViewModel.prototype.updateNode = function(parentElement) {
  ko.renderTemplate('repository', this, {}, parentElement);
}
RepositoryViewModel.prototype.onProgramEvent = function(event) {
  if (this.gitErrors.onProgramEvent) this.gitErrors.onProgramEvent(event);
  if (this.graph.onProgramEvent) this.graph.onProgramEvent(event);
  if (this.staging.onProgramEvent) this.staging.onProgramEvent(event);
  if (this.stash.onProgramEvent) this.stash.onProgramEvent(event);
  if (this.remotes.onProgramEvent) this.remotes.onProgramEvent(event);
  if (this.submodules.onProgramEvent) this.submodules.onProgramEvent(event);
  if (this.branches.onProgramEvent) this.branches.onProgramEvent(event);
  if (event.event == 'connected') this.server.watchRepository(this.repoPath());

  // If we get a reconnect event it's usually because the server crashed and then restarted
  // or something like that, so we need to tell it to start watching the path again
}
RepositoryViewModel.prototype.updateAnimationFrame = function(deltaT) {
  if (this.graph.updateAnimationFrame) this.graph.updateAnimationFrame(deltaT);
}
RepositoryViewModel.prototype.refreshSubmoduleStatus = function() {
  var self = this;

  return this.server.getPromise('/baserepopath', { path: this.repoPath() })
    .then(function(baseRepoPath) {
      if (baseRepoPath.path) {
        return self.server.getProimse('/submodules', { path: baseRepoPath.path })
          .then(function(submodules) {
            if (Array.isArray(submodules)) {
              var baseName = self.repoPath().substring(baseRepoPath.path.length + 1);
              for (var n = 0; n < submodules.length; n++) {
                if (submodules[n].path === baseName) {
                  self.parentModulePath(baseRepoPath.path);
                  self.parentModuleLink('/#/repository?path=' + encodeURIComponent(baseRepoPath.path));
                  return;
                }
              }
            }
          });
      }
    }).catch(function(err) {
      self.parentModuleLink(undefined);
      self.parentModulePath(undefined);
    });
}

RepositoryViewModel.prototype.editGitignore = function() {
  var self = this;
  return this.server.getPromise('/gitignore', { path: this.repoPath() })
    .then((res) => {
      return components.create('texteditdialog', { title: `${this.repoPath()}${ungit.config.fileSeparator}.gitignore`, content: res.content })
        .show()
        .closeThen(function(diag) {
          if (diag.result()) {
            return self.server.putPromise('/gitignore', { path: self.repoPath(), data: diag.textAreaContent });
          }
        });
    }).catch(e => {
      // Not a git error but we are going to treat like one
      programEvents.dispatch({ event: 'git-error', data: {
        command: `fs.write "${this.repoPath()}${ungit.config.fileSeparator}.gitignore"`,
        error: e.message || e.errorSummary,
        stdout: '',
        stderr: e.stack,
        repoPath: this.repoPath()
      }});
    })
}

},{"knockout":"knockout","lodash":"lodash","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3JlcG9zaXRvcnkvcmVwb3NpdG9yeS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgcHJvZ3JhbUV2ZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LXByb2dyYW0tZXZlbnRzJyk7XG5cbmNvbXBvbmVudHMucmVnaXN0ZXIoJ3JlcG9zaXRvcnknLCBmdW5jdGlvbihhcmdzKSB7XG4gIHJldHVybiBuZXcgUmVwb3NpdG9yeVZpZXdNb2RlbChhcmdzLnNlcnZlciwgYXJncy5wYXRoKTtcbn0pO1xuXG52YXIgUmVwb3NpdG9yeVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHNlcnZlciwgcGF0aCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gIHRoaXMuaXNCYXJlRGlyID0gcGF0aC5zdGF0dXMoKSA9PT0gJ2JhcmUnO1xuICB0aGlzLnJlcG9QYXRoID0gcGF0aC5yZXBvUGF0aDtcbiAgdGhpcy5naXRFcnJvcnMgPSBjb21wb25lbnRzLmNyZWF0ZSgnZ2l0RXJyb3JzJywgeyBzZXJ2ZXI6IHNlcnZlciwgcmVwb1BhdGg6IHRoaXMucmVwb1BhdGggfSk7XG4gIHRoaXMuZ3JhcGggPSBjb21wb25lbnRzLmNyZWF0ZSgnZ3JhcGgnLCB7IHNlcnZlcjogc2VydmVyLCByZXBvUGF0aDogdGhpcy5yZXBvUGF0aCB9KTtcbiAgdGhpcy5yZW1vdGVzID0gY29tcG9uZW50cy5jcmVhdGUoJ3JlbW90ZXMnLCB7IHNlcnZlcjogc2VydmVyLCByZXBvUGF0aDogdGhpcy5yZXBvUGF0aCB9KTtcbiAgdGhpcy5zdWJtb2R1bGVzID0gY29tcG9uZW50cy5jcmVhdGUoJ3N1Ym1vZHVsZXMnLCB7IHNlcnZlcjogc2VydmVyLCByZXBvUGF0aDogdGhpcy5yZXBvUGF0aCB9KTtcbiAgdGhpcy5zdGFzaCA9IHRoaXMuaXNCYXJlRGlyID8ge30gOiBjb21wb25lbnRzLmNyZWF0ZSgnc3Rhc2gnLCB7IHNlcnZlcjogc2VydmVyLCByZXBvUGF0aDogdGhpcy5yZXBvUGF0aCB9KTtcbiAgdGhpcy5zdGFnaW5nID0gdGhpcy5pc0JhcmVEaXIgPyB7fSA6IGNvbXBvbmVudHMuY3JlYXRlKCdzdGFnaW5nJywgeyBzZXJ2ZXI6IHNlcnZlciwgcmVwb1BhdGg6IHRoaXMucmVwb1BhdGgsIGdyYXBoOiB0aGlzLmdyYXBoIH0pO1xuICB0aGlzLmJyYW5jaGVzID0gY29tcG9uZW50cy5jcmVhdGUoJ2JyYW5jaGVzJywgeyBzZXJ2ZXI6IHNlcnZlciwgZ3JhcGg6IHRoaXMuZ3JhcGgsIHJlcG9QYXRoOiB0aGlzLnJlcG9QYXRoIH0pO1xuICB0aGlzLnJlcG9QYXRoLnN1YnNjcmliZShmdW5jdGlvbih2YWx1ZSkgeyBzZWxmLnNldmVyLndhdGNoUmVwb3NpdG9yeSh2YWx1ZSk7IH0pO1xuICB0aGlzLnNlcnZlci53YXRjaFJlcG9zaXRvcnkodGhpcy5yZXBvUGF0aCgpKTtcbiAgdGhpcy5zaG93TG9nID0gc2VsZi5pc0JhcmVEaXIgPyBrby5vYnNlcnZhYmxlKHRydWUpIDogc2VsZi5zdGFnaW5nLmlzU3RhZ2VWYWxpZDtcbiAgdGhpcy5wYXJlbnRNb2R1bGVQYXRoID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLnBhcmVudE1vZHVsZUxpbmsgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuaXNTdWJtb2R1bGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5wYXJlbnRNb2R1bGVQYXRoKCkgJiYgc2VsZi5wYXJlbnRNb2R1bGVMaW5rKCk7XG4gIH0pO1xuICB0aGlzLnJlZnJlc2hTdWJtb2R1bGVTdGF0dXMoKTtcbiAgaWYgKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guaW5kZXhPZignbm9oZWFkZXI9dHJ1ZScpID49IDApIHtcbiAgICB0aGlzLnJlZnJlc2hCdXR0b24gPSBjb21wb25lbnRzLmNyZWF0ZSgncmVmcmVzaGJ1dHRvbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVmcmVzaEJ1dHRvbiA9IGZhbHNlO1xuICB9XG59XG5SZXBvc2l0b3J5Vmlld01vZGVsLnByb3RvdHlwZS51cGRhdGVOb2RlID0gZnVuY3Rpb24ocGFyZW50RWxlbWVudCkge1xuICBrby5yZW5kZXJUZW1wbGF0ZSgncmVwb3NpdG9yeScsIHRoaXMsIHt9LCBwYXJlbnRFbGVtZW50KTtcbn1cblJlcG9zaXRvcnlWaWV3TW9kZWwucHJvdG90eXBlLm9uUHJvZ3JhbUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgaWYgKHRoaXMuZ2l0RXJyb3JzLm9uUHJvZ3JhbUV2ZW50KSB0aGlzLmdpdEVycm9ycy5vblByb2dyYW1FdmVudChldmVudCk7XG4gIGlmICh0aGlzLmdyYXBoLm9uUHJvZ3JhbUV2ZW50KSB0aGlzLmdyYXBoLm9uUHJvZ3JhbUV2ZW50KGV2ZW50KTtcbiAgaWYgKHRoaXMuc3RhZ2luZy5vblByb2dyYW1FdmVudCkgdGhpcy5zdGFnaW5nLm9uUHJvZ3JhbUV2ZW50KGV2ZW50KTtcbiAgaWYgKHRoaXMuc3Rhc2gub25Qcm9ncmFtRXZlbnQpIHRoaXMuc3Rhc2gub25Qcm9ncmFtRXZlbnQoZXZlbnQpO1xuICBpZiAodGhpcy5yZW1vdGVzLm9uUHJvZ3JhbUV2ZW50KSB0aGlzLnJlbW90ZXMub25Qcm9ncmFtRXZlbnQoZXZlbnQpO1xuICBpZiAodGhpcy5zdWJtb2R1bGVzLm9uUHJvZ3JhbUV2ZW50KSB0aGlzLnN1Ym1vZHVsZXMub25Qcm9ncmFtRXZlbnQoZXZlbnQpO1xuICBpZiAodGhpcy5icmFuY2hlcy5vblByb2dyYW1FdmVudCkgdGhpcy5icmFuY2hlcy5vblByb2dyYW1FdmVudChldmVudCk7XG4gIGlmIChldmVudC5ldmVudCA9PSAnY29ubmVjdGVkJykgdGhpcy5zZXJ2ZXIud2F0Y2hSZXBvc2l0b3J5KHRoaXMucmVwb1BhdGgoKSk7XG5cbiAgLy8gSWYgd2UgZ2V0IGEgcmVjb25uZWN0IGV2ZW50IGl0J3MgdXN1YWxseSBiZWNhdXNlIHRoZSBzZXJ2ZXIgY3Jhc2hlZCBhbmQgdGhlbiByZXN0YXJ0ZWRcbiAgLy8gb3Igc29tZXRoaW5nIGxpa2UgdGhhdCwgc28gd2UgbmVlZCB0byB0ZWxsIGl0IHRvIHN0YXJ0IHdhdGNoaW5nIHRoZSBwYXRoIGFnYWluXG59XG5SZXBvc2l0b3J5Vmlld01vZGVsLnByb3RvdHlwZS51cGRhdGVBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGRlbHRhVCkge1xuICBpZiAodGhpcy5ncmFwaC51cGRhdGVBbmltYXRpb25GcmFtZSkgdGhpcy5ncmFwaC51cGRhdGVBbmltYXRpb25GcmFtZShkZWx0YVQpO1xufVxuUmVwb3NpdG9yeVZpZXdNb2RlbC5wcm90b3R5cGUucmVmcmVzaFN1Ym1vZHVsZVN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuIHRoaXMuc2VydmVyLmdldFByb21pc2UoJy9iYXNlcmVwb3BhdGgnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKGJhc2VSZXBvUGF0aCkge1xuICAgICAgaWYgKGJhc2VSZXBvUGF0aC5wYXRoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNlcnZlci5nZXRQcm9pbXNlKCcvc3VibW9kdWxlcycsIHsgcGF0aDogYmFzZVJlcG9QYXRoLnBhdGggfSlcbiAgICAgICAgICAudGhlbihmdW5jdGlvbihzdWJtb2R1bGVzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJtb2R1bGVzKSkge1xuICAgICAgICAgICAgICB2YXIgYmFzZU5hbWUgPSBzZWxmLnJlcG9QYXRoKCkuc3Vic3RyaW5nKGJhc2VSZXBvUGF0aC5wYXRoLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHN1Ym1vZHVsZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VibW9kdWxlc1tuXS5wYXRoID09PSBiYXNlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgc2VsZi5wYXJlbnRNb2R1bGVQYXRoKGJhc2VSZXBvUGF0aC5wYXRoKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50TW9kdWxlTGluaygnLyMvcmVwb3NpdG9yeT9wYXRoPScgKyBlbmNvZGVVUklDb21wb25lbnQoYmFzZVJlcG9QYXRoLnBhdGgpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYucGFyZW50TW9kdWxlTGluayh1bmRlZmluZWQpO1xuICAgICAgc2VsZi5wYXJlbnRNb2R1bGVQYXRoKHVuZGVmaW5lZCk7XG4gICAgfSk7XG59XG5cblJlcG9zaXRvcnlWaWV3TW9kZWwucHJvdG90eXBlLmVkaXRHaXRpZ25vcmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy5zZXJ2ZXIuZ2V0UHJvbWlzZSgnL2dpdGlnbm9yZScsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpIH0pXG4gICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudHMuY3JlYXRlKCd0ZXh0ZWRpdGRpYWxvZycsIHsgdGl0bGU6IGAke3RoaXMucmVwb1BhdGgoKX0ke3VuZ2l0LmNvbmZpZy5maWxlU2VwYXJhdG9yfS5naXRpZ25vcmVgLCBjb250ZW50OiByZXMuY29udGVudCB9KVxuICAgICAgICAuc2hvdygpXG4gICAgICAgIC5jbG9zZVRoZW4oZnVuY3Rpb24oZGlhZykge1xuICAgICAgICAgIGlmIChkaWFnLnJlc3VsdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zZXJ2ZXIucHV0UHJvbWlzZSgnL2dpdGlnbm9yZScsIHsgcGF0aDogc2VsZi5yZXBvUGF0aCgpLCBkYXRhOiBkaWFnLnRleHRBcmVhQ29udGVudCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgLy8gTm90IGEgZ2l0IGVycm9yIGJ1dCB3ZSBhcmUgZ29pbmcgdG8gdHJlYXQgbGlrZSBvbmVcbiAgICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ2dpdC1lcnJvcicsIGRhdGE6IHtcbiAgICAgICAgY29tbWFuZDogYGZzLndyaXRlIFwiJHt0aGlzLnJlcG9QYXRoKCl9JHt1bmdpdC5jb25maWcuZmlsZVNlcGFyYXRvcn0uZ2l0aWdub3JlXCJgLFxuICAgICAgICBlcnJvcjogZS5tZXNzYWdlIHx8IGUuZXJyb3JTdW1tYXJ5LFxuICAgICAgICBzdGRvdXQ6ICcnLFxuICAgICAgICBzdGRlcnI6IGUuc3RhY2ssXG4gICAgICAgIHJlcG9QYXRoOiB0aGlzLnJlcG9QYXRoKClcbiAgICAgIH19KTtcbiAgICB9KVxufVxuIl19
